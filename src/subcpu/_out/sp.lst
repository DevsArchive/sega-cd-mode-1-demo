00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Mode 1 Demo
00000000                            ; By Devon 2022
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; System program
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	include	"megacd.i"
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Mega Drive Framework
00000000                            ; By Devon 2022
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Mega CD definitions
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	include	"_config.i"
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Mode 1 Demo
00000000                            ; By Devon 2022
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Assembler options
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	opt	ae-					; Disable automatic evens
00000000                            	opt	m+					; Expand macros
00000000                            	opt	l.					; Local label character
00000000                            	opt	op+					; PC relative optimizations
00000000                            	opt	os+					; Short branch optimizations
00000000                            	opt	ow+					; Absolute word numessing optimizations
00000000                            	opt	oz+					; Zero offset optimizations
00000000                            	opt	oaq+					; ADDQ optimizations
00000000                            	opt	osq+					; SUBQ optimizations
00000000                            	opt	omq+					; MOVEQ optimizations
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Flags
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ; Debug flag
00000000 =00000001                  DEBUG		EQU	1
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; ROM information
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ; Copyright
00000000                            COPYRIGHT	EQUS	"DEVON"
00000000                            ; Game name
00000000                            GAME_NAME	EQUS	"MEGA CD MODE 1 DEMO BY DEVON"
00000000                            ; I/O support
00000000                            IO_SUPPORT	EQUS	"JC"
00000000                            ; Serial number
00000000                            SERIAL		EQUS	"00000000"
00000000                            ; Revision
00000000 =00000000                  REVISION	EQU	0
00000000                            ; Save RAM size
00000000 =00000000                  SRAM_SIZE	EQU	0
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            	include	"macros.i"
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Mega Drive Framework
00000000                            ; By Devon 2022
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; General macros
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Align to size boundary
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	bound - Size boundary
00000000                            ;	value - (OPTIONAL) Value to pad with
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ALIGN macro bound, value
00000000                            	local	pad
00000000                            	pad: = ((\bound)-((*)%(\bound)))%(\bound)
00000000                            	if narg>1
00000000                            		dcb.b	pad, \value
00000000                            	else
00000000                            		dcb.b	pad, 0
00000000                            	endif
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Align RS offset to be even
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            RSEVEN macro
00000000                            	rs.b	__rs&1
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Align RS offset to boundary
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            RSALIGN macro bound
00000000                            	rs.b	((\bound)-((__rs)%(\bound)))%(\bound)
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Generate repeated RS structure entries
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	name  - Entry name base
00000000                            ;	count - Number of entries
00000000                            ;	size  - Size of entry
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            RSRPT macro name, count, size
00000000                            	local	cnt
00000000                            	cnt: = 0
00000000                            	rept	\count
00000000                            		\name\\$Cnt:	rs.\0	\size
00000000                            		cnt: = cnt+1
00000000                            	endr
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Push RS value
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =00000000                  rsStack: = 0
00000000                            RSPUSH macro
00000000                            	rsStackVal\#rsStack\: =	__rs
00000000                            	rsStack: = rsStack+1
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Pop RS value
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            RSPOP macro
00000000                            	rsStack: = rsStack-1
00000000                            	rsset	rsStackVal\#rsStack
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Store string with fixed size
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	len - Length of string
00000000                            ;	str - String to store
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            STRSZ macro len, str
00000000                            	local	len2, str2
00000000                            	if strlen(\str)>(\len)
00000000                            		len2: =	\len
00000000                            		str2: SUBSTR 1,\len,\str
00000000                            	else
00000000                            		len2: =	strlen(\str)
00000000                            		str2: EQUS \str
00000000                            	endif
00000000                            	dc.b	"\str2"
00000000                            	dcb.b	(\len)-len2, " "
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Store number with fixed number of digits
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	digits - Number of digits
00000000                            ;	num    - Number to store
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            NUMSTR macro digits, num
00000000                            	local	num2, dig2, mask
00000000                            	num2: = \num
00000000                            	dig2: = 1
00000000                            	mask: = 10
00000000                            	while	(num2<>0)&(dig2<(\digits))
00000000                            		num2: = num2/10
00000000                            		mask: = mask*10
00000000                            		dig2: = dig2+1
00000000                            	endw
00000000                            		num2: = (\num)%mask
00000000                            	dcb.b	(\digits)-strlen("\#num2"), "0"
00000000                            	dc.b	"\#num2"
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Store month string
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	month - Month ID
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            MTHSTR macro month
00000000                            	local	mth
00000000                            	mth: SUBSTR 1+(((\month)-1)*3), 3+(((\month)-1)*3), &
00000000                            	dc.b	"\mth"
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Store build date
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BUILDDATE macro
00000000                            	NUMSTR	4, _year+1900
00000000                            	dc.b	"/"
00000000                            	NUMSTR	2, _month
00000000                            	dc.b	"/"
00000000                            	NUMSTR	2, _day
00000000                            	dc.b	" "
00000000                            	NUMSTR	2, _hours
00000000                            	dc.b	":"
00000000                            	NUMSTR	2, _minutes
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Check if a parameter is a data register
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	param  - Parameter to check
00000000                            ; RETURNS:
00000000                            ;	is_reg - 0 = Not data register
00000000                            ;	         1 = Data register
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ISDREG macro param
00000000                            	local	num_str, num
00000000                            	is_reg: = 0
00000000                            	if strlen("\param")=2
00000000                            		if instr("\param","d")=1
00000000                            			num_str: SUBSTR 2,2,"\param"
00000000                            			num: EQU \num_str
00000000                            			if (num>=0)&(num<=7)
00000000                            				is_reg: = 1
00000000                            			endif
00000000                            		endif
00000000                            	endif
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Check if a parameter is an address register
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	param  - Parameter to check
00000000                            ; RETURNS:
00000000                            ;	is_reg - 0 = Not address register
00000000                            ;	         1 = Address register
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ISAREG macro param
00000000                            	local	numStr, num
00000000                            	is_reg: = 0
00000000                            	if strlen("\param")=2
00000000                            		if instr("\param","a")=1
00000000                            			numStr: SUBSTR 2,2,"\param"
00000000                            			num: EQU \numStr
00000000                            			if (num>=0)&(num<=7)
00000000                            				is_reg: = 1
00000000                            			endif
00000000                            		endif
00000000                            	endif
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            	include	"axm68k.i"
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Change CPU
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            cpu:		macro
00000000                            		if strcmp("\1","z80")
00000000                            		pusho						; save previous options
00000000                            		cpu_mode:	= 1				; Z80
00000000                            		opt	an+					; 1234h style numbering
00000000                            		opt	ae-					; disable auto evens
00000000                            
00000000                            		else
00000000                            		if def(cpu_mode)
00000000                            		popo						; restore options
00000000                            		endc
00000000                            
00000000                            		cpu_mode:	= 0				; 68000 by default
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; AS compatibility
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            phase:		macros
00000000                            		obj \1
00000000                            
00000000                            dephase:	macros
00000000                            		objend
00000000                            
00000000                            listing:	macro
00000000                            		if strcmp("\1","on")
00000000                            		list
00000000                            		else
00000000                            		nolist
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            binclude:	macros
00000000                            		incbin	\_
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Z80 instruction set
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            getzreg:	macro						; convert register to numerical value
00000000                            		if strcmp("\1","a")
00000000                            		zreg: = 7
00000000                            		elseif strcmp("\1","b")
00000000                            		zreg: = 0
00000000                            		elseif strcmp("\1","c")
00000000                            		zreg: = 1
00000000                            		elseif strcmp("\1","d")
00000000                            		zreg: = 2
00000000                            		elseif strcmp("\1","e")
00000000                            		zreg: = 3
00000000                            		elseif strcmp("\1","h")
00000000                            		zreg: = 4
00000000                            		elseif strcmp("\1","l")
00000000                            		zreg: = 5
00000000                            		elseif strcmp("\1","(hl)")
00000000                            		zreg: = 6
00000000                            		else
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            getindex:	macro						; convert index register to register offset and value
00000000                            		if instr("\1","(ix")
00000000                            		ireg: = $dd
00000000                            		elseif instr("\1","(iy")
00000000                            		ireg: = $fd
00000000                            		else
00000000                            			fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000 =00000000                  ix: =		0						; allows (ix+n) to be parsed as n
00000000 =00000000                  iy: =		0
00000000                            
00000000                            adc:		macro
00000000                            		local num
00000000                            		if strcmp("\1","hl")
00000000                            			if strcmp("\2","bc")
00000000                            			dc.w $ed4a
00000000                            			elseif strcmp("\2","de")
00000000                            			dc.w $ed5a
00000000                            			elseif strcmp("\2","hl")
00000000                            			dc.w $ed6a
00000000                            			elseif strcmp("\2","sp")
00000000                            			dc.w $ed7a
00000000                            			else
00000000                            			fail
00000000                            			endc
00000000                            			mexit
00000000                            		endc
00000000                            
00000000                            		; "adc a, x" or "adc x"
00000000                            		if narg=2 & strcmp("\1","a")
00000000                            			shift					; ignore a
00000000                            		endc
00000000                            
00000000                            		if (narg=1) | (narg=2)
00000000                            			if instr("a b c d e h l (hl) ","\1\ ")
00000000                            			getzreg	\1
00000000                            			dc.b $88+zreg
00000000                            			elseif strcmp("\1","ixh")
00000000                            			dc.w $dd8c
00000000                            			elseif strcmp("\1","ixl")
00000000                            			dc.w $dd8d
00000000                            			elseif strcmp("\1","iyh")
00000000                            			dc.w $fd8c
00000000                            			elseif strcmp("\1","iyl")
00000000                            			dc.w $fd8d
00000000                            			elseif instr("\1","(i")			; adc (ix+n)
00000000                            				num: equ \1
00000000                            				getindex \1
00000000                            				dc.b ireg, $8e, num
00000000                            			else					; adc n
00000000                            			num: equ \1
00000000                            			dc.b $ce, num
00000000                            			endc
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            bit:		macro
00000000                            		local num, num2
00000000                            		num: equ \1
00000000                            		if instr("a b c d e h l (hl) ","\2\ ")
00000000                            		getzreg	\2
00000000                            		dc.b $cb, $40+(num*8)+zreg
00000000                            		elseif instr("\2","(i")				; bit n,(ix+n)
00000000                            			num2: equ \2
00000000                            			getindex \2
00000000                            			dc.b ireg, $cb, num2, $40+(num*8)
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            call:		macro
00000000                            		local num
00000000                            		if narg=1					; call n
00000000                            		num: equ \1
00000000                            		dc.b $cd
00000000                            		elseif narg=2					; call x, n
00000000                            			num: equ \2
00000000                            			if strcmp("\1","nz")
00000000                            			dc.b $c4
00000000                            			elseif strcmp("\1","z")
00000000                            			dc.b $cc
00000000                            			elseif strcmp("\1","nc")
00000000                            			dc.b $d4
00000000                            			elseif strcmp("\1","c")
00000000                            			dc.b $dc
00000000                            			elseif strcmp("\1","po")
00000000                            			dc.b $e4
00000000                            			elseif strcmp("\1","pe")
00000000                            			dc.b $ec
00000000                            			elseif strcmp("\1","p")
00000000                            			dc.b $f4
00000000                            			elseif strcmp("\1","m")
00000000                            			dc.b $fc
00000000                            			else
00000000                            				fail
00000000                            			endc
00000000                            
00000000                            			shift
00000000                            		else
00000000                            			fail
00000000                            		endc
00000000                            
00000000                            		dc.b num&$FF, num>>8
00000000                            		endm
00000000                            
00000000                            ccf:		macros
00000000                            		dc.b $3f
00000000                            
00000000                            
00000000                            cp:		macro
00000000                            		local num
00000000                            		if instr("a b c d e h l (hl) ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $b8+zreg
00000000                            		elseif strcmp("\1","ixh")
00000000                            		dc.w $ddbc
00000000                            		elseif strcmp("\1","ixl")
00000000                            		dc.w $ddbd
00000000                            		elseif strcmp("\1","iyh")
00000000                            		dc.w $fdbc
00000000                            		elseif strcmp("\1","iyl")
00000000                            		dc.w $fdbd
00000000                            		elseif instr("\1","(i")				; cp (ix+n)
00000000                            			num: equ \1
00000000                            			getindex \1
00000000                            			dc.b ireg, $be, num
00000000                            		else						; cp n
00000000                            		num: equ \1
00000000                            		dc.b $fe, num
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            cpd:		macros
00000000                            		dc.w $eda9
00000000                            
00000000                            
00000000                            cpdr:		macros
00000000                            		dc.w $edb9
00000000                            
00000000                            
00000000                            cpi:		macros
00000000                            		dc.w $eda1
00000000                            
00000000                            
00000000                            cpir:		macros
00000000                            		dc.w $edb1
00000000                            
00000000                            
00000000                            cpl:		macros
00000000                            		dc.b $2f
00000000                            
00000000                            
00000000                            daa:		macros
00000000                            		dc.b $27
00000000                            
00000000                            
00000000                            dec:		macro
00000000                            		local num
00000000                            		if instr("a b c d e h l ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $5+(zreg*8)
00000000                            		elseif strcmp("\1","ixh")
00000000                            		dc.w $dd25
00000000                            		elseif strcmp("\1","ixl")
00000000                            		dc.w $dd2d
00000000                            		elseif strcmp("\1","iyh")
00000000                            		dc.w $fd25
00000000                            		elseif strcmp("\1","iyl")
00000000                            		dc.w $fd2d
00000000                            		elseif strcmp("\1","bc")
00000000                            		dc.b $b
00000000                            		elseif strcmp("\1","de")
00000000                            		dc.b $1b
00000000                            		elseif strcmp("\1","hl")
00000000                            		dc.b $2b
00000000                            		elseif strcmp("\1","ix")
00000000                            		dc.w $dd2b
00000000                            		elseif strcmp("\1","iy")
00000000                            		dc.w $fd2b
00000000                            		elseif strcmp("\1","sp")
00000000                            		dc.b $3b
00000000                            		elseif instr("\1","(i")				; dec (ix+n)
00000000                            			num: equ \1
00000000                            			getindex \1
00000000                            			dc.b ireg, $35, num
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            di:		macros
00000000                            		dc.b $f3
00000000                            
00000000                            
00000000                            djnz:		macro
00000000                            		local num
00000000                            		num: equ \1
00000000                            		dc.b $10, num-*-2
00000000                            		endm
00000000                            
00000000                            
00000000                            ei:		macros
00000000                            		dc.b $fb
00000000                            
00000000                            
00000000                            ex:		macro
00000000                            		if strcmp("\_","af,af")				; ex af,af'
00000000                            		dc.b 8
00000000                            		elseif strcmp("\_","(sp),hl")
00000000                            		dc.b $e3
00000000                            		elseif strcmp("\_","(sp),ix")
00000000                            		dc.w $dde3
00000000                            		elseif strcmp("\_","(sp),iy")
00000000                            		dc.w $fde3
00000000                            		elseif strcmp("\_","de,hl")
00000000                            		dc.b $eb
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            exx:		macros
00000000                            		dc.b $d9
00000000                            
00000000                            
00000000                            halt:		macros
00000000                            		dc.b $76
00000000                            
00000000                            
00000000                            im:		macro
00000000                            		if \1=0
00000000                            		dc.w $ed46
00000000                            		elseif \1=1
00000000                            		dc.w $ed56
00000000                            		elseif \1=2
00000000                            		dc.w $ed5e
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            in:		macro
00000000                            		local num
00000000                            		if strcmp("\1","a")
00000000                            			if strcmp("\2","(c)")
00000000                            			dc.w $ed78
00000000                            			else					; in a,n
00000000                            			num: equ \2
00000000                            			dc.b $db, num
00000000                            			endc
00000000                            		elseif instr("b c d e h l ","\1\ ")&strcmp("\2","(c)")
00000000                            		getzreg	\1
00000000                            		dc.w $ed40+(zreg*8)
00000000                            		elseif strcmp("\1","(c)")
00000000                            		dc.w $ed70
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            inc:		macro
00000000                            		local num
00000000                            		if instr("a b c d e h l ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $4+(zreg*8)
00000000                            		elseif strcmp("\1","ixh")
00000000                            		dc.w $dd24
00000000                            		elseif strcmp("\1","ixl")
00000000                            		dc.w $dd2c
00000000                            		elseif strcmp("\1","iyh")
00000000                            		dc.w $fd24
00000000                            		elseif strcmp("\1","iyl")
00000000                            		dc.w $fd2c
00000000                            		elseif strcmp("\1","bc")
00000000                            		dc.b $3
00000000                            		elseif strcmp("\1","de")
00000000                            		dc.b $13
00000000                            		elseif strcmp("\1","hl")
00000000                            		dc.b $23
00000000                            		elseif strcmp("\1","ix")
00000000                            		dc.w $dd23
00000000                            		elseif strcmp("\1","iy")
00000000                            		dc.w $fd23
00000000                            		elseif strcmp("\1","sp")
00000000                            		dc.b $33
00000000                            		elseif instr("\1","(i")				; inc (ix+n)
00000000                            			num: equ \1
00000000                            			getindex \1
00000000                            			dc.b ireg, $34, num
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            ind:		macros
00000000                            		dc.w $edaa
00000000                            
00000000                            
00000000                            indr:		macros
00000000                            		dc.w $edba
00000000                            
00000000                            
00000000                            ini:		macros
00000000                            		dc.w $eda2
00000000                            
00000000                            
00000000                            inir:		macros
00000000                            		dc.w $edb2
00000000                            
00000000                            
00000000                            jp:		macro
00000000                            		local num
00000000                            		if strcmp("\1","(hl)")
00000000                            		dc.b $e9
00000000                            		elseif strcmp("\1","(ix)")
00000000                            		dc.w $dde9
00000000                            		elseif strcmp("\1","(iy)")
00000000                            		dc.w $fde9
00000000                            		else
00000000                            			if strcmp("\1","nz")
00000000                            			num: equ \2
00000000                            			dc.b $c2
00000000                            			elseif strcmp("\1","z")
00000000                            			num: equ \2
00000000                            			dc.b $ca
00000000                            			elseif strcmp("\1","nc")
00000000                            			num: equ \2
00000000                            			dc.b $d2
00000000                            			elseif strcmp("\1","c")
00000000                            			num: equ \2
00000000                            			dc.b $da
00000000                            			elseif strcmp("\1","po")
00000000                            			num: equ \2
00000000                            			dc.b $e2
00000000                            			elseif strcmp("\1","pe")
00000000                            			num: equ \2
00000000                            			dc.b $ea
00000000                            			elseif strcmp("\1","p")
00000000                            			num: equ \2
00000000                            			dc.b $f2
00000000                            			elseif strcmp("\1","m")
00000000                            			num: equ \2
00000000                            			dc.b $fa
00000000                            			else					; jp n
00000000                            			num: equ \1
00000000                            			dc.b $c3
00000000                            			endc
00000000                            			if narg=2
00000000                            			shift
00000000                            			endc
00000000                            			dc.b num&$FF, num>>8
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            jr:		macro
00000000                            		local num
00000000                            		if strcmp("\1","nz")
00000000                            		num: equ \2
00000000                            		dc.b $20
00000000                            		elseif strcmp("\1","z")
00000000                            		num: equ \2
00000000                            		dc.b $28
00000000                            		elseif strcmp("\1","nc")
00000000                            		num: equ \2
00000000                            		dc.b $30
00000000                            		elseif strcmp("\1","c")
00000000                            		num: equ \2
00000000                            		dc.b $38
00000000                            		else						; jr n
00000000                            		num: equ \1
00000000                            		dc.b $18
00000000                            		endc
00000000                            		if narg=2
00000000                            		shift
00000000                            		endc
00000000                            		dc.b num-*-1
00000000                            		;if ((num-*)>=-$80)&((num-*)<=$7f)
00000000                            		;fail
00000000                            		;endc
00000000                            		endm
00000000                            
00000000                            
00000000                            ld:		macro
00000000                            		local num, num2
00000000                            		if strcmp("\1","a")
00000000                            			if instr("a b c d e h l (hl) ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.b $78+zreg
00000000                            			elseif strcmp("\2","i")
00000000                            			dc.w $ed57
00000000                            			elseif strcmp("\2","r")
00000000                            			dc.w $ed5f
00000000                            			elseif strcmp("\2","ixh")
00000000                            			dc.w $dd7c
00000000                            			elseif strcmp("\2","ixl")
00000000                            			dc.w $dd7d
00000000                            			elseif strcmp("\2","iyh")
00000000                            			dc.w $fd7c
00000000                            			elseif strcmp("\2","iyl")
00000000                            			dc.w $fd7d
00000000                            			elseif strcmp("\2","(bc)")
00000000                            			dc.b $0a
00000000                            			elseif strcmp("\2","(de)")
00000000                            			dc.b $1a
00000000                            			elseif instr("\2","(i")			; ld a,(ix+n)
00000000                            				num: equ \2
00000000                            				getindex \2
00000000                            				dc.b ireg, $7e, num
00000000                            			else
00000000                            				num: equ \2
00000000                            				tmp_len: = strlen("\2")
00000000                            				tmp_fc:	substr	1,1,"\2"
00000000                            				tmp_lc:	substr	tmp_len,tmp_len,"\2"
00000000                            				if strcmp("\tmp_fc","(") & strcmp("\tmp_lc",")") ; ld a,(n)
00000000                            				dc.b $3a, num&$ff, num>>8
00000000                            				else				; ld a,n
00000000                            				dc.b $3e, num
00000000                            				endc
00000000                            			endc
00000000                            		elseif strcmp("\1","b")
00000000                            			if instr("a b c d e h l (hl) ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.b $40+zreg
00000000                            			elseif strcmp("\2","ixh")
00000000                            			dc.w $dd44
00000000                            			elseif strcmp("\2","ixl")
00000000                            			dc.w $dd45
00000000                            			elseif strcmp("\2","iyh")
00000000                            			dc.w $fd44
00000000                            			elseif strcmp("\2","iyl")
00000000                            			dc.w $fd45
00000000                            			elseif instr("\2","(i")			; ld b,(ix+n)
00000000                            				num: equ \2
00000000                            				getindex \2
00000000                            				dc.b ireg, $46, num
00000000                            			else					; ld b,n
00000000                            			num: equ \2
00000000                            			dc.b $6, num
00000000                            			endc
00000000                            		elseif strcmp("\1","c")
00000000                            			if instr("a b c d e h l (hl) ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.b $48+zreg
00000000                            			elseif strcmp("\2","ixh")
00000000                            			dc.w $dd4c
00000000                            			elseif strcmp("\2","ixl")
00000000                            			dc.w $dd4d
00000000                            			elseif strcmp("\2","iyh")
00000000                            			dc.w $fd4c
00000000                            			elseif strcmp("\2","iyl")
00000000                            			dc.w $fd4d
00000000                            			elseif instr("\2","(i")			; ld c,(ix+n)
00000000                            				num: equ \2
00000000                            				getindex \2
00000000                            				dc.b ireg, $4e, num
00000000                            			else					; ld c,n
00000000                            			num: equ \2
00000000                            			dc.b $e, num
00000000                            			endc
00000000                            		elseif strcmp("\1","d")
00000000                            			if instr("a b c d e h l (hl) ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.b $50+zreg
00000000                            			elseif strcmp("\2","ixh")
00000000                            			dc.w $dd54
00000000                            			elseif strcmp("\2","ixl")
00000000                            			dc.w $dd55
00000000                            			elseif strcmp("\2","iyh")
00000000                            			dc.w $fd54
00000000                            			elseif strcmp("\2","iyl")
00000000                            			dc.w $fd55
00000000                            			elseif instr("\2","(i")			; ld d,(ix+n)
00000000                            				num: equ \2
00000000                            				getindex \2
00000000                            				dc.b ireg, $56, num
00000000                            			else					; ld d,n
00000000                            			num: equ \2
00000000                            			dc.b $16, num
00000000                            			endc
00000000                            		elseif strcmp("\1","e")
00000000                            			if instr("a b c d e h l (hl) ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.b $58+zreg
00000000                            			elseif strcmp("\2","ixh")
00000000                            			dc.w $dd5c
00000000                            			elseif strcmp("\2","ixl")
00000000                            			dc.w $dd5d
00000000                            			elseif strcmp("\2","iyh")
00000000                            			dc.w $fd5c
00000000                            			elseif strcmp("\2","iyl")
00000000                            			dc.w $fd5d
00000000                            			elseif instr("\2","(i")			; ld e,(ix+n)
00000000                            				num: equ \2
00000000                            				getindex \2
00000000                            				dc.b ireg, $5e, num
00000000                            			else					; ld e,n
00000000                            			num: equ \2
00000000                            			dc.b $1e, num
00000000                            			endc
00000000                            		elseif strcmp("\1","h")
00000000                            			if instr("a b c d e h l (hl) ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.b $60+zreg
00000000                            			elseif instr("\2","(i")			; ld h,(ix+n)
00000000                            				num: equ \2
00000000                            				getindex \2
00000000                            				dc.b ireg, $66, num
00000000                            			else					; ld h,n
00000000                            			num: equ \2
00000000                            			dc.b $26, num
00000000                            			endc
00000000                            		elseif strcmp("\1","l")
00000000                            			if instr("a b c d e h l (hl) ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.b $68+zreg
00000000                            			elseif instr("\2","(i")			; ld l,(ix+n)
00000000                            				num: equ \2
00000000                            				getindex \2
00000000                            				dc.b ireg, $6e, num
00000000                            			else					; ld l,n
00000000                            			num: equ \2
00000000                            			dc.b $2e, num
00000000                            			endc
00000000                            		elseif strcmp("\1","i")
00000000                            		dc.w $ed47
00000000                            		elseif strcmp("\1","r")
00000000                            		dc.w $ed4f
00000000                            		elseif strcmp("\1","ixh")
00000000                            			if instr("a b c d e ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.w $dd60+zreg
00000000                            			elseif strcmp("\2","ixh")
00000000                            			dc.w $dd64
00000000                            			elseif strcmp("\2","ixl")
00000000                            			dc.w $dd65
00000000                            			else					; ld ixh,n
00000000                            			num: equ \2
00000000                            			dc.b $dd, $26, num
00000000                            			endc
00000000                            		elseif strcmp("\1","ixl")
00000000                            			if instr("a b c d e ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.w $dd68+zreg
00000000                            			elseif strcmp("\2","ixh")
00000000                            			dc.w $dd6c
00000000                            			elseif strcmp("\2","ixl")
00000000                            			dc.w $dd6d
00000000                            			else					; ld ixl,n
00000000                            			num: equ \2
00000000                            			dc.b $dd, $2e, num
00000000                            			endc
00000000                            		elseif strcmp("\1","iyh")
00000000                            			if instr("a b c d e ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.w $fd60+zreg
00000000                            			elseif strcmp("\2","iyh")
00000000                            			dc.w $fd64
00000000                            			elseif strcmp("\2","iyl")
00000000                            			dc.w $fd65
00000000                            			else					; ld iyh,n
00000000                            			num: equ \2
00000000                            			dc.b $fd, $26, num
00000000                            			endc
00000000                            		elseif strcmp("\1","iyl")
00000000                            			if instr("a b c d e ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.w $fd68+zreg
00000000                            			elseif strcmp("\2","iyh")
00000000                            			dc.w $fd6c
00000000                            			elseif strcmp("\2","iyl")
00000000                            			dc.w $fd6d
00000000                            			else					; ld iyl,n
00000000                            			num: equ \2
00000000                            			dc.b $fd, $2e, num
00000000                            			endc
00000000                            		elseif strcmp("\1","bc")
00000000                            			num: equ \2
00000000                            			tmp_len: = strlen("\2")
00000000                            			tmp_fc:	substr	1,1,"\2"
00000000                            			tmp_lc:	substr	tmp_len,tmp_len,"\2"
00000000                            			if strcmp("\tmp_fc","(") & strcmp("\tmp_lc",")") ; ld bc,(n)
00000000                            			dc.b $ed, $4b, num&$ff, num>>8
00000000                            			else					; ld bc,n
00000000                            			dc.b $1, num&$ff, num>>8
00000000                            			endc
00000000                            		elseif strcmp("\1","de")
00000000                            			num: equ \2
00000000                            			tmp_len: = strlen("\2")
00000000                            			tmp_fc:	substr	1,1,"\2"
00000000                            			tmp_lc:	substr	tmp_len,tmp_len,"\2"
00000000                            			if strcmp("\tmp_fc","(") & strcmp("\tmp_lc",")") ; ld de,(n)
00000000                            			dc.b $ed, $5b, num&$ff, num>>8
00000000                            			else					; ld de,n
00000000                            			dc.b $11, num&$ff, num>>8
00000000                            			endc
00000000                            		elseif strcmp("\1","hl")
00000000                            			num: equ \2
00000000                            			tmp_len: = strlen("\2")
00000000                            			tmp_fc:	substr	1,1,"\2"
00000000                            			tmp_lc:	substr	tmp_len,tmp_len,"\2"
00000000                            			if strcmp("\tmp_fc","(") & strcmp("\tmp_lc",")") ; ld hl,(n)
00000000                            			dc.b $ed, $6b, num&$ff, num>>8
00000000                            			else					; ld hl,n
00000000                            			dc.b $21, num&$ff, num>>8
00000000                            			endc
00000000                            		elseif strcmp("\1","sp")
00000000                            			if strcmp("\2","hl")
00000000                            			dc.b $f9
00000000                            			elseif strcmp("\2","ix")
00000000                            			dc.w $ddf9
00000000                            			elseif strcmp("\2","iy")
00000000                            			dc.w $fdf9
00000000                            			else
00000000                            				num: equ \2
00000000                            				tmp_len: = strlen("\2")
00000000                            				tmp_fc:	substr	1,1,"\2"
00000000                            				tmp_lc:	substr	tmp_len,tmp_len,"\2"
00000000                            				if strcmp("\tmp_fc","(") & strcmp("\tmp_lc",")") ; ld sp,(n)
00000000                            				dc.b $ed, $7b, num&$ff, num>>8
00000000                            				else				; ld sp,n
00000000                            				dc.b $31, num&$ff, num>>8
00000000                            				endc
00000000                            			endc
00000000                            		elseif strcmp("\1","ix")
00000000                            			num: equ \2
00000000                            			tmp_len: = strlen("\2")
00000000                            			tmp_fc:	substr	1,1,"\2"
00000000                            			tmp_lc:	substr	tmp_len,tmp_len,"\2"
00000000                            			if strcmp("\tmp_fc","(") & strcmp("\tmp_lc",")") ; ld ix,(n)
00000000                            			dc.b $dd, $2a, num&$ff, num>>8
00000000                            			else					; ld ix,n
00000000                            			dc.b $dd, $21, num&$ff, num>>8
00000000                            			endc
00000000                            		elseif strcmp("\1","iy")
00000000                            			num: equ \2
00000000                            			tmp_len: = strlen("\2")
00000000                            			tmp_fc:	substr	1,1,"\2"
00000000                            			tmp_lc:	substr	tmp_len,tmp_len,"\2"
00000000                            			if strcmp("\tmp_fc","(") & strcmp("\tmp_lc",")") ; ld iy,(n)
00000000                            			dc.b $fd, $2a, num&$ff, num>>8
00000000                            			else					; ld iy,n
00000000                            			dc.b $fd, $21, num&$ff, num>>8
00000000                            			endc
00000000                            		elseif strcmp("\1","(bc)")
00000000                            		dc.b 2
00000000                            		elseif strcmp("\1","(de)")
00000000                            		dc.b $12
00000000                            		elseif strcmp("\1","(hl)")
00000000                            			if instr("a b c d e h l ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.b $70+zreg
00000000                            			else					; ld (hl),n
00000000                            			num: equ \2
00000000                            			dc.b $36, num
00000000                            			endc
00000000                            		elseif instr("\1","(i")				; ld (ix+n),?
00000000                            			if instr("a b c d e h l ","\2\ ")
00000000                            				num: equ \1
00000000                            				getzreg	\2
00000000                            				getindex \1
00000000                            				dc.b ireg, $70|zreg, num
00000000                            			else					; ld (ix+n),n
00000000                            				num: equ \1
00000000                            				num2: equ \2
00000000                            				getindex \1
00000000                            				dc.b ireg, $36, num, num2
00000000                            			endc
00000000                            		else						; ld (n),?
00000000                            			num: equ \1
00000000                            			if strcmp("\2","a")
00000000                            			dc.b $32
00000000                            			elseif strcmp("\2","bc")
00000000                            			dc.w $ed43
00000000                            			elseif strcmp("\2","de")
00000000                            			dc.w $ed53
00000000                            			elseif strcmp("\2","hl")
00000000                            			dc.w $ed63
00000000                            			elseif strcmp("\2","sp")
00000000                            			dc.w $ed73
00000000                            			elseif strcmp("\2","ix")
00000000                            			dc.w $dd22
00000000                            			elseif strcmp("\2","iy")
00000000                            			dc.w $fd22
00000000                            			else
00000000                            			fail
00000000                            			endc
00000000                            			dc.b num&$FF, num>>8
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            ldd:		macros
00000000                            		dc.w $eda8
00000000                            
00000000                            
00000000                            lddr:		macros
00000000                            		dc.w $edb8
00000000                            
00000000                            
00000000                            ldi:		macros
00000000                            		dc.w $eda0
00000000                            
00000000                            
00000000                            ldir:		macros
00000000                            		dc.w $edb0
00000000                            
00000000                            
00000000                            otdr:		macros
00000000                            		dc.w $edbb
00000000                            
00000000                            
00000000                            otir:		macros
00000000                            		dc.w $edb3
00000000                            
00000000                            
00000000                            out:		macro
00000000                            		local num
00000000                            		if strcmp("\1","(c)")&instr("a b c d e h l ","\2\ ")
00000000                            		getzreg	\2
00000000                            		dc.w $ed41+(zreg*8)
00000000                            		elseif strcmp("\_","(c),0")
00000000                            		dc.w $ed71
00000000                            		elseif strcmp("\2","a")				; out n,a
00000000                            		num: equ \1
00000000                            		dc.b $d3, num
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            outd:		macros
00000000                            		dc.w $edab
00000000                            
00000000                            
00000000                            outi:		macros
00000000                            		dc.w $eda3
00000000                            
00000000                            
00000000                            pop:		macro
00000000                            		if strcmp("\1","bc")
00000000                            		dc.b $c1
00000000                            		elseif strcmp("\1","de")
00000000                            		dc.b $d1
00000000                            		elseif strcmp("\1","hl")
00000000                            		dc.b $e1
00000000                            		elseif strcmp("\1","af")
00000000                            		dc.b $f1
00000000                            		elseif strcmp("\1","ix")
00000000                            		dc.w $dde1
00000000                            		elseif strcmp("\1","iy")
00000000                            		dc.w $fde1
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            push:		macro
00000000                            		if strcmp("\1","bc")
00000000                            		dc.b $c5
00000000                            		elseif strcmp("\1","de")
00000000                            		dc.b $d5
00000000                            		elseif strcmp("\1","hl")
00000000                            		dc.b $e5
00000000                            		elseif strcmp("\1","af")
00000000                            		dc.b $f5
00000000                            		elseif strcmp("\1","ix")
00000000                            		dc.w $dde5
00000000                            		elseif strcmp("\1","iy")
00000000                            		dc.w $fde5
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            res:		macro
00000000                            		local num, num2
00000000                            		num: equ \1
00000000                            		if instr("a b c d e h l (hl) ","\2\ ")
00000000                            		getzreg	\2
00000000                            		dc.b $cb, $80+(num*8)+zreg
00000000                            		elseif instr("\2","(i")				; res n,(ix+n)
00000000                            			num2: equ \2
00000000                            			getindex \2
00000000                            			dc.b ireg, $cb, num2
00000000                            		dc.b $80+(num*8)
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            ret:		macro
00000000                            		if strcmp("\1","nz")
00000000                            		dc.b $c0
00000000                            		elseif strcmp("\1","z")
00000000                            		dc.b $c8
00000000                            		elseif strcmp("\1","nc")
00000000                            		dc.b $d0
00000000                            		elseif strcmp("\1","c")
00000000                            		dc.b $d8
00000000                            		elseif strcmp("\1","po")
00000000                            		dc.b $e0
00000000                            		elseif strcmp("\1","pe")
00000000                            		dc.b $e8
00000000                            		elseif strcmp("\1","p")
00000000                            		dc.b $f0
00000000                            		elseif strcmp("\1","m")
00000000                            		dc.b $f8
00000000                            		elseif strlen("\1")=0				; ret
00000000                            		dc.b $c9
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            reti:		macros
00000000                            		dc.w $ed4d
00000000                            
00000000                            
00000000                            retn:		macros
00000000                            		dc.w $ed45
00000000                            
00000000                            
00000000                            rl:		macro
00000000                            		local num
00000000                            		if instr("a b c d e h l (hl) ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $cb, $10+zreg
00000000                            		elseif instr("\1","(i")				; rl (ix+n)
00000000                            			num: equ \1
00000000                            			getindex \1
00000000                            			dc.b ireg, $cb, num
00000000                            
00000000                            			if narg=2				; rl (ix+n),?
00000000                            			getzreg	\2
00000000                            			dc.b $10+zreg
00000000                            			else
00000000                            			dc.b $16
00000000                            			endc
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            rla:		macros
00000000                            		dc.b $17
00000000                            
00000000                            
00000000                            rlc:		macro
00000000                            		local num
00000000                            		if instr("a b c d e h l (hl) ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $cb, zreg
00000000                            		elseif instr("\1","(i")				; rlc (ix+n)
00000000                            			num: equ \1
00000000                            			getindex \1
00000000                            			dc.b ireg, $cb, num
00000000                            
00000000                            			if narg=2				; rlc (ix+n),?
00000000                            			getzreg	\2
00000000                            			dc.b zreg
00000000                            			else
00000000                            			dc.b $6
00000000                            			endc
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            rlca:		macros
00000000                            		dc.b $7
00000000                            
00000000                            
00000000                            rld:		macros
00000000                            		dc.w $ed6f
00000000                            
00000000                            
00000000                            rr:		macro
00000000                            		local num
00000000                            		if instr("a b c d e h l (hl) ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $cb, $18+zreg
00000000                            		elseif instr("\1","(i")				; rr (ix+n)
00000000                            			num: equ \1
00000000                            			getindex \1
00000000                            			dc.b ireg, $cb, num
00000000                            
00000000                            			if narg=2				; rr (ix+n),?
00000000                            			getzreg	\2
00000000                            			dc.b $18+zreg
00000000                            			else
00000000                            			dc.b $1e
00000000                            			endc
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            rra:		macros
00000000                            		dc.b $1f
00000000                            
00000000                            
00000000                            rrc:		macro
00000000                            		local num
00000000                            		if instr("a b c d e h l (hl) ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $cb, $8+zreg
00000000                            		elseif instr("\1","(i")				; rrc (ix+n)
00000000                            			num: equ \1
00000000                            			getindex \1
00000000                            			dc.b ireg, $cb, num
00000000                            
00000000                            			if narg=2				; rrc (ix+n),?
00000000                            			getzreg	\2
00000000                            			dc.b $8+zreg
00000000                            			else
00000000                            			dc.b $e
00000000                            			endc
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            rrca:		macros
00000000                            		dc.b $f
00000000                            
00000000                            
00000000                            rrd:		macros
00000000                            		dc.w $ed67
00000000                            
00000000                            
00000000                            rst:		macro
00000000                            		local num
00000000                            		num: equ \1
00000000                            		dc.b $c7+(num&$38)
00000000                            		endm
00000000                            
00000000                            
00000000                            sbc:		macro
00000000                            		local num
00000000                            		if strcmp("\1","a")
00000000                            			if instr("a b c d e h l (hl) ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.b $98+zreg
00000000                            			elseif strcmp("\2","ixh")
00000000                            			dc.w $dd9c
00000000                            			elseif strcmp("\2","ixl")
00000000                            			dc.w $dd9d
00000000                            			elseif strcmp("\2","iyh")
00000000                            			dc.w $fd9c
00000000                            			elseif strcmp("\2","iyl")
00000000                            			dc.w $fd9d
00000000                            			elseif instr("\2","(i")			; sbc a,(ix+n)
00000000                            				num: equ \2
00000000                            				getindex \2
00000000                            				dc.b ireg, $9e, num
00000000                            			else					; sbc a,n
00000000                            			num: equ \2
00000000                            			dc.b $de, num
00000000                            			endc
00000000                            		elseif strcmp("\1","hl")
00000000                            			if strcmp("\2","bc")
00000000                            			dc.w $ed42
00000000                            			elseif strcmp("\2","de")
00000000                            			dc.w $ed52
00000000                            			elseif strcmp("\2","hl")
00000000                            			dc.w $ed62
00000000                            			elseif strcmp("\2","sp")
00000000                            			dc.w $ed72
00000000                            			else
00000000                            			fail
00000000                            			endc
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            scf:		macros
00000000                            		dc.b $37
00000000                            
00000000                            
00000000                            set:		macro
00000000                            		local num, num2
00000000                            		num: equ \1
00000000                            		if instr("a b c d e h l (hl) ","\2\ ")
00000000                            		getzreg	\2
00000000                            		dc.b $cb, $c0+(num*8)+zreg
00000000                            		elseif instr("\2","(i")				; set n,(ix+n)
00000000                            			num2: equ \2
00000000                            			getindex \2
00000000                            			dc.b ireg, $cb, num2, $c0+(num*8)
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            sla:		macro
00000000                            		local num
00000000                            		if instr("a b c d e h l (hl) ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $cb, $20+zreg
00000000                            		elseif instr("\1","(i")
00000000                            			num: equ \1
00000000                            			getindex \1
00000000                            			dc.b ireg, $cb, num
00000000                            
00000000                            			if narg=2				; sla (ix+n),?
00000000                            			getzreg	\2
00000000                            			dc.b $20+zreg
00000000                            			else					; sla (ix+n)
00000000                            			dc.b $26
00000000                            			endc
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            sll:		macro
00000000                            		local num
00000000                            		if instr("a b c d e h l (hl) ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $cb, $30+zreg
00000000                            		elseif instr("\1","(i")
00000000                            			num: equ \1
00000000                            			getindex \1
00000000                            			dc.b ireg, $cb, num
00000000                            
00000000                            			if narg=2				; sll (ix+n),?
00000000                            			getzreg	\2
00000000                            			dc.b $30+zreg
00000000                            			else					; sll (ix+n)
00000000                            			dc.b $36
00000000                            			endc
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            sra:		macro
00000000                            		local num
00000000                            		if instr("a b c d e h l (hl) ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $cb, $28+zreg
00000000                            		elseif instr("\1","(i")
00000000                            			num: equ \1
00000000                            			getindex \1
00000000                            			dc.b ireg, $cb, num
00000000                            
00000000                            			if narg=2				; sra (ix+n),?
00000000                            			getzreg	\2
00000000                            			dc.b $28+zreg
00000000                            			else					; sra (ix+n)
00000000                            			dc.b $2e
00000000                            			endc
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            srl:		macro
00000000                            		local num
00000000                            		if instr("a b c d e h l (hl) ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $cb, $38+zreg
00000000                            		elseif instr("\1","(i")
00000000                            			num: equ \1
00000000                            			getindex \1
00000000                            			dc.b ireg, $cb, num
00000000                            
00000000                            			if narg=2				; srl (ix+n),?
00000000                            			getzreg	\2
00000000                            			dc.b $38+zreg
00000000                            			else					; srl (ix+n)
00000000                            			dc.b $3e
00000000                            			endc
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            xor:		macro
00000000                            		local num
00000000                            		if instr("a b c d e h l (hl) ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $a8+zreg
00000000                            		elseif strcmp("\1","ixh")
00000000                            		dc.w $ddac
00000000                            		elseif strcmp("\1","ixl")
00000000                            		dc.w $ddad
00000000                            		elseif strcmp("\1","iyh")
00000000                            		dc.w $fdac
00000000                            		elseif strcmp("\1","iyl")
00000000                            		dc.w $fdad
00000000                            		elseif instr("\1","(i")				; xor (ix+n)
00000000                            			num: equ \1
00000000                            			getindex \1
00000000                            			dc.b ireg, $ae, num
00000000                            		else						; xor n
00000000                            		num: equ \1
00000000                            		dc.b $ee, num
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            db:		macros
00000000                            		dc.b \_
00000000                            
00000000                            
00000000                            dw:		macro
00000000                            		local c
00000000                            		c: = 0
00000000                            		rept narg
00000000                            			local num\#c
00000000                            			num\#c\: equ \1
00000000                            			dc.b (num\#c\)&$FF, (num\#c\)>>8
00000000                            			shift
00000000                            			c: = c+1
00000000                            		endr
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Mixed instruction set
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            add:		macro
00000000                            		local num
00000000                            		if cpu_mode=1					; Z80
00000000                            			if strcmp("\1","hl")
00000000                            				if strcmp("\2","bc")
00000000                            				dc.b $9
00000000                            				elseif strcmp("\2","de")
00000000                            				dc.b $19
00000000                            				elseif strcmp("\2","hl")
00000000                            				dc.b $29
00000000                            				elseif strcmp("\2","sp")
00000000                            				dc.b $39
00000000                            				else
00000000                            				fail
00000000                            				endc
00000000                            				mexit
00000000                            
00000000                            			elseif strcmp("\1","ix")
00000000                            				if strcmp("\2","bc")
00000000                            				dc.w $dd09
00000000                            				elseif strcmp("\2","de")
00000000                            				dc.w $dd19
00000000                            				elseif strcmp("\2","ix")
00000000                            				dc.w $dd29
00000000                            				elseif strcmp("\2","sp")
00000000                            				dc.w $dd39
00000000                            				else
00000000                            				fail
00000000                            				endc
00000000                            				mexit
00000000                            
00000000                            			elseif strcmp("\1","iy")
00000000                            				if strcmp("\2","bc")
00000000                            				dc.w $fd09
00000000                            				elseif strcmp("\2","de")
00000000                            				dc.w $fd19
00000000                            				elseif strcmp("\2","iy")
00000000                            				dc.w $fd29
00000000                            				elseif strcmp("\2","sp")
00000000                            				dc.w $fd39
00000000                            				else
00000000                            				fail
00000000                            				endc
00000000                            				mexit
00000000                            			endc
00000000                            
00000000                            								; "add a, x" or "add x"
00000000                            			if (narg=2) & strcmp("\1","a")
00000000                            				shift				; ignore a
00000000                            			endc
00000000                            
00000000                            			if (narg=1) | (narg=2)
00000000                            				if instr("a b c d e h l (hl) ","\1\ ")
00000000                            				getzreg	\1
00000000                            				dc.b $80+zreg
00000000                            				elseif strcmp("\1","ixh")
00000000                            				dc.w $dd84
00000000                            				elseif strcmp("\1","ixl")
00000000                            				dc.w $dd85
00000000                            				elseif strcmp("\1","iyh")
00000000                            				dc.w $fd84
00000000                            				elseif strcmp("\1","iyl")
00000000                            				dc.w $fd85
00000000                            				elseif instr("\1","(i")		; add (ix+n)
00000000                            					num: equ \1
00000000                            					getindex \1
00000000                            					dc.b ireg, $86, num
00000000                            				else				; add n
00000000                            				num: equ \1
00000000                            				dc.b $c6, num
00000000                            				endc
00000000                            			else
00000000                            			fail
00000000                            			endc
00000000                            		else						; 68k
00000000                            		axd.\0	\_
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            and:		macro
00000000                            		local num
00000000                            		if cpu_mode=1					; Z80
00000000                            			if instr("a b c d e h l (hl) ","\1\ ")
00000000                            			getzreg	\1
00000000                            			dc.b $a0+zreg
00000000                            			elseif strcmp("\1","ixh")
00000000                            			dc.w $dda4
00000000                            			elseif strcmp("\1","ixl")
00000000                            			dc.w $dda5
00000000                            			elseif strcmp("\1","iyh")
00000000                            			dc.w $fda4
00000000                            			elseif strcmp("\1","iyl")
00000000                            			dc.w $fda5
00000000                            			elseif instr("\1","(i")			; and (ix+n)
00000000                            				num: equ \1
00000000                            				getindex \1
00000000                            				dc.b ireg, $a6, num
00000000                            			else					; and n
00000000                            			num: equ \1
00000000                            			dc.b $e6, num
00000000                            			endc
00000000                            		else						; 68k
00000000                            		anx.\0	\_
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            neg:		macro
00000000                            		if cpu_mode=1					; Z80
00000000                            		dc.w $ed44
00000000                            		else						; 68k
00000000                            		nxg.\0	\_
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            nop:		macro
00000000                            		if cpu_mode=1					; Z80
00000000                            		dc.b 0
00000000                            		else						; 68k
00000000                            		nxp
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            or:		macro
00000000                            		local num
00000000                            		if cpu_mode=1					; Z80
00000000                            			if instr("a b c d e h l (hl) ","\1\ ")
00000000                            			getzreg	\1
00000000                            			dc.b $b0+zreg
00000000                            			elseif strcmp("\1","ixh")
00000000                            			dc.w $ddb4
00000000                            			elseif strcmp("\1","ixl")
00000000                            			dc.w $ddb5
00000000                            			elseif strcmp("\1","iyh")
00000000                            			dc.w $fdb4
00000000                            			elseif strcmp("\1","iyl")
00000000                            			dc.w $fdb5
00000000                            			elseif instr("\1","(i")			; or (ix+n)
00000000                            				num: equ \1
00000000                            				getindex \1
00000000                            				dc.b ireg, $b6, num
00000000                            			else					; or n
00000000                            			num: equ \1
00000000                            			dc.b $f6, num
00000000                            			endc
00000000                            		else						; 68k
00000000                            		ox.\0	\_
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            sub:		macro
00000000                            		local num
00000000                            		if cpu_mode=1					; Z80
00000000                            			if instr("a b c d e h l (hl) ","\1\ ")
00000000                            			getzreg	\1
00000000                            			dc.b $90+zreg
00000000                            			elseif strcmp("\1","ixh")
00000000                            			dc.w $dd94
00000000                            			elseif strcmp("\1","ixl")
00000000                            			dc.w $dd95
00000000                            			elseif strcmp("\1","iyh")
00000000                            			dc.w $fd94
00000000                            			elseif strcmp("\1","iyl")
00000000                            			dc.w $fd95
00000000                            			elseif instr("\1","(i")			; sub (ix+n)
00000000                            				um: equ \1
00000000                            				getindex \1
00000000                            				dc.b ireg, $96, num
00000000                            			else					; sub n
00000000                            			num: equ \1
00000000                            			dc.b $d6, num
00000000                            			endc
00000000                            		else						; 68k
00000000                            		sxb.\0	\_
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Restored ASM68k instruction set
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            adda:		macros
00000000                            		axda.\0	\_
00000000                            
00000000                            addi:		macros
00000000                            		axdi.\0	\_
00000000                            
00000000                            addq:		macros
00000000                            		axdq.\0	\_
00000000                            
00000000                            addx:		macros
00000000                            		axdx.\0	\_
00000000                            
00000000                            andi:		macros
00000000                            		anxi.\0	\_
00000000                            
00000000                            negx:		macros
00000000                            		nxgx.\0	\_
00000000                            
00000000                            ori:		macros
00000000                            		oxi.\0	\_
00000000                            
00000000                            suba:		macros
00000000                            		sxba.\0	\_
00000000                            
00000000                            subi:		macros
00000000                            		sxbi.\0	\_
00000000                            
00000000                            subq:		macros
00000000                            		sxbq.\0	\_
00000000                            
00000000                            subx:		macros
00000000                            		sxbx.\0	\_
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Memory map
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ; Program RAM
00000000 =00000000                  PRGRAM		EQU	$000000				; Program RAM
00000000 =0007FFFF                  PRGRAM_END	EQU	$07FFFF				; End of Program RAM
00000000 =00080000                  PRGRAM_SIZE	EQU	(PRGRAM_END+1)-PRGRAM		; Size of Program RAM
00000000 =00006000                  SPSTART		EQU	PRGRAM+$6000			; System program start
00000000                            
00000000                            ; Word RAM
00000000 =00080000                  WORDRAM2M	EQU	$080000				; Word RAM (2M)
00000000 =000BFFFF                  WORDRAM2M_END	EQU	$0BFFFF				; End of Word RAM (2M)
00000000 =00040000                  WORDRAM2M_SIZE	EQU	(WORDRAM2M_END+1)-WORDRAM2M	; Size of Word RAM (2M)
00000000 =000C0000                  WORDRAM1M	EQU	$0C0000				; Word RAM (2M)
00000000 =000DFFFF                  WORDRAM1M_END	EQU	$0DFFFF				; End of Word RAM (2M)
00000000 =00020000                  WORDRAM1M_SIZE	EQU	(WORDRAM1M_END+1)-WORDRAM1M	; Size of Word RAM (2M)
00000000                            
00000000                            ; PCM
00000000 =00FF0001                  PCMREGS		EQU	$FF0001				; PCM registers base
00000000 =00FF0001                  PCMENV		EQU	PCMREGS+($0000*2)		; PCM volume
00000000 =00FF0003                  PCMPAN		EQU	PCMREGS+($0001*2)		; PCM panning
00000000 =00FF0005                  PCMFDL		EQU	PCMREGS+($0002*2)		; PCM frequency low
00000000 =00FF0007                  PCMFDH		EQU	PCMREGS+($0003*2)		; PCM frequency high
00000000 =00FF0009                  PCMLSL		EQU	PCMREGS+($0004*2)		; PCM loop address low
00000000 =00FF000B                  PCMLSH		EQU	PCMREGS+($0005*2)		; PCM loop address high
00000000 =00FF000D                  PCMST		EQU	PCMREGS+($0006*2)		; PCM start address high
00000000 =00FF000F                  PCMCTRL		EQU	PCMREGS+($0007*2)		; PCM control
00000000 =00FF0011                  PCMONOFF	EQU	PCMREGS+($0008*2)		; PCM on/off control
00000000 =00FF0021                  PCMADDR		EQU	PCMREGS+($0010*2)		; PCM sample address
00000000 =00FF2001                  PCMDATA		EQU	PCMREGS+($1000*2)		; PCM sample data
00000000                            
00000000                            ; Registers
00000000 =FFFF8000                  MCDREGS		EQU	$FFFF8000			; Registers base
00000000                            
00000000                            ; Initialization
00000000 =FFFF8000                  LEDSTATUS	EQU	MCDREGS+0			; LED status
00000000 =FFFF8001                  CPURESET	EQU	MCDREGS+1			; Reset flag
00000000 =FFFF8001                  VERSION		EQU	MCDREGS+1			; Version
00000000 =FFFF8002                  PROTECT		EQU	MCDREGS+2			; Program RAM write protect
00000000 =FFFF8003                  MEMMODE		EQU	MCDREGS+3			; Memory mode
00000000                            
00000000                            ; CDC
00000000 =FFFF8004                  CDCMODE		EQU	MCDREGS+4			; CDC mode
00000000 =FFFF8005                  CDCREGADDR	EQU	MCDREGS+5			; CDC register address
00000000 =FFFF8006                  CDCREGDATA	EQU	MCDREGS+6			; CDC register data
00000000 =FFFF8008                  CDCDATA		EQU	MCDREGS+8			; CDC read data
00000000 =FFFF800A                  CDCDMA		EQU	MCDREGS+$A			; CDC DMA address
00000000 =FFFF800C                  STOPWATCH	EQU	MCDREGS+$C			; Stop watch
00000000                            
00000000                            ; Communication (Main CPU)
00000000 =FFFF800E                  MAINFLAG	EQU	MCDREGS+$E			; Main CPU flag
00000000 =FFFF8010                  MAINCOM0	EQU	MCDREGS+$10			; Communication command 0
00000000 =FFFF8010                  MAINCOM0H	EQU	MAINCOM0
00000000 =FFFF8011                  MAINCOM0L	EQU	MAINCOM0+1
00000000 =FFFF8012                  MAINCOM1	EQU	MCDREGS+$12			; Communication command 1
00000000 =FFFF8012                  MAINCOM1H	EQU	MAINCOM1
00000000 =FFFF8013                  MAINCOM1L	EQU	MAINCOM1+1
00000000 =FFFF8014                  MAINCOM2	EQU	MCDREGS+$14			; Communication command 2
00000000 =FFFF8014                  MAINCOM2H	EQU	MAINCOM2
00000000 =FFFF8015                  MAINCOM2L	EQU	MAINCOM2+1
00000000 =FFFF8016                  MAINCOM3	EQU	MCDREGS+$16			; Communication command 3
00000000 =FFFF8016                  MAINCOM3H	EQU	MAINCOM3
00000000 =FFFF8017                  MAINCOM3L	EQU	MAINCOM3+1
00000000 =FFFF8018                  MAINCOM4	EQU	MCDREGS+$18			; Communication command 4
00000000 =FFFF8018                  MAINCOM4H	EQU	MAINCOM4
00000000 =FFFF8019                  MAINCOM4L	EQU	MAINCOM4+1
00000000 =FFFF801A                  MAINCOM5	EQU	MCDREGS+$1A			; Communication command 5
00000000 =FFFF801A                  MAINCOM5H	EQU	MAINCOM5
00000000 =FFFF801B                  MAINCOM5L	EQU	MAINCOM5+1
00000000 =FFFF801C                  MAINCOM6	EQU	MCDREGS+$1C			; Communication command 6
00000000 =FFFF801C                  MAINCOM6H	EQU	MAINCOM6
00000000 =FFFF801D                  MAINCOM6L	EQU	MAINCOM6+1
00000000 =FFFF801E                  MAINCOM7	EQU	MCDREGS+$1E			; Communication command 7
00000000 =FFFF801E                  MAINCOM7H	EQU	MAINCOM7
00000000 =FFFF801F                  MAINCOM7L	EQU	MAINCOM7+1
00000000                            
00000000                            ; Communication (Sub CPU)
00000000 =FFFF800F                  SUBFLAG		EQU	MCDREGS+$F			; Sub CPU flag
00000000 =FFFF8020                  SUBCOM0		EQU	MCDREGS+$20			; Communication status 0
00000000 =FFFF8020                  SUBCOM0H	EQU	SUBCOM0
00000000 =FFFF8021                  SUBCOM0L	EQU	SUBCOM0+1
00000000 =FFFF8022                  SUBCOM1		EQU	MCDREGS+$22			; Communication status 1
00000000 =FFFF8022                  SUBCOM1H	EQU	SUBCOM1
00000000 =FFFF8023                  SUBCOM1L	EQU	SUBCOM1+1
00000000 =FFFF8024                  SUBCOM2		EQU	MCDREGS+$24			; Communication status 2
00000000 =FFFF8024                  SUBCOM2H	EQU	SUBCOM2
00000000 =FFFF8025                  SUBCOM2L	EQU	SUBCOM2+1
00000000 =FFFF8026                  SUBCOM3		EQU	MCDREGS+$26			; Communication status 3
00000000 =FFFF8026                  SUBCOM3H	EQU	SUBCOM3
00000000 =FFFF8027                  SUBCOM3L	EQU	SUBCOM3+1
00000000 =FFFF8028                  SUBCOM4		EQU	MCDREGS+$28			; Communication status 4
00000000 =FFFF8028                  SUBCOM4H	EQU	SUBCOM4
00000000 =FFFF8029                  SUBCOM4L	EQU	SUBCOM4+1
00000000 =FFFF802A                  SUBCOM5		EQU	MCDREGS+$2A			; Communication status 5
00000000 =FFFF802A                  SUBCOM5H	EQU	SUBCOM5
00000000 =FFFF802B                  SUBCOM5L	EQU	SUBCOM5+1
00000000 =FFFF802C                  SUBCOM6		EQU	MCDREGS+$2C			; Communication status 6
00000000 =FFFF802C                  SUBCOM6H	EQU	SUBCOM6
00000000 =FFFF802D                  SUBCOM6L	EQU	SUBCOM6+1
00000000 =FFFF802E                  SUBCOM7		EQU	MCDREGS+$2E			; Communication status 7
00000000 =FFFF802E                  SUBCOM7H	EQU	SUBCOM7
00000000 =FFFF802F                  SUBCOM7L	EQU	SUBCOM7+1
00000000                            
00000000                            ; Interrupt
00000000 =FFFF8030                  INT3TIME	EQU	MCDREGS+$30			; Timer interrupt time
00000000 =FFFF8032                  INTMASK		EQU	MCDREGS+$32			; Interrupt mask
00000000                            
00000000                            ; CDD
00000000 =FFFF8034                  CDFADER		EQU	MCDREGS+$34			; CD fader
00000000 =FFFF8036                  CDDTYPE		EQU	MCDREGS+$36			; CDD data type
00000000 =FFFF8037                  CDDCTRL		EQU	MCDREGS+$37			; CDD control
00000000 =FFFF8038                  CDDSTAT0	EQU	MCDREGS+$38			; CDD receive status 0
00000000 =FFFF8039                  CDDSTAT1	EQU	MCDREGS+$39			; CDD receive status 1
00000000 =FFFF803A                  CDDSTAT2	EQU	MCDREGS+$3A			; CDD receive status 2
00000000 =FFFF803B                  CDDSTAT3	EQU	MCDREGS+$3B			; CDD receive status 3
00000000 =FFFF803C                  CDDSTAT4	EQU	MCDREGS+$3C			; CDD receive status 4
00000000 =FFFF803D                  CDDSTAT5	EQU	MCDREGS+$3D			; CDD receive status 5
00000000 =FFFF803E                  CDDSTAT6	EQU	MCDREGS+$3E			; CDD receive status 6
00000000 =FFFF803F                  CDDSTAT7	EQU	MCDREGS+$3F			; CDD receive status 7
00000000 =FFFF8040                  CDDSTAT8	EQU	MCDREGS+$40			; CDD receive status 8
00000000 =FFFF8041                  CDDSTAT9	EQU	MCDREGS+$41			; CDD receive status 9
00000000 =FFFF8042                  CDDCMD0		EQU	MCDREGS+$42			; CDD transfer command 0
00000000 =FFFF8043                  CDDCMD1		EQU	MCDREGS+$43			; CDD transfer command 1
00000000 =FFFF8044                  CDDCMD2		EQU	MCDREGS+$44			; CDD transfer command 2
00000000 =FFFF8045                  CDDCMD3		EQU	MCDREGS+$45			; CDD transfer command 3
00000000 =FFFF8046                  CDDCMD4		EQU	MCDREGS+$46			; CDD transfer command 4
00000000 =FFFF8047                  CDDCMD5		EQU	MCDREGS+$47			; CDD transfer command 5
00000000 =FFFF8048                  CDDCMD6		EQU	MCDREGS+$48			; CDD transfer command 6
00000000 =FFFF8049                  CDDCMD7		EQU	MCDREGS+$49			; CDD transfer command 7
00000000 =FFFF804A                  CDDCMD8		EQU	MCDREGS+$4A			; CDD transfer command 8
00000000 =FFFF804B                  CDDCMD9		EQU	MCDREGS+$4B			; CDD transfer command 9
00000000                            
00000000                            ; Font
00000000 =FFFF804C                  FONTCOLOR	EQU	MCDREGS+$4C			; Font color
00000000 =FFFF804E                  FONT1BPP	EQU	MCDREGS+$4E			; Input 1BPP font data
00000000 =FFFF8050                  FONT4BPP0	EQU	MCDREGS+$50			; Output 4BPP font data (0)
00000000 =FFFF8052                  FONT4BPP1	EQU	MCDREGS+$52			; Output 4BPP font data (1)
00000000 =FFFF8054                  FONT4BPP2	EQU	MCDREGS+$54			; Output 4BPP font data (2)
00000000 =FFFF8056                  FONT4BPP3	EQU	MCDREGS+$56			; Output 4BPP font data (3)
00000000                            
00000000                            ; Graphics
00000000 =FFFF8058                  GFXON		EQU	MCDREGS+$58			; Graphics operation process flag
00000000 =FFFF8059                  GFXSIZE		EQU	MCDREGS+$59			; Graphics data size
00000000 =FFFF805A                  STAMPMAP	EQU	MCDREGS+$5A			; Stamp map address
00000000 =FFFF805C                  IMGVSZTILE	EQU	MCDREGS+$5C			; Image buffer vertical tile size
00000000 =FFFF805E                  IMGBUFFER	EQU	MCDREGS+$5E			; Image buffer address
00000000 =FFFF8060                  IMGOFFSET	EQU	MCDREGS+$60			; Image buffer offset
00000000 =FFFF8062                  IMGHSIZE	EQU	MCDREGS+$62			; Image buffer horizontal pixel size
00000000 =FFFF8064                  IMGVSIZE	EQU	MCDREGS+$64			; Image buffer vertical pixel size
00000000 =FFFF8066                  TRACETBL	EQU	MCDREGS+$66			; Trace table address
00000000                            
00000000                            ; Subcode
00000000 =FFFF8068                  SUBADDR		EQU	MCDREGS+$68			; Subcode address
00000000 =FFFF8100                  SUBDATA		EQU	MCDREGS+$100			; Subcode buffer area
00000000 =FFFF817F                  SUBDATA_END	EQU	MCDREGS+$17F			; End of subcode buffer area
00000000 =00000080                  SUBDATA_SIZE	EQU	(SUBDATA_END+1)-SUBDATA		; Size of subcoe buffer area
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; BIOS function code
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ; Music
00000000 =00000002                  MSCSTOP		EQU	$02				; Stop music
00000000 =00000003                  MSCPAUSEON	EQU	$03				; Pause music
00000000 =00000004                  MSCPAUSEOFF	EQU	$04				; Unpause music
00000000 =00000005                  MSCSCANFF	EQU	$05				; Fast forward music
00000000 =00000006                  MSCSCANFR	EQU	$06				; Fast reverse music
00000000 =00000007                  MSCSCANOFF	EQU	$07				; Restore music playback speed
00000000 =00000011                  MSCPLAY		EQU	$11				; Play music and subsequent tracks
00000000 =00000012                  MSCPLAY1	EQU	$12				; Play music track
00000000 =00000013                  MSCPLAYR	EQU	$13				; Loop music track
00000000 =00000014                  MSCPLAYT	EQU	$14				; Play music at time
00000000 =00000015                  MSCSEEK		EQU	$15				; Seek to music track
00000000 =00000019                  MSCSEEK1	EQU	$19				; Seek to music track and play
00000000 =00000016                  MSCSEEKT	EQU	$16				; Seek to music at time
00000000                            
00000000                            ; Drive
00000000 =0000000A                  DRVOPEN		EQU	$0A				; Open CD drive
00000000 =00000010                  DRVINIT		EQU	$10				; Close CD drive and read TOC
00000000                            
00000000                            ; CD-ROM
00000000 =00000008                  ROMPAUSEON	EQU	$08				; Stop reading into CDC
00000000 =00000009                  ROMPAUSEOFF	EQU	$09				; Resume reading into CDC
00000000 =00000017                  ROMREAD		EQU	$17				; Begin reading sectors
00000000 =00000018                  ROMSEEK		EQU	$18				; Seek to sector
00000000 =00000020                  ROMREADN	EQU	$20				; Read number of sectors
00000000 =00000021                  ROMREADE	EQU	$21				; Read up to sector
00000000                            
00000000                            ; BIOS
00000000 =00000080                  CDBCHK		EQU	$80				; Get status of last command
00000000 =00000081                  CDBSTAT		EQU	$81				; Get BIOS status
00000000 =00000082                  CDBTOCWRITE	EQU	$82				; Write TOC
00000000 =00000083                  CDBTOCREAD	EQU	$83				; Read TOC
00000000 =00000084                  CDBPAUSE	EQU	$84				; Set pause to standby delay time
00000000                            
00000000                            ; Fader
00000000 =00000085                  FDRSET		EQU	$85				; Set music volume
00000000 =00000086                  FDRCHG		EQU	$86				; Ramp to music volume at rate
00000000                            
00000000                            ; CDC
00000000 =00000087                  CDCSTART	EQU	$87				; Start reading at sector into CDC
00000000 =00000089                  CDCSTOP		EQU	$89				; Stop reading into CDC
00000000 =0000008A                  CDCSTAT		EQU	$8A				; Check if sector data is prepared
00000000 =0000008B                  CDCREAD		EQU	$8B				; Prepare to send sector data to destination
00000000 =0000008C                  CDCTRN		EQU	$8C				; Use Sub CPU to read sector data into RAM
00000000 =0000008D                  CDCACK		EQU	$8D				; Inform CDC sector is fully read
00000000 =00000096                  CDCSETMODE	EQU	$96				; Set CD read mode
00000000                            
00000000                            ; Subcode
00000000 =0000008E                  SCDINIT		EQU	$8E				; Initialize BIOS for subcode reading
00000000 =0000008F                  SCDSTART	EQU	$8F				; Enable reading of subcode data by the CDC
00000000 =00000090                  SCDSTOP		EQU	$90				; Disable reading of subcode data by the CDC
00000000 =00000091                  SCDSTAT		EQU	$91				; Get subcode error status
00000000 =00000092                  SCDREAD		EQU	$92				; Read R through W subcode channels
00000000 =00000093                  SCDPQ		EQU	$93				; Read P and Q codes
00000000 =00000094                  SCDPQL		EQU	$94				; Read last P and Q codes
00000000                            
00000000                            ; LED
00000000 =00000095                  LEDSET		EQU	$95				; Set LED mode
00000000                            
00000000                            ; Backup RAM
00000000 =00000000                  BRMINIT		EQU	$00				; Prepare writing to or reading fromBackup RAM
00000000 =00000001                  BRMSTAT		EQU	$01				; Get how much Backup RAM has been used
00000000 =00000002                  BRMSERCH	EQU	$02				; Search for the desired file in Backup RAM
00000000 =00000003                  BRMREAD		EQU	$03				; Read data from Backup RAM
00000000 =00000004                  BRMWRITE	EQU	$04				; Write data to Backup RAM
00000000 =00000005                  BRMDEL		EQU	$05				; Delete data from Backup RAM
00000000 =00000006                  BRMFORMAT	EQU	$06				; Format Backup RAM
00000000 =00000007                  BRMDIR		EQU	$07				; Read directory from Backup RAM
00000000 =00000008                  BRMVERIFY	EQU	$08				; Check data written to Backup RAM
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; BIOS entry points
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =00005F40                  _ADRERR		EQU	$5F40					; Address error
00000000 =00005EA0                  _BOOTSTAT	EQU	$5EA0					; Boot status
00000000 =00005F16                  _BURAM		EQU	$5F16					; Backup RAM function entry
00000000 =00005F22                  _CDBIOS		EQU	$5F22					; BIOS function entry
00000000 =00005F1C                  _CDBOOT		EQU	$5F1C					; Boot function entry
00000000 =00005E80                  _CDSTAT		EQU	$5E80					; CD status
00000000 =00005F52                  _CHKERR		EQU	$5F52					; CHK exception
00000000 =00005F46                  _CODERR		EQU	$5F46					; Illegal instruction
00000000 =00005F4C                  _DEVERR		EQU	$5F4C					; Division by zero
00000000 =00005F76                  _LEVEL1		EQU	$5F76					; Graphics interrupt
00000000 =00005F7C                  _LEVEL2		EQU	$5F7C					; Mega Drive interrupt
00000000 =00005F82                  _LEVEL3		EQU	$5F82					; Timer interrupt
00000000 =00005F88                  _LEVEL4		EQU	$5F88					; CDD interrupt
00000000 =00005F8E                  _LEVEL5		EQU	$5F8E					; CDC interrupt
00000000 =00005F94                  _LEVEL6		EQU	$5F94					; Subcode interrupt
00000000 =00005F9A                  _LEVEL7		EQU	$5F9A					; Unused
00000000 =00005F6A                  _NOCOD0		EQU	$5F6A					; Line A emulator
00000000 =00005F70                  _NOCOD1		EQU	$5F70					; Line F emulator
00000000 =00005F0A                  _SETJMPTBL	EQU	$5F0A					; Set up module
00000000 =00005F5E                  _SPVERR		EQU	$5F5E					; Privilege violation
00000000 =00005F64                  _TRACE		EQU	$5F64					; TRACE exception
00000000 =00005FA0                  _TRAP00		EQU	$5FA0					; TRAP 00 exception
00000000 =00005FA6                  _TRAP01		EQU	$5FA6					; TRAP 01 exception
00000000 =00005FAC                  _TRAP02		EQU	$5FAC					; TRAP 02 exception
00000000 =00005FB2                  _TRAP03		EQU	$5FB2					; TRAP 03 exception
00000000 =00005FB8                  _TRAP04		EQU	$5FB8					; TRAP 04 exception
00000000 =00005FBE                  _TRAP05		EQU	$5FBE					; TRAP 05 exception
00000000 =00005FC4                  _TRAP06		EQU	$5FC4					; TRAP 06 exception
00000000 =00005FCA                  _TRAP07		EQU	$5FCA					; TRAP 07 exception
00000000 =00005FD0                  _TRAP08		EQU	$5FD0					; TRAP 08 exception
00000000 =00005FD6                  _TRAP09		EQU	$5FD6					; TRAP 09 exception
00000000 =00005FDC                  _TRAP10		EQU	$5FDC					; TRAP 10 exception
00000000 =00005FE2                  _TRAP11		EQU	$5FE2					; TRAP 11 exception
00000000 =00005FE8                  _TRAP12		EQU	$5FE8					; TRAP 12 exception
00000000 =00005FEE                  _TRAP13		EQU	$5FEE					; TRAP 13 exception
00000000 =00005FF4                  _TRAP14		EQU	$5FF4					; TRAP 14 exception
00000000 =00005FFA                  _TRAP15		EQU	$5FFA					; TRAP 15 exception
00000000 =00005F58                  _TRPERR		EQU	$5F58					; TRAPV exception
00000000 =00005F28                  _USERCALL0	EQU	$5F28					; System program initialization
00000000 =00005F2E                  _USERCALL1	EQU	$5F2E					; System program main
00000000 =00005F34                  _USERCALL2	EQU	$5F34					; System program Mega Drive interrupt
00000000 =00005F3A                  _USERCALL3	EQU	$5F3A					; System program user routine
00000000 =00005EA6                  _USERMODE	EQU	$5EA6					; System program return code
00000000 =00005F10                  _WAITVSYNC	EQU	$5F10					; VSync
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Calls BIOS function
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Assumes that all preparatory and cleanup work is done externally
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	fcode - BIOS function code
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            CDBIOS macro fcode
00000000                            	moveq	#0,d0
00000000                            	move.w	\fcode,d0
00000000                            	jsr	_CDBIOS	
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Call Backup RAM function
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Assumes that all preparatory and cleanup work is done externally.
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	fcode - Backup RAM function code
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BURAM macro fcode
00000000                            	move.w	\fcode,d0
00000000                            	jsr	_BURAM
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Close the CD tray and read the TOC from the CD
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Pauses for 2 seconds after reading the TOC. If bit 7 of the TOC track
00000000                            ; is set, the BIOS starts playing the first track automatically. Waits
00000000                            ; for a DRVOPEN request if there is no disc in the drive.
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	a0.l - Address of initialization parameters:
00000000                            ;	       dc.b    $XX              ; Track ID to read TOC from
00000000                            ;                                       ; (Normally $01)
00000000                            ;	       dc.b    $XX              ; Last track ID
00000000                            ;                                       ; ($FF = Read all tracks)
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_DRVINIT macro
00000000                            	CDBIOS	#DRVINIT
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Open the CD drive
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_DRVOPEN macro
00000000                            	CDBIOS	#DRVOPEN
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Stop the current music track
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_MSCSTOP macro
00000000                            	CDBIOS	#MSCSTOP
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Play a music track and subsequent tracks after
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	a0.l - Pointer to music track ID
00000000                            ;	       dc.w    $XXXX            ; First music track to play
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_MSCPLAY macro
00000000                            	CDBIOS	#MSCPLAY
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Play a music track
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	a0.l - Pointer to music track ID
00000000                            ;	       dc.w    $XXXX            ; Music track to play
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_MSCPLAY1 macro
00000000                            	CDBIOS	#MSCPLAY1
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Loop a music track
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	a0.l - Pointer to music track ID
00000000                            ;	       dc.w    $XXXX            ; Music track to loop
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_MSCPLAYR macro
00000000                            	CDBIOS	#MSCPLAYR
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Play music from a specific time
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	a0.l - Pointer to BCD time code in the format MM:SS:FF:00
00000000                            ;	       dc.l    $XXXXXXXX        ; Seek time
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_MSCPLAYT macro
00000000                            	CDBIOS	#MSCPLAYT
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Seek to beginning of music track and pause
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	a0.l - Pointer to music track ID
00000000                            ;	       dc.w    $XXXX            ; Music track to seek to
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_MSCSEEK macro
00000000                            	CDBIOS	#MSCSEEK
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Seek to beginning of music track and play it
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	a0.l - Pointer to music track ID
00000000                            ;	       dc.w    $XXXX            ; Music track to play
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_MSCSEEK1 macro
00000000                            	CDBIOS	#MSCSEEK1
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Seek to a specific time
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	a0.l - Pointer to BCD time code in the format MM:SS:FF:00
00000000                            ;	       dc.l    $XXXXXXXX       ; Seek time
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_MSCSEEKT macro
00000000                            	CDBIOS	#MSCSEEKT
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Pause the current music track
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; If the drive is left paused it will stop after a programmable delay
00000000                            ; (See CDBPAUSE).
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_MSCPAUSEON macro
00000000                            	CDBIOS	#MSCPAUSEON
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Resume the current paused music track
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; If the drive has timed out and stopped, the BIOS will seek to the pause
00000000                            ; time (with the attendant delay) and resume playing.
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_MSCPAUSEOFF macro
00000000                            	CDBIOS	#MSCPAUSEOFF
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Play music from current position in fast forward speed
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_MSCSCANFF macro
00000000                            	CDBIOS	#MSCSCANFF
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Play music from current position in fast reverse speed
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_MSCSCANFR macro
00000000                            	CDBIOS	#MSCSCANFR
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Return to normal playback speed
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; If the drive was paused before the scan was initiated, it will be
00000000                            ; returned to pause.
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_MSCSCANOFF macro
00000000                            	CDBIOS	#MSCSCANOFF
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Begin reading data from the CD at the designated logical sector
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Executes a CDCSTART to begin the read, but doesn't stop automatically.
00000000                            ; ROMREAD actually pre-seeks by 2 sectors, but doesn't start passing data
00000000                            ; to the CDC until the desired sector is reached.
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	a0.l - Pointer to logical sector ID
00000000                            ;	       dc.l    $XXXXXXXX       ; First sector to read
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_ROMREAD macro
00000000                            	CDBIOS	#ROMREAD
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Begin reading data from the CD at the designated logical sector for
00000000                            ; a set number of sectors
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	a0.l - Pointer to logical sector ID and count
00000000                            ;	       dc.l    $XXXXXXXX       ; First sector to read
00000000                            ;	       dc.l    $XXXXXXXX       ; Number of sectors to read
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_ROMREADN macro
00000000                            	CDBIOS	#ROMREADN
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Begin reading data from the CD at the designated logical sector up to
00000000                            ; another designated logical sector
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	a0.l - Pointer to first and last logical sector IDs
00000000                            ;	       dc.l    $XXXXXXXX       ; First sector to read
00000000                            ;	       dc.l    $XXXXXXXX       ; Last sector to read
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_ROMREADE macro
00000000                            	CDBIOS	#ROMREADE
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Seek to the designated logical sector and pause
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	a0.l - Pointer to logical sector ID
00000000                            ;	       dc.l    $XXXXXXXX       ; Sector to seek to
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_ROMSEEK macro
00000000                            	CDBIOS	#ROMSEEK
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Stop reading data into the CDC and pause
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_ROMPAUSEON macro
00000000                            	CDBIOS	#ROMPAUSEON
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Resume reading data into the CDC from the current logical sector
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_ROMPAUSEOFF macro
00000000                            	CDBIOS	#ROMPAUSEOFF
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Check the status of the last command
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Returns success if the command has been executed, not if it's complete.
00000000                            ; This means that CDBCHK will return success on a seek command once the
00000000                            ; seek has started, NOT when the seek is actually finished.
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	cc/cs - Command has been executed/BIOS is busy
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_CDBCHK macro
00000000                            	CDBIOS	#CDBCHK
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Get the BIOS status
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	a0.l - Pointer to BIOS status table
00000000                            ;	       dc.w    $XXXX            ; BIOS status
00000000                            ;	       dc.w    $XXXX            ; LED status
00000000                            ;	       dc.b    $XX              ; CDD status code
00000000                            ;	       dc.b    $XX              ; CDD report code
00000000                            ;	       dc.b    $XX              ; Disc control code
00000000                            ;	       dc.b    $XX              ; Track ID
00000000                            ;	       dc.l    $XXXXXXXX        ; Absolute BCD timecode
00000000                            ;	       dc.l    $XXXXXXXX        ; Relative BCD timecode
00000000                            ;	       dc.b    $XX              ; First track ID
00000000                            ;	       dc.b    $XX              ; Last track ID
00000000                            ;	       dc.b    $XX              ; Drive version
00000000                            ;	       dc.b    $XX              ; Track flag
00000000                            ;	       dc.l    $XXXXXXXX        ; Start time of read out area
00000000                            ;	       dc.w    $XXXX            ; Master volume
00000000                            ;	       dc.w    $XXXX            ; Volume
00000000                            ;	       dc.l    $XXXXXXXX        ; Data read header
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_CDBSTAT macro
00000000                            	CDBIOS	#CDBSTAT
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Get the timecode and type of a specific track from the TOC
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; If the track isn't in the TOC, the BIOS will either return the time of
00000000                            ; the last track read or the beginning of the disc. Don't call this
00000000                            ; function while the BIOS is loading the TOC (see DRVINIT).
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	d1.w - Track ID
00000000                            ; RETURNS:
00000000                            ;	d0.l - BCD timecode of requested track in MM:SS:FF:## format
00000000                            ;	       ## is the requested track number, 00 if there was an error
00000000                            ;	d1.b - Track type:
00000000                            ;	       $00 = CD-DA track
00000000                            ;	       $FF = CD-ROM track
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_CDBTOCREAD macro
00000000                            	CDBIOS	#CDBTOCREAD
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Write data to the TOC
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Don't write to the TOC while the BIOS is performing a DRVINIT.
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	a0.l - Pointer to table of TOC entries to write
00000000                            ;	       Entry format is MM:SS:FF:HH where ## is the track number
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_CDBTOCWRITE macro
00000000                            	CDBIOS	#CDBTOCWRITE
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Set delay time for when the BIOS switches from pause to standby
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Normal ranges for this delay time are $1194 - $FFFE.
00000000                            ; A delay of $FFFF prevents the drive from stopping, but can damage the
00000000                            ; drive if used improperly.
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	d1.w - Delay time
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_CDBPAUSE macro
00000000                            	CDBIOS	#CDBPAUSE
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Set the audio volume
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; If bit 15 of the volume parameter is 1, sets the master volume level.
00000000                            ; There's a delay of up to 13ms before the volume begins to change and
00000000                            ; another 23ms for the new volume level to take effect. The master volume
00000000                            ; sets a maximum level which the volume level can't exceed.
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	d1.w - 16 bit volume        ($0000 = Min, $0400 = Max)
00000000                            ;	       16 bit master volume ($8000 = Min, $8400 = Max)
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_FDRSET macro
00000000                            	CDBIOS	#FDRSET
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Ramp the audio volume to a new level at the requested rate
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; As in FDRSET, there's a delay of up to 13ms before the change starts.
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	d1.l - Volume change
00000000                            ;	       H: New volume ($0000 = Min, $0400 = Max)
00000000                            ;	       L: Rate in steps/vblank
00000000                            ;	          $0001 = Slow
00000000                            ;	          $0200 = Fast
00000000                            ;	          $0400 = Set immediately
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_FDRCHG macro
00000000                            	CDBIOS	#FDRCHG
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Start reading data from the current logical sector into the CDC
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; The BIOS pre-seeks by 2 to 4 sectors and data read actually begins before
00000000                            ; the requested sector. It's up to the caller to identify the correct
00000000                            ; starting sector (usually by checking the time codes in the headers as
00000000                            ; they're read from the CDC buffer).
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_CDCSTART macro
00000000                            	CDBIOS	#CDCSTART
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Stop reading data into the CDC
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; If a sector is being read when CDCSTOP is called, it's lost.
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_CDCSTOP macro
00000000                            	CDBIOS	#CDCSTOP
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Check if sector data has been prepared
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; If no sector is ready for read, the carry bit will be set. Up to 5 sectors
00000000                            ; can be buffered in the CDC buffer.
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	cc/cs - Sector available for read/No sectors available
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_CDCSTAT macro
00000000                            	CDBIOS	#CDCSTAT
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Prepare to send sector to the current device destination
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Make sure to set the device destination BEFORE calling CDCREAD. If a sector
00000000                            ; is ready, the carry bit will be cleared on return and it's necessary to
00000000                            ; respond with a call to CDCACK.
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	d0.l  - Sector header in BCD MM:SS:FF:MD format, MD is sector mode
00000000                            ;	        $00 = CD-DA
00000000                            ;	        $01 = CD-ROM mode 1
00000000                            ;	        $02 = CD-ROM mode 2
00000000                            ;	cc/cs - Sector ready for transfer/Sector not ready
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_CDCREAD macro
00000000                            	CDBIOS	#CDCREAD
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Use the Sub-CPU to read one sector into RAM
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; The device destination must be set to SUB-CPU read before calling CDCTRN.
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	a0.l  - Pointer to sector destination buffer (At least $920 bytes)
00000000                            ;	a1.l  - Pointer to header destination buffer (At least 4 bytes)
00000000                            ; RETURNS:
00000000                            ;	a0.l  - Next sector destination address (a0 + $920)
00000000                            ;	a1.l  - Next header destination address (a1 + 4)
00000000                            ;	cc/cs - Sector successfully transferred/Transfer failed
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_CDCTRN macro
00000000                            	CDBIOS	#CDCTRN
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Inform the CDC that the current sector has been read and we're ready
00000000                            ; for the next sector
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_CDCACK macro
00000000                            	CDBIOS	#CDCACK
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Tell the BIOS which mode to read the CD in
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Mode 0 (CD-DA)                              %10
00000000                            ; Mode 1 (CD-ROM with full error correction)  %00
00000000                            ; Mode 2 (CD-ROM with CRC only)               %01
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	d1.w - xxxxxxxxxxxx3210
00000000                            ;	                   ||||
00000000                            ;	                   |||+--> CD Mode 2
00000000                            ;	                   ||+---> CD-DA mode
00000000                            ;	                   |+----> Transfer error block with data
00000000                            ;	                   +-----> Re-read last data
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_CDCSETMODE macro
00000000                            	CDBIOS	#CDCSETMODE
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Initialize the BIOS for subcode reading
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	a0.l - Pointer to scratch buffer (At least $750 bytes)
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_SCDINIT macro
00000000                            	CDBIOS	#SCDINIT
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Enable reading of subcode data by the CDC
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	d1.w - Subcode processing mode
00000000                            ;	       0 = --------
00000000                            ;	       1 = --RSTUVW
00000000                            ;	       2 = PQ------
00000000                            ;	       3 = PQRSTUVW
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_SCDSTART macro
00000000                            	CDBIOS	#SCDSTART
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Disable reading of subcode data by the CDC
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_SCDSTOP macro
00000000                            	CDBIOS	#SCDSTOP
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Get subcode error status
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	d0.l - errqcodecrc/errpackcirc/scdflag/restrcnt
00000000                            ;	d1.l - erroverrun/errpacketbufful/errqcodefufful/errpackfufful
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_SCDSTAT macro
00000000                            	CDBIOS	#SCDSTAT
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Reads R through W subcode channels
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	a0.l  - Pointer to subcode buffer (At least $18 bytes)
00000000                            ; RETURNS:
00000000                            ;	a0.l  - Address of next subcode buffer (a0.l + $18)
00000000                            ;	cc/cs - Read successful/Read failed
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_SCDREAD macro
00000000                            	CDBIOS	#SCDREAD
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Get P and Q codes from subcode
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	a0.l  - Pointer to Q code buffer (At least $C bytes)
00000000                            ; RETURNS:
00000000                            ;	a0.l  - Address of next Q code buffer (a0.l + $C)
00000000                            ;	cc/cs - Read successful/Read failed
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_SCDPQ macro
00000000                            	CDBIOS	#SCDPQ
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Get the last P and Q codes
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	a0.l  - Pointer to Q code buffer (At least $C bytes)
00000000                            ; RETURNS:
00000000                            ;	a0.l  - Address of next Q code buffer (a0.l + $C)
00000000                            ;	cc/cs - Read successful/Read failed
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_SCDPQL macro
00000000                            	CDBIOS	#SCDPQL
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Control the "Ready" and "Access" LEDs
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	d1.w
00000000                            ;	Mode            Ready (Green)  Access (Red)  System Indication
00000000                            ;	---------------------------------------------------------------
00000000                            ;	                Off            Off           Only at reset
00000000                            ;	0 - LEDREADY    On             Blink         CD ready/No disc
00000000                            ;	1 - LEDDISCIN   On             Off           CD ready/Disc ok
00000000                            ;	2 - LEDACCESS   On             On            CD accessing
00000000                            ;	3 - LEDSTANDBY  Blink          Off           Standby mode
00000000                            ;	4 - LEDERROR    Blink          Blink         Reserved
00000000                            ;	5 - LEDMODE5    Blink          On            Reserved
00000000                            ;	6 - LEDMODE6    Off            Blink         Reserved
00000000                            ;	7 - LEDMODE7    Off            On            Reserved
00000000                            ;	? - LEDSYSTEM                                Return to BIOS
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_LEDSET macro
00000000                            	CDBIOS	#LEDSET
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Prepare to write into or read from Backup RAM
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	a0.l  - Pointer to scratch RAM ($640 bytes)
00000000                            ;	a1.l  - Pointer to display strings buffer (12 bytes)
00000000                            ; RETURNS:
00000000                            ;	cc/cs - SEGA formatted RAM is present/Not formatted or no RAM
00000000                            ;	d0.w  - Size of Backup RAM ($2[000] - $100[000] bytes)
00000000                            ;	d1.w  - 0 = No RAM
00000000                            ;	        1 = Not formatted
00000000                            ;	        2 = Other format
00000000                            ;	a1.l  - Pointer to display strings
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_BRMINIT macro
00000000                            	BURAM	#BRMINIT
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Get how much Backup RAM has been used
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	a1.l - Pointer to display strings buffer (12 bytes)
00000000                            ; RETURNS:
00000000                            ;	d0.w - Number of blocks of free area
00000000                            ;	d1.w - Number of files in directory
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_BRMSTAT macro
00000000                            	BURAM	#BRMSTAT
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Search for the desired file in Backup RAM
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; The file names are 11 ASCII characters terminated with a 0.
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	a0.l  - Pointer to file name
00000000                            ; RETURNS:
00000000                            ;	cc/cs - File found/File not found
00000000                            ;	d0.w  - Number of blocks
00000000                            ;	d1.b  - Mode
00000000                            ;		 0 = normal
00000000                            ;		-1 = data protected (with protect function)
00000000                            ;	a0.l  - Backup RAM start address for search
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_BRMSERCH macro
00000000                            	BURAM	#BRMSERCH
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Read data from Backup RAM
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	a0.l  - Pointer to file name
00000000                            ;	a1.l  - Pointer to write buffer
00000000                            ; RETURNS:
00000000                            ;	cc/cs - Success/Error
00000000                            ;	d0.w  - Number of blocks
00000000                            ;	d1.b  - Mode
00000000                            ;	         0 = Normal
00000000                            ;	        -1 = Data protected
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_BRMREAD macro
00000000                            	BURAM	#BRMREAD
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Write data to Backup RAM
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	a0.l  - Pointer to parameters
00000000                            ;	        dc.b    "XXXXXXXXXXX", 0 ; File name
00000000                            ;	        dc.b    $XX		 ; Flag
00000000                            ;		                         ; $00 = Normal
00000000                            ;		                         ; $FF = Encoded
00000000                            ;	        dc.w    $XXXX            ; Block size
00000000                            ;	                                 ; $00 = $40 bytes
00000000                            ;	                                 ; $FF = $20 bytes
00000000                            ;	a1.l  - Pointer to save data
00000000                            ; RETURNS:
00000000                            ;	cc/cs - Success/Error
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_BRMWRITE macro
00000000                            	BURAM	#BRMWRITE
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Delete data from Backup RAM
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	a0.l  - Pointer to file name
00000000                            ; RETURNS:
00000000                            ;	cc/cs - Deleted/Not found
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_BRMDEL macro
00000000                            	BURAM	#BRMDEL
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Format Backup RAM
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Call BIOS_BRMINIT before calling this.
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	cc/cs - Success/Error
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_BRMFORMAT macro
00000000                            	BURAM	#BRMFORMAT
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Read directory from Backup RAM
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	d1.l  - H: Number of files to skip when all files cannot be read in
00000000                            ;	           one try
00000000                            ;	        L: Size of directory buffer (numer of files that can be read
00000000                            ;	           in the directory buffer)
00000000                            ;	a0.l  - Pointer to parameter (file name) table
00000000                            ;	a1.l  - Pointer to directory buffer
00000000                            ; RETURNS:
00000000                            ;	cc/cs - Success/Too much to read
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_BRMDIR macro
00000000                            	BURAM	#BRMDIR
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Check data written to Backup RAM
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	a0.l  - Pointer to parameters
00000000                            ;	        dc.b    "XXXXXXXXXXX", 0 ; File name
00000000                            ;	        dc.b    $XX		 ; Flag
00000000                            ;		                         ; $00 = Normal
00000000                            ;		                         ; $FF = Encoded
00000000                            ;	        dc.w    $XXXX            ; Block size
00000000                            ;	                                 ; $00 = $40 bytes
00000000                            ;	                                 ; $FF = $20 bytes
00000000                            ;	a1.l  - Pointer to save data
00000000                            ; RETURNS:
00000000                            ;	cc/cs - Success/Error
00000000                            ;	d0.w  - Error number
00000000                            ;	        -1 = Data does not match
00000000                            ;	         0 = File Not found
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BIOS_BRMVERIFY macro
00000000                            	BURAM	#BRMVERIFY
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Header
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	CPU	68000
00000000 =00000000                M 	cpu_mode:	= 0
00000000                            	org	SPSTART
00006000                            
00006000                            Header:
00006000 4D41 494E 2020 2020 2020+  	dc.b	"MAIN       "				; Module name
0000600B 00                         	dc.b	0					; No startup code
0000600C 0100                       	dc.w	$0100					; Version
0000600E 0000                       	dc.w	$0000					; Type
00006010 0000 0000                  	dc.l	$00000000				; Next module
00006014 0000 0000                  	dc.l	$00000000				; Module size
00006018 0000 0000                  	dc.l	JumpTable-Header			; Start address
0000601C 0000 0000                  	dc.l	$00000000				; Work RAM address
00006020                            
00006020                            ; ---------------------------------------------------------------------------
00006020                            ; Jump table
00006020                            ; ---------------------------------------------------------------------------
00006020                            
00006020                            JumpTable:
00006020 0000                       	dc.w	Initialize-JumpTable			; Initialization
00006022 0000                       	dc.w	Main-JumpTable				; Main
00006024 0000                       	dc.w	MDInterrupt-JumpTable			; Mega Drive interrupt
00006026 0000                       	dc.w	0					; User defined/End of table
00006028                            
00006028                            ; ---------------------------------------------------------------------------
00006028                            ; Initialize
00006028                            ; ---------------------------------------------------------------------------
00006028                            
00006028                            Initialize:
00006028                            	andi.b	#$E2,MEMMODE.w				; Disable priority mode, set to 2M mode
00006028 0238 00E2 8003           M 	anxi.b	#$e2,memmode.w
0000602E 4E75                       	rts
00006030                            
00006030                            ; ---------------------------------------------------------------------------
00006030                            ; Main
00006030                            ; ---------------------------------------------------------------------------
00006030                            
00006030                            Main:
00006030 08B8 0002 8033             	bclr	#2,INTMASK+1.w				; Disable INT2
00006036 6100 0000                  	bsr.w	InitPCM					; Initialize PCM
0000603A 08F8 0002 8033             	bset	#2,INTMASK+1.w				; Enable INT2
00006040                            
00006040                            .SendWordRAM:						; Give the Main CPU Word RAM
00006040 08F8 0000 8003             	bset	#0,MEMMODE.w
00006046 67F8                       	beq.s	.SendWordRAM
00006048                            
00006048                            .WaitMain:
00006048 0C38 0052 800E             	cmpi.b	#"R",MAINFLAG.w				; Is the Main CPU done with the security code?
0000604E 66F8                       	bne.s	.WaitMain				; If not, branch
00006050 11FC 0047 800F             	move.b	#"G",SUBFLAG.w				; Tell the Main CPU we got the memo
00006056                            
00006056                            .WaitMain2:
00006056 4A38 800E                  	tst.b	MAINFLAG.w				; Is the Main CPU ready to send commands?
0000605A 66FA                       	bne.s	.WaitMain2				; If not, branch
0000605C 11FC 0052 800F             	move.b	#"R",SUBFLAG.w				; Mark as ready to retrieve commands
00006062                            
00006062                            ; ---------------------------------------------------------------------------
00006062                            
00006062                            CommandLoop:
00006062 7000                       	moveq	#0,d0					; Get command ID
00006064 1038 800E                  	move.b	MAINFLAG.w,d0
00006068 67F8                       	beq.s	CommandLoop				; Wait if we if the ID is 0
0000606A                            
0000606A 11FC 0042 800F             	move.b	#"B",SUBFLAG.w				; Mark as busy
00006070                            	
00006070                            .WaitMain:
00006070 4A38 800E                  	tst.b	MAINFLAG.w				; Is the Main CPU ready to send commands again?
00006074 66FA                       	bne.s	.WaitMain				; If not, branch
00006076                            
00006076                            	add.w	d0,d0					; Go to command
00006076                          M 	local	num
00006076 D040                     M 	axd.w	d0,d0
00006078                            	add.w	d0,d0
00006078                          M 	local	num
00006078 D040                     M 	axd.w	d0,d0
0000607A 4EBB 0000                  	jsr	.Commands-4(pc,d0.w)
0000607E                            
0000607E 11FC 0052 800F             	move.b	#"R",SUBFLAG.w				; Mark as ready
00006084 60DC                       	bra.s	CommandLoop				; Loop
00006086                            
00006086                            ; ---------------------------------------------------------------------------
00006086                            ; Commands
00006086                            ; ---------------------------------------------------------------------------
00006086                            
00006086                            .Commands:
00006086 6000 0000                  	bra.w	GfxRender				; Start graphics rendering
0000608A 6000 0000                  	bra.w	CheckGfx				; Check graphics status
0000608E                            
0000608E                            ; ---------------------------------------------------------------------------
0000608E                            ; Mega Drive (level 2) interrupt
0000608E                            ; ---------------------------------------------------------------------------
0000608E                            
0000608E                            MDInterrupt:
0000608E 48E7 FFFE                  	movem.l	d0-a6,-(sp)				; Save registers
00006092 08B8 0002 8033             	bclr	#2,INTMASK+1.w				; Update PCM tracker
00006098 6100 0000                  	bsr.w	UpdatePCMTracker
0000609C 08F8 0002 8033             	bset	#2,INTMASK+1.w
000060A2 4CDF 7FFF                  	movem.l	(sp)+,d0-a6				; Restore registers
000060A6 4E75                       	rts
000060A8                            	
000060A8                            ; ---------------------------------------------------------------------------
000060A8                            ; Libraries
000060A8                            ; ---------------------------------------------------------------------------
000060A8                            
000060A8                            	include	"subcpu/gfx.s68k"			; Graphics library
000060A8                            ; ---------------------------------------------------------------------------
000060A8                            ; Mode 1 Demo
000060A8                            ; By Devon 2022
000060A8                            ; ---------------------------------------------------------------------------
000060A8                            ; Graphics commands
000060A8                            ; ---------------------------------------------------------------------------
000060A8                            
000060A8                            	include	"subcpu/gfxdef.i"
000060A8                            ; ---------------------------------------------------------------------------
000060A8                            ; Mode 1 Demo
000060A8                            ; By Devon 2022
000060A8                            ; ---------------------------------------------------------------------------
000060A8                            ; Graphics definitions
000060A8                            ; ---------------------------------------------------------------------------
000060A8                            
000060A8 =00000000                  STAMP_DATA	EQU	$00000			; Stamp data location in Word RAM
000060A8 =00010000                  STAMP_MAP	EQU	$10000			; Stamp map location in Word RAM
000060A8 =00020000                  TRACE_TABLE	EQU	$20000			; Trace table location in Word RAM
000060A8 =00030000                  IMG_BUFFER	EQU	$30000			; Image buffer location in Word RAM
000060A8                            
000060A8 =00000100                  IMG_WIDTH	EQU	256			; Image buffer width
000060A8 =00000070                  IMG_HEIGHT	EQU	112			; Image buffer height
000060A8 =000000A0                  IMG_FOV		EQU	160			; FOV
000060A8 =0000000E                  IMG_TILE_H	EQU	(IMG_HEIGHT+((7-(IMG_HEIGHT&7))&7))/8
000060A8 =00003800                  IMG_SIZE	EQU	(IMG_WIDTH/8)*(IMG_HEIGHT/8)*$20
000060A8                            
000060A8                            ; -------------------------------------------------------------------------
000060A8                            
000060A8                            ; -------------------------------------------------------------------------
000060A8                            ; Start graphics rendering
000060A8                            ; Based on https://www.coranac.com/tonc/text/mode7.htm
000060A8                            ; -------------------------------------------------------------------------
000060A8                            ; PARAMETERS:
000060A8                            ;	Cmd 0 - Camera X
000060A8                            ;	Cmd 1 - Camera Y
000060A8                            ;	Cmd 2 - Camera Z
000060A8                            ;	Cmd 3 - Camera angle
000060A8                            ; -------------------------------------------------------------------------
000060A8                            
000060A8                            GfxRender:
000060A8 3038 8016                  	move.w	MAINCOM3.w,d0			; Get sine values
000060AC                            	andi.w	#$1FE,d0
000060AC 0240 01FE                M 	anxi.w	#$1fe,d0
000060B0 41FA 0000                  	lea	SineTable+$10(pc),a0
000060B4 3430 00F0                  	move.w	-$10(a0,d0.w),d2		; sin(a)
000060B8 3630 0070                  	move.w	$70(a0,d0.w),d3			; cos(a)
000060BC                            
000060BC 41F9 000A 0000             	lea	WORDRAM2M+TRACE_TABLE,a0	; Trace table
000060C2 43FA 0000                  	lea	ReciprocalLUT(pc),a1		; Reciprocal LUT
000060C6                            
000060C6 3E3C 006F                  	move.w	#IMG_HEIGHT-1,d7
000060CA                            
000060CA                            .LineLoop:
000060CA 3019                       	move.w	(a1)+,d0			; lam = cam_pos_y / y
000060CC C0F8 8012                  	mulu.w	MAINCOM1.w,d0
000060D0 4840                       	swap	d0
000060D2                            
000060D2 3200                       	move.w	d0,d1				; lsf = lam * sin(a)
000060D4 C3C2                       	muls.w	d2,d1
000060D6 EA81                       	asr.l	#5,d1
000060D8 C1C3                       	muls.w	d3,d0				; lcf = lam * cos(a)
000060DA EA80                       	asr.l	#5,d0
000060DC                            
000060DC 383C 0080                  	move.w	#IMG_WIDTH/2,d4			; lxr = center * lcf
000060E0 C9C0                       	muls.w	d0,d4
000060E2 E084                       	asr.l	#8,d4
000060E4 3A3C 00A0                  	move.w	#IMG_FOV,d5			; lyr = fov * lsf
000060E8 CBC1                       	muls.w	d1,d5
000060EA E085                       	asr.l	#8,d5
000060EC                            
000060EC 3C38 8010                  	move.w	MAINCOM0.w,d6			; Start X = cam_pos_x - lxr + lyr
000060F0                            	sub.w	d4,d6
000060F0                          M 	local	num
000060F0 9C44                     M 	sxb.w	d4,d6
000060F2                            	add.w	d5,d6
000060F2                          M 	local	num
000060F2 DC45                     M 	axd.w	d5,d6
000060F4 30C6                       	move.w	d6,(a0)+
000060F6                            
000060F6 383C 0080                  	move.w	#IMG_WIDTH/2,d4			; lxr = center * lsf
000060FA C9C1                       	muls.w	d1,d4
000060FC E084                       	asr.l	#8,d4
000060FE 3A3C 00A0                  	move.w	#IMG_FOV,d5			; lyr = fov * lcf
00006102 CBC0                       	muls.w	d0,d5
00006104 E085                       	asr.l	#8,d5
00006106                            
00006106 3C38 8014                  	move.w	MAINCOM2.w,d6			; Start Y = cam_pos_z - lxr - lyr
0000610A                            	sub.w	d4,d6
0000610A                          M 	local	num
0000610A 9C44                     M 	sxb.w	d4,d6
0000610C                            	sub.w	d5,d6
0000610C                          M 	local	num
0000610C 9C45                     M 	sxb.w	d5,d6
0000610E 30C6                       	move.w	d6,(a0)+
00006110                            
00006110 3800                       	move.w	d0,d4				; Delta X = lcf
00006112 30C4                       	move.w	d4,(a0)+
00006114 3801                       	move.w	d1,d4				; Delta Y = lsf
00006116 30C4                       	move.w	d4,(a0)+
00006118                            
00006118 51CF FFB0                  	dbf	d7,.LineLoop			; Loop until all lines are set
0000611C                            
0000611C                            ; -------------------------------------------------------------------------
0000611C                            
0000611C 31FC 4000 805A             	move.w	#STAMP_MAP/4,STAMPMAP.w		; Set stamp map address
00006122 31FC C000 805E             	move.w	#IMG_BUFFER/4,IMGBUFFER.w	; Set image buffer address
00006128                            	
00006128 11FC 0007 8059             	move.b	#%111,GFXSIZE.w			; 4096x4096 repeated map, 32x32 stamps
0000612E 31FC 0100 8062             	move.w	#IMG_WIDTH,IMGHSIZE.w		; Set image buffer horizontal resolution
00006134 31FC 0070 8064             	move.w	#IMG_HEIGHT,IMGVSIZE.w		; Set image buffer vertical resolution
0000613A 31FC 000D 805C             	move.w	#IMG_TILE_H-1,IMGVSZTILE.w
00006140 31FC 0000 8060             	move.w	#0,IMGOFFSET.w			; Set image buffer offset
00006146                            
00006146 31FC 8000 8066             	move.w	#TRACE_TABLE/4,TRACETBL.w	; Set trace table address and start rendering
0000614C 4E75                       	rts
0000614E                            
0000614E                            ; -------------------------------------------------------------------------
0000614E                            
0000614E                            ReciprocalLUT:
0000614E 8000 5555 4000 3333 2AAB+  	dc.w	$8000, $5555, $4000, $3333, $2AAB, $2492, $2000, $1C72
0000615E 199A 1746 1555 13B1 1249+  	dc.w	$199A, $1746, $1555, $13B1, $1249, $1111, $1000, $0F0F
0000616E 0E39 0D79 0CCD 0C31 0BA3+  	dc.w	$0E39, $0D79, $0CCD, $0C31, $0BA3, $0B21, $0AAB, $0A3D
0000617E 09D9 097B 0925 08D4 0889+  	dc.w	$09D9, $097B, $0925, $08D4, $0889, $0842, $0800, $07C2
0000618E 0788 0750 071C 06EB 06BD+  	dc.w	$0788, $0750, $071C, $06EB, $06BD, $0690, $0666, $063E
0000619E 0618 05F4 05D1 05B0 0591+  	dc.w	$0618, $05F4, $05D1, $05B0, $0591, $0572, $0555, $0539
000061AE 051F 0505 04EC 04D5 04BE+  	dc.w	$051F, $0505, $04EC, $04D5, $04BE, $04A8, $0492, $047E
000061BE 046A 0457 0444 0432 0421+  	dc.w	$046A, $0457, $0444, $0432, $0421, $0410, $0400, $03F0
000061CE 03E1 03D2 03C4 03B6 03A8+  	dc.w	$03E1, $03D2, $03C4, $03B6, $03A8, $039B, $038E, $0382
000061DE 0376 036A 035E 0353 0348+  	dc.w	$0376, $036A, $035E, $0353, $0348, $033E, $0333, $0329
000061EE 031F 0316 030C 0303 02FA+  	dc.w	$031F, $0316, $030C, $0303, $02FA, $02F1, $02E9, $02E0
000061FE 02D8 02D0 02C8 02C1 02B9+  	dc.w	$02D8, $02D0, $02C8, $02C1, $02B9, $02B2, $02AB, $02A4
0000620E 029D 0296 028F 0289 0283+  	dc.w	$029D, $0296, $028F, $0289, $0283, $027C, $0276, $0270
0000621E 026A 0264 025F 0259 0254+  	dc.w	$026A, $0264, $025F, $0259, $0254, $024E, $0249, $0244
0000622E 023F 023A 0235 0230 022B+  	dc.w	$023F, $023A, $0235, $0230, $022B, $0227, $0222, $021E
0000623E 0219 0215 0211 020C 0208+  	dc.w	$0219, $0215, $0211, $020C, $0208, $0204, $0200, $01FC
0000624E 01F8 01F4 01F0 01ED 01E9+  	dc.w	$01F8, $01F4, $01F0, $01ED, $01E9, $01E5, $01E2, $01DE
0000625E 01DB 01D7 01D4 01D1 01CE+  	dc.w	$01DB, $01D7, $01D4, $01D1, $01CE, $01CA, $01C7, $01C4
0000626E 01C1 01BE 01BB 01B8 01B5+  	dc.w	$01C1, $01BE, $01BB, $01B8, $01B5, $01B2, $01AF, $01AC
0000627E 01AA 01A7 01A4 01A1 019F+  	dc.w	$01AA, $01A7, $01A4, $01A1, $019F, $019C, $019A, $0197
0000628E 0195 0192 0190 018D 018B+  	dc.w	$0195, $0192, $0190, $018D, $018B, $0188, $0186, $0184
0000629E 0182 017F 017D 017B 0179+  	dc.w	$0182, $017F, $017D, $017B, $0179, $0176, $0174, $0172
000062AE 0170 016E 016C 016A 0168+  	dc.w	$0170, $016E, $016C, $016A, $0168, $0166, $0164, $0162
000062BE 0160 015E 015D 015B 0159+  	dc.w	$0160, $015E, $015D, $015B, $0159, $0157, $0155, $0154
000062CE 0152 0150 014E 014D 014B+  	dc.w	$0152, $0150, $014E, $014D, $014B, $0149, $0148, $0146
000062DE 0144 0143 0141 0140 013E+  	dc.w	$0144, $0143, $0141, $0140, $013E, $013D, $013B, $013A
000062EE 0138 0137 0135 0134 0132+  	dc.w	$0138, $0137, $0135, $0134, $0132, $0131, $012F, $012E
000062FE 012D 012B 012A 0129 0127+  	dc.w	$012D, $012B, $012A, $0129, $0127, $0126, $0125, $0123
0000630E 0122 0121 011F 011E 011D+  	dc.w	$0122, $0121, $011F, $011E, $011D, $011C, $011A, $0119
0000631E 0118 0117 0116 0115 0113+  	dc.w	$0118, $0117, $0116, $0115, $0113, $0112, $0111, $0110
0000632E 010F 010E 010D 010B 010A+  	dc.w	$010F, $010E, $010D, $010B, $010A, $0109, $0108, $0107
0000633E 0106 0105 0104 0103 0102+  	dc.w	$0106, $0105, $0104, $0103, $0102, $0101, $0100, $00FF
0000634E                            
0000634E                            ; -------------------------------------------------------------------------
0000634E                            
0000634E                            SineTable:
0000634E 0000 0006 000C 0012 0019+  	dc.w	$0000, $0006, $000C, $0012, $0019, $001F, $0025, $002B
0000635E 0031 0038 003E 0044 004A+  	dc.w	$0031, $0038, $003E, $0044, $004A, $0050, $0056, $005C
0000636E 0061 0067 006D 0073 0078+  	dc.w	$0061, $0067, $006D, $0073, $0078, $007E, $0083, $0088
0000637E 008E 0093 0098 009D 00A2+  	dc.w	$008E, $0093, $0098, $009D, $00A2, $00A7, $00AB, $00B0
0000638E 00B5 00B9 00BD 00C1 00C5+  	dc.w	$00B5, $00B9, $00BD, $00C1, $00C5, $00C9, $00CD, $00D1
0000639E 00D4 00D8 00DB 00DE 00E1+  	dc.w	$00D4, $00D8, $00DB, $00DE, $00E1, $00E4, $00E7, $00EA
000063AE 00EC 00EE 00F1 00F3 00F4+  	dc.w	$00EC, $00EE, $00F1, $00F3, $00F4, $00F6, $00F8, $00F9
000063BE 00FB 00FC 00FD 00FE 00FE+  	dc.w	$00FB, $00FC, $00FD, $00FE, $00FE, $00FF, $00FF, $00FF
000063CE 0100 00FF 00FF 00FF 00FE+  	dc.w	$0100, $00FF, $00FF, $00FF, $00FE, $00FE, $00FD, $00FC
000063DE 00FB 00F9 00F8 00F6 00F4+  	dc.w	$00FB, $00F9, $00F8, $00F6, $00F4, $00F3, $00F1, $00EE
000063EE 00EC 00EA 00E7 00E4 00E1+  	dc.w	$00EC, $00EA, $00E7, $00E4, $00E1, $00DE, $00DB, $00D8
000063FE 00D4 00D1 00CD 00C9 00C5+  	dc.w	$00D4, $00D1, $00CD, $00C9, $00C5, $00C1, $00BD, $00B9
0000640E 00B5 00B0 00AB 00A7 00A2+  	dc.w	$00B5, $00B0, $00AB, $00A7, $00A2, $009D, $0098, $0093
0000641E 008E 0088 0083 007E 0078+  	dc.w	$008E, $0088, $0083, $007E, $0078, $0073, $006D, $0067
0000642E 0061 005C 0056 0050 004A+  	dc.w	$0061, $005C, $0056, $0050, $004A, $0044, $003E, $0038
0000643E 0031 002B 0025 001F 0019+  	dc.w	$0031, $002B, $0025, $001F, $0019, $0012, $000C, $0006
0000644E 0000 FFFA FFF4 FFEE FFE7+  	dc.w	$0000, $FFFA, $FFF4, $FFEE, $FFE7, $FFE1, $FFDB, $FFD5
0000645E FFCF FFC8 FFC2 FFBC FFB6+  	dc.w	$FFCF, $FFC8, $FFC2, $FFBC, $FFB6, $FFB0, $FFAA, $FFA4
0000646E FF9F FF99 FF93 FF8B FF88+  	dc.w	$FF9F, $FF99, $FF93, $FF8B, $FF88, $FF82, $FF7D, $FF78
0000647E FF72 FF6D FF68 FF63 FF5E+  	dc.w	$FF72, $FF6D, $FF68, $FF63, $FF5E, $FF59, $FF55, $FF50
0000648E FF4B FF47 FF43 FF3F FF3B+  	dc.w	$FF4B, $FF47, $FF43, $FF3F, $FF3B, $FF37, $FF33, $FF2F
0000649E FF2C FF28 FF25 FF22 FF1F+  	dc.w	$FF2C, $FF28, $FF25, $FF22, $FF1F, $FF1C, $FF19, $FF16
000064AE FF14 FF12 FF0F FF0D FF0C+  	dc.w	$FF14, $FF12, $FF0F, $FF0D, $FF0C, $FF0A, $FF08, $FF07
000064BE FF05 FF04 FF03 FF02 FF02+  	dc.w	$FF05, $FF04, $FF03, $FF02, $FF02, $FF01, $FF01, $FF01
000064CE FF00 FF01 FF01 FF01 FF02+  	dc.w	$FF00, $FF01, $FF01, $FF01, $FF02, $FF02, $FF03, $FF04
000064DE FF05 FF07 FF08 FF0A FF0C+  	dc.w	$FF05, $FF07, $FF08, $FF0A, $FF0C, $FF0D, $FF0F, $FF12
000064EE FF14 FF16 FF19 FF1C FF1F+  	dc.w	$FF14, $FF16, $FF19, $FF1C, $FF1F, $FF22, $FF25, $FF28
000064FE FF2C FF2F FF33 FF37 FF3B+  	dc.w	$FF2C, $FF2F, $FF33, $FF37, $FF3B, $FF3F, $FF43, $FF47
0000650E FF4B FF50 FF55 FF59 FF5E+  	dc.w	$FF4B, $FF50, $FF55, $FF59, $FF5E, $FF63, $FF68, $FF6D
0000651E FF72 FF78 FF7D FF82 FF88+  	dc.w	$FF72, $FF78, $FF7D, $FF82, $FF88, $FF8B, $FF93, $FF99
0000652E FF9F FFA4 FFAA FFB0 FFB6+  	dc.w	$FF9F, $FFA4, $FFAA, $FFB0, $FFB6, $FFBC, $FFC2, $FFC8
0000653E FFCF FFD5 FFDB FFE1 FFE7+  	dc.w	$FFCF, $FFD5, $FFDB, $FFE1, $FFE7, $FFEE, $FFF4, $FFFA
0000654E                            	; Extra values for cosine
0000654E 0000 0006 000C 0012 0019+  	dc.w	$0000, $0006, $000C, $0012, $0019, $001F, $0025, $002B
0000655E 0031 0038 003E 0044 004A+  	dc.w	$0031, $0038, $003E, $0044, $004A, $0050, $0056, $005C
0000656E 0061 0067 006D 0073 0078+  	dc.w	$0061, $0067, $006D, $0073, $0078, $007E, $0083, $0088
0000657E 008E 0093 0098 009D 00A2+  	dc.w	$008E, $0093, $0098, $009D, $00A2, $00A7, $00AB, $00B0
0000658E 00B5 00B9 00BD 00C1 00C5+  	dc.w	$00B5, $00B9, $00BD, $00C1, $00C5, $00C9, $00CD, $00D1
0000659E 00D4 00D8 00DB 00DE 00E1+  	dc.w	$00D4, $00D8, $00DB, $00DE, $00E1, $00E4, $00E7, $00EA
000065AE 00EC 00EE 00F1 00F3 00F4+  	dc.w	$00EC, $00EE, $00F1, $00F3, $00F4, $00F6, $00F8, $00F9
000065BE 00FB 00FC 00FD 00FE 00FE+  	dc.w	$00FB, $00FC, $00FD, $00FE, $00FE, $00FF, $00FF, $00FF
000065CE                            
000065CE                            ; -------------------------------------------------------------------------
000065CE                            ; Check graphics status
000065CE                            ; -------------------------------------------------------------------------
000065CE                            ; RETURNS:
000065CE                            ;	Stat 0	- 0 if inactive, -1 if busy
000065CE                            ; -------------------------------------------------------------------------
000065CE                            
000065CE                            CheckGfx:
000065CE 4A78 8058                  	tst.w	GFXON.w				; Is the graphics chip busy?
000065D2 6B00                       	bmi.s	.Busy				; If so, branch
000065D4                            
000065D4                            .SendWordRAM:
000065D4 08F8 0000 8003             	bset	#0,MEMMODE.w			; Give the Main CPU Word RAM access
000065DA 67F8                       	beq.s	.SendWordRAM
000065DC                            
000065DC 31FC 0000 8020             	move.w	#0,SUBCOM0.w			; Mark as inactive
000065E2 4E75                       	rts
000065E4                            
000065E4                            .Busy:
000065E4 31FC FFFF 8020             	move.w	#-1,SUBCOM0.w			; Mark as busy
000065EA 4E75                       	rts
000065EC                            
000065EC                            ; -------------------------------------------------------------------------
000065EC                            	include	"subcpu/pcm.s68k"			; PCM library
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            ; Mode 1 Demo
000065EC                            ; By Devon 2022
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            ; PCM driver
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            
000065EC                            	include	"subcpu/pcmscript.i"
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            ; Mode 1 Demo
000065EC                            ; By Devon 2022
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            ; PCM driver script definitions
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            ; Notes
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            
000065EC                            	rsset	$40
000065EC =00000040                  PCMNSTART	rs.b	0				; Start of notes
000065EC                            
000065EC =00000040                  NREST		rs.b	1				; Rest note
000065EC =00000041                  NCUT		rs.b	1				; Cut note
000065EC                            
000065EC =00000042                  NA0		rs.b	1				; Octave 0
000065EC =00000043                  NAS0		rs.b	0
000065EC =00000043                  NBB0		rs.b	1
000065EC =00000044                  NB0		rs.b	1
000065EC                            
000065EC =00000045                  NC1		rs.b	1				; Octave 1
000065EC =00000046                  NCS1		rs.b	0
000065EC =00000046                  NDB1		rs.b	1
000065EC =00000047                  ND1		rs.b	1
000065EC =00000048                  NDS1		rs.b	0
000065EC =00000048                  NEB1		rs.b	1
000065EC =00000049                  NE1		rs.b	1
000065EC =0000004A                  NF1		rs.b	1
000065EC =0000004B                  NFS1		rs.b	0
000065EC =0000004B                  NGB1		rs.b	1
000065EC =0000004C                  NG1		rs.b	1
000065EC =0000004D                  NGS1		rs.b	0
000065EC =0000004D                  NAB1		rs.b	1
000065EC =0000004E                  NA1		rs.b	1
000065EC =0000004F                  NAS1		rs.b	0
000065EC =0000004F                  NBB1		rs.b	1
000065EC =00000050                  NB1		rs.b	1
000065EC                            
000065EC =00000051                  NC2		rs.b	1				; Octave 2
000065EC =00000052                  NCS2		rs.b	0
000065EC =00000052                  NDB2		rs.b	1
000065EC =00000053                  ND2		rs.b	1
000065EC =00000054                  NDS2		rs.b	0
000065EC =00000054                  NEB2		rs.b	1
000065EC =00000055                  NE2		rs.b	1
000065EC =00000056                  NF2		rs.b	1
000065EC =00000057                  NFS2		rs.b	0
000065EC =00000057                  NGB2		rs.b	1
000065EC =00000058                  NG2		rs.b	1
000065EC =00000059                  NGS2		rs.b	0
000065EC =00000059                  NAB2		rs.b	1
000065EC =0000005A                  NA2		rs.b	1
000065EC =0000005B                  NAS2		rs.b	0
000065EC =0000005B                  NBB2		rs.b	1
000065EC =0000005C                  NB2		rs.b	1
000065EC                            
000065EC =0000005D                  NC3		rs.b	1				; Octave 3
000065EC =0000005E                  NCS3		rs.b	0
000065EC =0000005E                  NDB3		rs.b	1
000065EC =0000005F                  ND3		rs.b	1
000065EC =00000060                  NDS3		rs.b	0
000065EC =00000060                  NEB3		rs.b	1
000065EC =00000061                  NE3		rs.b	1
000065EC =00000062                  NF3		rs.b	1
000065EC =00000063                  NFS3		rs.b	0
000065EC =00000063                  NGB3		rs.b	1
000065EC =00000064                  NG3		rs.b	1
000065EC =00000065                  NGS3		rs.b	0
000065EC =00000065                  NAB3		rs.b	1
000065EC =00000066                  NA3		rs.b	1
000065EC =00000067                  NAS3		rs.b	0
000065EC =00000067                  NBB3		rs.b	1
000065EC =00000068                  NB3		rs.b	1
000065EC                            
000065EC =00000069                  NC4		rs.b	1				; Octave 4
000065EC =0000006A                  NCS4		rs.b	0
000065EC =0000006A                  NDB4		rs.b	1
000065EC =0000006B                  ND4		rs.b	1
000065EC =0000006C                  NDS4		rs.b	0
000065EC =0000006C                  NEB4		rs.b	1
000065EC =0000006D                  NE4		rs.b	1
000065EC =0000006E                  NF4		rs.b	1
000065EC =0000006F                  NFS4		rs.b	0
000065EC =0000006F                  NGB4		rs.b	1
000065EC =00000070                  NG4		rs.b	1
000065EC =00000071                  NGS4		rs.b	0
000065EC =00000071                  NAB4		rs.b	1
000065EC =00000072                  NA4		rs.b	1
000065EC =00000073                  NAS4		rs.b	0
000065EC =00000073                  NBB4		rs.b	1
000065EC =00000074                  NB4		rs.b	1
000065EC                            
000065EC =00000075                  NC5		rs.b	1				; Octave 5
000065EC =00000076                  NCS5		rs.b	0
000065EC =00000076                  NDB5		rs.b	1
000065EC =00000077                  ND5		rs.b	1
000065EC =00000078                  NDS5		rs.b	0
000065EC =00000078                  NEB5		rs.b	1
000065EC =00000079                  NE5		rs.b	1
000065EC =0000007A                  NF5		rs.b	1
000065EC =0000007B                  NFS5		rs.b	0
000065EC =0000007B                  NGB5		rs.b	1
000065EC =0000007C                  NG5		rs.b	1
000065EC =0000007D                  NGS5		rs.b	0
000065EC =0000007D                  NAB5		rs.b	1
000065EC =0000007E                  NA5		rs.b	1
000065EC =0000007F                  NAS5		rs.b	0
000065EC =0000007F                  NBB5		rs.b	1
000065EC =00000080                  NB5		rs.b	1
000065EC                            
000065EC =00000081                  NC6		rs.b	1				; Octave 6
000065EC =00000082                  NCS6		rs.b	0
000065EC =00000082                  NDB6		rs.b	1
000065EC =00000083                  ND6		rs.b	1
000065EC =00000084                  NDS6		rs.b	0
000065EC =00000084                  NEB6		rs.b	1
000065EC =00000085                  NE6		rs.b	1
000065EC =00000086                  NF6		rs.b	1
000065EC =00000087                  NFS6		rs.b	0
000065EC =00000087                  NGB6		rs.b	1
000065EC =00000088                  NG6		rs.b	1
000065EC =00000089                  NGS6		rs.b	0
000065EC =00000089                  NAB6		rs.b	1
000065EC =0000008A                  NA6		rs.b	1
000065EC =0000008B                  NAS6		rs.b	0
000065EC =0000008B                  NBB6		rs.b	1
000065EC =0000008C                  NB6		rs.b	1
000065EC                            
000065EC =0000008D                  NC7		rs.b	1				; Octave 7
000065EC =0000008E                  NCS7		rs.b	0
000065EC =0000008E                  NDB7		rs.b	1
000065EC =0000008F                  ND7		rs.b	1
000065EC =00000090                  NDS7		rs.b	0
000065EC =00000090                  NEB7		rs.b	1
000065EC =00000091                  NE7		rs.b	1
000065EC =00000092                  NF7		rs.b	1
000065EC =00000093                  NFS7		rs.b	0
000065EC =00000093                  NGB7		rs.b	1
000065EC =00000094                  NG7		rs.b	1
000065EC =00000095                  NGS7		rs.b	0
000065EC =00000095                  NAB7		rs.b	1
000065EC =00000096                  NA7		rs.b	1
000065EC =00000097                  NAS7		rs.b	0
000065EC =00000097                  NBB7		rs.b	1
000065EC =00000098                  NB7		rs.b	1
000065EC                            
000065EC =00000099                  NC8		rs.b	1				; Octave 8
000065EC =0000009A                  NCS8		rs.b	0
000065EC =0000009A                  NDB8		rs.b	1
000065EC =0000009B                  ND8		rs.b	1
000065EC =0000009C                  NDS8		rs.b	0
000065EC =0000009C                  NEB8		rs.b	1
000065EC =0000009D                  NE8		rs.b	1
000065EC =0000009E                  NF8		rs.b	1
000065EC =0000009F                  NFS8		rs.b	0
000065EC =0000009F                  NGB8		rs.b	1
000065EC =000000A0                  NG8		rs.b	1
000065EC =000000A1                  NGS8		rs.b	0
000065EC =000000A1                  NAB8		rs.b	1
000065EC                            
000065EC =000000A1                  PCMNEND		EQU	__rs-1				; End of notes
000065EC                            
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            ; Command IDs
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            
000065EC =000000A2                  PCMCSTART	rs.b	0				; Start of commands
000065EC                            
000065EC =000000A2                  PCMCIDJUMP	rs.b	1				; Jump
000065EC =000000A3                  PCMCIDLEGATO	rs.b	1				; Legato
000065EC =000000A4                  PCMCIDINS	rs.b	1				; Instrument
000065EC                            
000065EC =000000A4                  PCMCEND		EQU	__rs-1				; End of commands
000065EC                            
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            ; Start track
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            
000065EC =FFFFFFFF                  __pcm_track_id = -1
000065EC                            PCMTRKSTART macro
000065EC                            	__pcm_track_id: = __pcm_track_id+1
000065EC                            	__pcm_origin_\#__pcm_track_id\: EQU *
000065EC                            	endm
000065EC                            
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            ; Define instrument table
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            ; PARAMETERS:
000065EC                            ;	addr - Pointer to instrument table
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            
000065EC                            PCMINSTBL macro addr
000065EC                            	dc.w	(\addr)-(__pcm_origin_\#__pcm_track_id\)
000065EC                            	endm
000065EC                            
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            ; Start channel table
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            
000065EC                            PCMCHNSTART macro
000065EC                            	__pcm_chn_cnt: = -1
000065EC                            	dc.w	__pcm_chn_cnt_\#__pcm_track_id
000065EC                            	endm
000065EC                            
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            ; Define channel
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            ; PARAMETERS:
000065EC                            ;	addr - Pointer to track data
000065EC                            ;	id   - Channel ID
000065EC                            ;	vol  - Volume
000065EC                            ;	pan  - Panning
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            
000065EC                            PCMCHNPTR macro addr, id, vol, pan
000065EC                            	if ((\id)<0)|((\id)>7)
000065EC                            		inform 2,"Invalid PCM channel ID %d", \id
000065EC                            		mexit
000065EC                            	endif
000065EC                            
000065EC                            	__pcm_chn_cnt: = __pcm_chn_cnt+1
000065EC                            	dc.w	(\addr)-(__pcm_origin_\#__pcm_track_id\)
000065EC                            	dc.b	\id
000065EC                            	dc.b	\vol, \pan, 0
000065EC                            	endm
000065EC                            
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            ; End channel table
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            
000065EC                            PCMCHNEND macro
000065EC                            	__pcm_chn_cnt_\#__pcm_track_id: EQU __pcm_chn_cnt
000065EC                            	endm
000065EC                            
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            ; Start instrument table
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            
000065EC                            PCMINSSTART macro
000065EC                            	__pcm_instbl_\#__pcm_track_id\: EQU *
000065EC                            	endm
000065EC                            
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            ; Define instrument pointer
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            ; PARAMETERS:
000065EC                            ;	addr - Pointer to instrument data
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            
000065EC                            PCMINSPTR macro addr
000065EC                            	dc.w	(\addr)-(__pcm_instbl_\#__pcm_track_id\)
000065EC                            	endm
000065EC                            
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            ; Define instrument data
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            ; PARAMETERS:
000065EC                            ;	addr   - Pointer to sample data
000065EC                            ;	len    - Length of sample data
000065EC                            ;	loop   - Loop point
000065EC                            ;	nstart - Note range start
000065EC                            ;	nend   - Note range end
000065EC                            ;	root   - Root note
000065EC                            ;	detune - Detune
000065EC                            ;	atk    - Attack rate
000065EC                            ;	dec    - Decay rate
000065EC                            ;	slv    - Sustain level
000065EC                            ;	sus    - Sustain rate
000065EC                            ;	rel    - Release rate
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            
000065EC                            PCMINSDAT macro addr, len, loop, nstart, nend, root, detune, atk, dec, slv, sus, rel
000065EC                            	if ((\nstart)<PCMNSTART)|((\nstart)>PCMNEND)
000065EC                            		inform 2,"Invalid note range start"
000065EC                            		mexit
000065EC                            	elseif ((\nend)<PCMNSTART)|((\nend)>PCMNEND)
000065EC                            		inform 2,"Invalid note range end"
000065EC                            		mexit
000065EC                            	elseif (\nend)<(\nstart)
000065EC                            		inform 2,"Note range end is less than start"
000065EC                            		mexit
000065EC                            	elseif ((\root)<PCMNSTART)|((\root)>PCMNEND)
000065EC                            		inform 2,"Invalid root note"
000065EC                            		mexit
000065EC                            	endif
000065EC                            	
000065EC                            	dc.l	\addr
000065EC                            	dc.l	\len
000065EC                            	dc.l	\loop
000065EC                            	dc.l	((NA4-(\root))<<16)+(\detune)
000065EC                            	dc.b	\atk, \dec, \slv, \sus, \rel
000065EC                            	dc.b	(\nstart)-NA0, (\nend)-NA0
000065EC                            	even
000065EC                            	endm
000065EC                            
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            ; End of instrument data
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            
000065EC                            PCMINSEND macro
000065EC                            	dc.w	-1
000065EC                            	endm
000065EC                            
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            ; Jump command
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            ; PARAMETERS:
000065EC                            ;	addr - Address to jump to
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            
000065EC                            PCMCJUMP macro addr
000065EC                            	dc.b	PCMCIDJUMP
000065EC                            	dc.w	(\addr)-(*+2)
000065EC                            	endm
000065EC                            
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            ; Legato command
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            
000065EC =000000A3                  PCMCLEGATO	EQU	PCMCIDLEGATO
000065EC                            
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            ; Set instrument command
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            ; PARAMETERS:
000065EC                            ;	ins - Instrument ID
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            
000065EC                            PCMCINS macro ins
000065EC                            	dc.b	PCMCIDINS, \ins
000065EC                            	endm
000065EC                            
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            ; Constants
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            
000065EC =00001000                  PCMBANKSZ	EQU	$1000				; Wave bank size
000065EC =00000020                  PCMLOOPCNT	EQU	$20				; Stream loop flag count
000065EC                            
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            ; PCM channel structure
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            
000065EC                            	rsreset
000065EC =00000000                  pcmChnID	rs.b	1				; Channel ID
000065EC =00000001                  pcmFlags	rs.b	1				; Flags
000065EC                            
000065EC =00000002                  pcmTrkAddr	rs.l	1				; Tracker data address
000065EC =00000006                  pcmInsTable	rs.l	1				; Instrument table address
000065EC                            
000065EC =0000000A                  pcmDuration	rs.b	1				; Note duration
000065EC =0000000B                  pcmSavedDur	rs.b	1				; Saved note duration
000065EC                            
000065EC =0000000C                  pcmFreq		rs.l	1				; Frequency
000065EC =00000010                  pcmDetune	rs.l	1				; Detune
000065EC =00000014                  pcmNote		rs.b	1				; Note
000065EC                            
000065EC =00000015                  pcmPortaLen	rs.b	1				; Portamento length
000065EC =00000016                  pcmPortaAccum	rs.l	1				; Portamento accumulator
000065EC =0000001A                  pcmPortaFreq	rs.l	1				; Portamento target frequency
000065EC                            
000065EC =0000001E                  pcmVolume	rs.b	1				; Volume
000065EC =0000001F                  pcmPanning	rs.b	1				; Panning
000065EC =00000020                  pcmIns		rs.b	1				; Instrument ID
000065EC                            
000065EC =00000021                  pcmEnvMode	rs.b	1				; Envelope mode
000065EC =00000022                  pcmEnvVolume	rs.b	1				; Envelope volume level
000065EC =00000023                  pcmAttackRate	rs.b	1				; Attack rate
000065EC =00000024                  pcmDecayRate	rs.b	1				; Decay rate
000065EC =00000025                  pcmSustainLvl	rs.b	1				; Sustain level
000065EC =00000026                  pcmSustainRate	rs.b	1				; Sustain rate
000065EC =00000027                  pcmReleaseRate	rs.b	1				; Release rate
000065EC                            
000065EC =00000028                  pcmSamplePos	rs.l	1				; Sample position
000065EC =0000002C                  pcmSampleStart	rs.l	1				; Sample start address
000065EC =00000030                  pcmSampleLoop	rs.l	1				; Sample loop position
000065EC =00000034                  pcmSampleSize	rs.l	1				; Size of sample
000065EC =00000038                  pcmSamplesLeft	rs.l	1				; Samples left to stream
000065EC =0000003C                  pcmSampleDetune	rs.l	1				; Sample detune
000065EC =00000040                  pcmStreamBuf	rs.l	1				; Stream buffer address
000065EC =00000044                  pcmLastAddr	rs.w	1				; Last wave RAM playback position
000065EC =00000046                  pcmBytesLeft	rs.w	1				; Bytes left in bank
000065EC                            
000065EC =00000048                  pcmChnSize	rs.b	0				; Size of structure
000065EC                            
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            ; PCM channel flags
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            
000065EC                            	rsreset
000065EC =00000000                  PCMFSMPBANK	rs.b	1				; Sample wave bank
000065EC =00000001                  PCMFSMPSET	rs.b	1				; Sample setup
000065EC =00000002                  PCMFSMPSTRM	rs.b	1				; Sample stream
000065EC =00000003                  PCMFREST	rs.b	1				; Rest flag
000065EC =00000004                  PCMFLEGATO	rs.b	1				; Legato
000065EC =00000005                  PCMFPORTA	rs.b	1				; Portamento
000065EC                            		rs.b	1
000065EC =00000007                  PCMFPLAY	rs.b	1				; Playing
000065EC                            
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            ; PCM instrument sample metadata structure
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            
000065EC                            	rsreset
000065EC =00000000                  pcmISmpAddr	rs.l	1				; Sample data address
000065EC =00000004                  pcmISmpLen	rs.l	1				; Size of sample data
000065EC =00000008                  pcmISmpLoop	rs.l	1				; Loop point
000065EC =0000000C                  pcmISmpDetune	rs.l	1				; Transposition
000065EC                            
000065EC =00000010                  pcmISmpAtk	rs.b	1				; Attack rate
000065EC =00000011                  pcmISmpDec	rs.b	1				; Decay rate
000065EC =00000012                  pcmISmpSLv	rs.b	1				; Sustain level
000065EC =00000013                  pcmISmpSus	rs.b	1				; Sustain rate
000065EC =00000014                  pcmISmpRel	rs.b	1				; Release rate
000065EC                            
000065EC =00000015                  pcmISmpNStart	rs.b	1				; Note range start
000065EC =00000016                  pcmISmpNEnd	rs.b	1				; Note range end
000065EC                            
000065EC                            		rs.b	__rs&1
000065EC =00000018                  pcmISmpSize	rs.b	0				; size of structure
000065EC                            
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            ; Initial PCM channel structure data
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            
000065EC                            PCMCHNDAT macro id
000065EC                            	dcb.b	pcmChnID, 0				; Fill data before channel ID with zero
000065EC                            	dc.b	\id					; Channel ID
000065EC                            	dcb.b	pcmChnSize-(pcmChnID+1), 0		; Fill the rest with zero
000065EC                            	endm
000065EC                            
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            ; PCM register write
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            ; PARAMETERS:
000065EC                            ;	snd - Sound on/off flag
000065EC                            ;	reg - Data register to use
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            
000065EC                            PCMREG macro src, dest, snd, reg
000065EC                            	move.b	\src,\dest				; Write register data
000065EC                            	if (\snd)<>0					; Delay
000065EC                            		moveq	#$28-1,\reg
000065EC                            	else
000065EC                            		moveq	#5-1,\reg
000065EC                            	endif
000065EC                            	dbf	\reg,*
000065EC                            	endm
000065EC                            
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            ; Initialize PCM
000065EC                            ; ---------------------------------------------------------------------------
000065EC                            
000065EC                            InitPCM:
000065EC 6100 0000                  	bsr.w	StopPCMChannels				; Stop all PCM channels
000065F0                            
000065F0 43FA 0000                  	lea	TestTrack(pc),a1			; Get music data
000065F4 2209                       	move.l	a1,d1
000065F6                            
000065F6 7000                       	moveq	#0,d0					; Instrument table
000065F8 3019                       	move.w	(a1)+,d0
000065FA                            	add.l	d1,d0
000065FA                          M 	local	num
000065FA D081                     M 	axd.l	d1,d0
000065FC                            
000065FC 3819                       	move.w	(a1)+,d4				; Channel count
000065FE 6B00                       	bmi.s	.Done					; If there are none, branch
00006600                            
00006600                            .InitTracks:
00006600 7400                       	moveq	#0,d2					; Track data
00006602 3419                       	move.w	(a1)+,d2
00006604                            	add.l	d1,d2
00006604                          M 	local	num
00006604 D481                     M 	axd.l	d1,d2
00006606                            
00006606 7600                       	moveq	#0,d3					; Get track RAM
00006608 1619                       	move.b	(a1)+,d3
0000660A                            	add.w	d3,d3
0000660A                          M 	local	num
0000660A D643                     M 	axd.w	d3,d3
0000660C                            	add.w	d3,d3
0000660C                          M 	local	num
0000660C D643                     M 	axd.w	d3,d3
0000660E 207B 3000                  	movea.l	.Channels(pc,d3.w),a0
00006612                            	
00006612 1159 001E                  	move.b	(a1)+,pcmVolume(a0)			; Set volume
00006616 1159 001F                  	move.b	(a1)+,pcmPanning(a0)			; Set panning
0000661A                            
0000661A                            	addq.w	#1,a1					; TODO
0000661A 5249                     M 	axdq.w	#1,a1
0000661C                            
0000661C 2142 0002                  	move.l	d2,pcmTrkAddr(a0)			; Set track data address
00006620 2140 0006                  	move.l	d0,pcmInsTable(a0)			; Set instrument table
00006624                            	
00006624                            							; Set flags
00006624 117C 0088 0001             	move.b	#(1<<PCMFREST)|(1<<PCMFPLAY),pcmFlags(a0)
0000662A 117C 0040 0014             	move.b	#NREST,pcmNote(a0)			; Set rest note
00006630                            
00006630 51CC FFCE                  	dbf	d4,.InitTracks				; Loop until finished
00006634                            
00006634                            .Done:
00006634 4E75                       	rts
00006636                            
00006636                            ; ---------------------------------------------------------------------------
00006636                            
00006636                            .Channels:
00006636 0000 0000                  	dc.l	pcm_channel_1				; Channel 1
0000663A 0000 0000                  	dc.l	pcm_channel_2				; Channel 2
0000663E 0000 0000                  	dc.l	pcm_channel_3				; Channel 3
00006642 0000 0000                  	dc.l	pcm_channel_4				; Channel 4
00006646 0000 0000                  	dc.l	pcm_channel_5				; Channel 5
0000664A 0000 0000                  	dc.l	pcm_channel_6				; Channel 6
0000664E 0000 0000                  	dc.l	pcm_channel_7				; Channel 7
00006652 0000 0000                  	dc.l	pcm_channel_8				; Channel 8
00006656                            
00006656                            ; ---------------------------------------------------------------------------
00006656                            ; Update PCM tracker
00006656                            ; ---------------------------------------------------------------------------
00006656                            
00006656                            UpdatePCMTracker:
00006656 41FA 0000                  	lea	pcm_channel_1(pc),a0			; Update channel 1
0000665A 6100                       	bsr.s	UpdatePCMChannel
0000665C 41FA 0000                  	lea	pcm_channel_2(pc),a0			; Update channel 2
00006660 6100                       	bsr.s	UpdatePCMChannel
00006662 41FA 0000                  	lea	pcm_channel_3(pc),a0			; Update channel 3
00006666 6100                       	bsr.s	UpdatePCMChannel
00006668 41FA 0000                  	lea	pcm_channel_4(pc),a0			; Update channel 4
0000666C 6100                       	bsr.s	UpdatePCMChannel
0000666E 41FA 0000                  	lea	pcm_channel_5(pc),a0			; Update channel 5
00006672 6100                       	bsr.s	UpdatePCMChannel
00006674 41FA 0000                  	lea	pcm_channel_6(pc),a0			; Update channel 6
00006678 6100                       	bsr.s	UpdatePCMChannel
0000667A 41FA 0000                  	lea	pcm_channel_7(pc),a0			; Update channel 7
0000667E 6100                       	bsr.s	UpdatePCMChannel
00006680 41FA 0000                  	lea	pcm_channel_8(pc),a0			; Update channel 8
00006684                            
00006684                            ; ---------------------------------------------------------------------------
00006684                            ; Update PCM channel
00006684                            ; ---------------------------------------------------------------------------
00006684                            
00006684                            UpdatePCMChannel:
00006684 4A28 0001                  	tst.b	pcmFlags(a0)				; Is this channel playing?
00006688 6A00 0000                  	bpl.w	.End					; If not, branch
0000668C                            
0000668C                            	subq.b	#1,pcmDuration(a0)			; Decrement duration
0000668C 5328 000A                M 	sxbq.b	#1,pcmduration(a0)
00006690 6A00 0000                  	bpl.w	.UpdateNote				; If it hasn't run out, branch
00006694                            
00006694                            ; ---------------------------------------------------------------------------
00006694                            
00006694                            .ParseTrackData:
00006694 2268 0002                  	movea.l	pcmTrkAddr(a0),a1			; Get tracker data address
00006698                            
00006698                            .ParseLoop:
00006698 7000                       	moveq	#0,d0					; Read byte
0000669A 1019                       	move.b	(a1)+,d0
0000669C 0C00 00A2                  	cmpi.b	#PCMCSTART,d0				; Is it a command?
000066A0 6500                       	bcs.s	.NotCommand				; If not, branch
000066A2                            
000066A2 45FA 0000                  	lea	PCMCommands(pc),a2			; Jump to command handler
000066A6                            	subi.b	#PCMCSTART,d0
000066A6 0400 00A2                M 	sxbi.b	#pcmcstart,d0
000066AA                            	add.w	d0,d0
000066AA                          M 	local	num
000066AA D040                     M 	axd.w	d0,d0
000066AC                            	add.w	d0,d0
000066AC                          M 	local	num
000066AC D040                     M 	axd.w	d0,d0
000066AE 4EB2 0000                  	jsr	(a2,d0.w)
000066B2                            
000066B2 60E4                       	bra.s	.ParseLoop				; Continue parsing
000066B4                            
000066B4                            ; ---------------------------------------------------------------------------
000066B4                            
000066B4                            .NotCommand:
000066B4 0C00 0040                  	cmpi.b	#PCMNSTART,d0				; Is this a note?
000066B8 6500                       	bcs.s	.GotDuration				; If not, branch
000066BA 1140 0014                  	move.b	d0,pcmNote(a0)				; If so, set note ID
000066BE                            
000066BE 0C11 0040                  	cmpi.b	#PCMNSTART,(a1)				; Is the next byte a duration?
000066C2 6400                       	bcc.s	.ParseDone				; If not, branch
000066C4 1019                       	move.b	(a1)+,d0				; Get duration value
000066C6                            
000066C6                            .GotDuration:
000066C6 1140 000B                  	move.b	d0,pcmSavedDur(a0)			; Save duration
000066CA                            
000066CA                            ; ---------------------------------------------------------------------------
000066CA                            
000066CA                            .ParseDone:
000066CA 2149 0002                  	move.l	a1,pcmTrkAddr(a0)			; Update tracker data address
000066CE 1168 000B 000A             	move.b	pcmSavedDur(a0),pcmDuration(a0)		; Set duration
000066D4                            	
000066D4 7000                       	moveq	#0,d0					; Get current note
000066D6 1028 0014                  	move.b	pcmNote(a0),d0
000066DA                            	subi.b	#PCMNSTART,d0
000066DA 0400 0040                M 	sxbi.b	#pcmnstart,d0
000066DE 6700 0000                  	beq.w	.RestNote				; If it's a rest note, branch
000066E2 0C00 0001                  	cmpi.b	#NCUT-PCMNSTART,d0			; Is it a cut note?
000066E6 6700 0000                  	beq.w	.CutNote				; If so, branch
000066EA                            
000066EA                            ; ---------------------------------------------------------------------------
000066EA                            
000066EA                            .RegularNote:
000066EA                            	subq.b	#NA0-PCMNSTART,d0			; Get frequency
000066EA 5500                     M 	sxbq.b	#na0-pcmnstart,d0
000066EC                            	
000066EC 08A8 0003 0001             	bclr	#PCMFREST,pcmFlags(a0)			; Clear rest flag
000066F2 6600                       	bne.s	.SetFreq				; If it was set before, branch
000066F4 0828 0005 0001             	btst	#PCMFPORTA,pcmFlags(a0)			; Is portamento active?
000066FA 6700                       	beq.s	.SetFreq				; If not, branch
000066FC 08A8 0004 0001             	bclr	#PCMFLEGATO,pcmFlags(a0)		; Clear legato flag
00006702                            
00006702 3140 001A                  	move.w	d0,pcmPortaFreq(a0)			; Set target portamento frequency
00006706 4268 001C                  	clr.w	pcmPortaFreq+2(a0)
0000670A                            	
0000670A 7200                       	moveq	#0,d1					; Get portamento length
0000670C 1228 0015                  	move.b	pcmPortaLen(a0),d1
00006710 6700 0000                  	beq.w	.KeyOn					; If we aren't using the length, branch
00006714                            	
00006714 7600                       	moveq	#0,d3					; Number of shifts made
00006716 2428 001A                  	move.l	pcmPortaFreq(a0),d2			; Get frequency difference
0000671A                            	sub.l	pcmFreq(a0),d2
0000671A                          M 	local	num
0000671A 94A8 000C                M 	sxb.l	pcmfreq(a0),d2
0000671E 6A00                       	bpl.s	.FixPortaLen
00006720 4482                       	neg.l	d2
00006722                            
00006722                            .FixPortaLen:
00006722                            	; This exists because m68k division can only produce a 16-bit result. If the
00006722                            	; result is too large, it will not be saved. We shift it down until it
00006722                            	; can at least be divided by 2. A little bit of precision is lost when it
00006722                            	; gets shifted down, but  there's not really much else I can do about this
00006722                            	; whole thing.
00006722 0C01 0001                  	cmpi.b	#1,d1					; Is the length 1?
00006726 6700                       	beq.s	.SetPortaAccum				; If so, branch
00006728                            
00006728                            .FixPortaLenLoop:
00006728 0C82 0002 0000             	cmpi.l	#$20000,d2				; Is the value too large for even a division by 2?
0000672E 6500                       	bcs.s	.DividePortaLen				; If not, branch
00006730 E28A                       	lsr.l	#1,d2					; Shift value down
00006732                            	addq.b	#1,d3					; Increment shift count
00006732 5203                     M 	axdq.b	#1,d3
00006734 60F2                       	bra.s	.FixPortaLenLoop			; Loop until value can fit nicely in a division
00006736                            
00006736                            .DividePortaLen:
00006736 84C1                       	divu.w	d1,d2					; Divide distance by portamento length
00006738 4842                       	swap	d2
0000673A 4242                       	clr.w	d2
0000673C 4842                       	swap	d2
0000673E E7AA                       	lsl.l	d3,d2					; Shift result back
00006740                            
00006740                            .SetPortaAccum:
00006740 2142 0016                  	move.l	d2,pcmPortaAccum(a0)			; Set portamento accumulator
00006744                            	
00006744 6000                       	bra.s	.KeyOn					; Key on
00006746                            	
00006746                            .SetFreq:
00006746 3140 000C                  	move.w	d0,pcmFreq(a0)				; Set note frequency
0000674A 4268 000E                  	clr.w	pcmFreq+2(a0)
0000674E                            
0000674E                            .CheckLegato:
0000674E 08A8 0004 0001             	bclr	#PCMFLEGATO,pcmFlags(a0)		; Clear legato flag
00006754 6600                       	bne.s	.KeyOn					; If it was set, branch
00006756 6100 0000                  	bsr.w	KeyOffPCM				; Key off
0000675A                            	
0000675A 2268 0006                  	movea.l	pcmInsTable(a0),a1			; Get instrument table entry
0000675E 7200                       	moveq	#0,d1
00006760 1228 0020                  	move.b	pcmIns(a0),d1
00006764                            	add.w	d1,d1
00006764                          M 	local	num
00006764 D241                     M 	axd.w	d1,d1
00006766                            	adda.w	(a1,d1.w),a1
00006766 D2F1 1000                M 	axda.w	(a1,d1.w),a1
0000676A                            
0000676A                            .FindSample:
0000676A 1229 0015                  	move.b	pcmISmpNStart(a1),d1			; Get sample start note
0000676E 0C01 00FF                  	cmpi.b	#$FF,d1					; Is this the end of the sample list?
00006772 6700                       	beq.s	.UpdateNote				; If so, don't play a sample
00006774                            	
00006774 B001                       	cmp.b	d1,d0					; Is the current note at least the sample start note?
00006776 6500                       	bcs.s	.NextSample				; If not, branch
00006778 B029 0016                  	cmp.b	pcmISmpNEnd(a1),d0			; Is the current note within the note range?
0000677C 6300                       	bls.s	.StartSample				; If so, branch
0000677E                            
0000677E                            .NextSample:
0000677E 43E9 0018                  	lea	pcmISmpSize(a1),a1			; Next sample
00006782 60E6                       	bra.s	.FindSample				; Loop until sample is found
00006784                            
00006784                            .StartSample:
00006784 2159 002C                  	move.l	(a1)+,pcmSampleStart(a0)		; Sample start
00006788 2159 0034                  	move.l	(a1)+,pcmSampleSize(a0)			; Sample size
0000678C 2159 0030                  	move.l	(a1)+,pcmSampleLoop(a0)			; Sample loop
00006790 2159 003C                  	move.l	(a1)+,pcmSampleDetune(a0)		; Sample detune
00006794 2159 0023                  	move.l	(a1)+,pcmAttackRate(a0)			; Envelope parameters
00006798 1159 0027                  	move.b	(a1)+,pcmReleaseRate(a0)
0000679C                            
0000679C 08A8 0001 0001             	bclr	#PCMFSMPSET,pcmFlags(a0)		; Clear sample setup flag
000067A2 4228 0021                  	clr.b	pcmEnvMode(a0)				; Reset envelope
000067A6 4228 0022                  	clr.b	pcmEnvVolume(a0)
000067AA                            
000067AA                            .KeyOn:
000067AA 6100                       	bsr.s	.UpdateNote				; Update note
000067AC 6000 0000                  	bra.w	KeyOnPCM				; Key on
000067B0                            
000067B0                            ; ---------------------------------------------------------------------------
000067B0                            
000067B0                            .RestNote:
000067B0 08E8 0003 0001             	bset	#PCMFREST,pcmFlags(a0)			; Set rest flag
000067B6 117C 0008 0021             	move.b	#8,pcmEnvMode(a0)			; Set to release mode
000067BC 6000                       	bra.s	.UpdateNote				; Update note
000067BE                            
000067BE                            ; ---------------------------------------------------------------------------
000067BE                            
000067BE                            .CutNote:
000067BE 08E8 0003 0001             	bset	#PCMFREST,pcmFlags(a0)			; Set rest flag
000067C4 6100 0000                  	bsr.w	KeyOffPCM				; Key off
000067C8                            
000067C8                            ; ---------------------------------------------------------------------------
000067C8                            
000067C8                            .UpdateNote:
000067C8 6100 0000                  	bsr.w	UpdatePCMPorta				; Update portamento
000067CC 6100 0000                  	bsr.w	UpdatePCMADSREnv			; Update ADSR envelope
000067D0 6000 0000                  	bra.w	UpdatePCMChnData			; Update data
000067D4                            
000067D4                            .End:
000067D4 4E75                       	rts
000067D6                            	
000067D6                            ; ---------------------------------------------------------------------------
000067D6                            ; Stop all channels
000067D6                            ; ---------------------------------------------------------------------------
000067D6                            
000067D6                            StopPCMChannels:
000067D6 50C0                       	st	d0					; Disable all channels
000067D8 13C0 0000 0000             	move.b	d0,pcmOnFlags
000067DE 13C0 00FF 0011             	move.b	d0,PCMONOFF
000067E4                            
000067E4 41FA 0000                  	lea	pcm_channel_1(pc),a0			; Start with channel 1
000067E8 7007                       	moveq	#8-1,d0					; Number of channels
000067EA                            
000067EA                            .StopLoop:
000067EA 4228 0001                  	clr.b	pcmFlags(a0)				; Clear flags
000067EE                            	
000067EE 1210                       	move.b	pcmChnID(a0),d1				; Control channel
000067F0                            	ori.b	#$40,d1
000067F0 0001 0040                M 	oxi.b	#$40,d1
000067F4                            	PCMREG	d1,PCMCTRL,0,d1
000067F4 13C1 00FF 000F           M 	move.b	d1,pcmctrl
000067FA 7204                     M 	moveq	#5-1,d1
000067FC 51C9 FFFE                M 	dbf	d1,*
00006800                            	
00006800 4228 001E                  	clr.b	pcmVolume(a0)				; Mute volume
00006804                            	PCMREG	#0,PCMENV,0,d1
00006804 13FC 0000 00FF 0001      M 	move.b	#0,pcmenv
0000680C 7204                     M 	moveq	#5-1,d1
0000680E 51C9 FFFE                M 	dbf	d1,*
00006812                            
00006812 41E8 0048                  	lea	pcmChnSize(a0),a0			; Next channel
00006816 51C8 FFD2                  	dbf	d0,.StopLoop				; Loop until all channels are stopped
0000681A 4E75                       	rts
0000681C                            
0000681C                            ; ---------------------------------------------------------------------------
0000681C                            ; Set channel key on
0000681C                            ; ---------------------------------------------------------------------------
0000681C                            ; PARAMETERS:
0000681C                            ;	a0.l - PCM channel data structure
0000681C                            ; ---------------------------------------------------------------------------
0000681C                            
0000681C                            KeyOnPCM:
0000681C 103A 0000                  	move.b	pcmOnFlags(pc),d0			; Set channel key on
00006820 1210                       	move.b	pcmChnID(a0),d1
00006822 0380                       	bclr	d1,d0
00006824 13C0 0000 0000             	move.b	d0,pcmOnFlags
0000682A 13C0 00FF 0011             	move.b	d0,PCMONOFF
00006830 4E75                       	rts
00006832                            
00006832                            ; ---------------------------------------------------------------------------
00006832                            ; Set channel key off
00006832                            ; ---------------------------------------------------------------------------
00006832                            ; PARAMETERS:
00006832                            ;	a0.l - PCM channel data structure
00006832                            ; ---------------------------------------------------------------------------
00006832                            
00006832                            KeyOffPCM:
00006832 123A 0000                  	move.b	pcmOnFlags(pc),d1			; Set channel key off
00006836 1410                       	move.b	pcmChnID(a0),d2
00006838 05C1                       	bset	d2,d1
0000683A 13C1 0000 0000             	move.b	d1,pcmOnFlags
00006840 13C1 00FF 0011             	move.b	d1,PCMONOFF
00006846                            
00006846 08A8 0002 0001             	bclr	#PCMFSMPSTRM,pcmFlags(a0)		; Stop streaming sample data
0000684C 4E75                       	rts
0000684E                            
0000684E                            ; ---------------------------------------------------------------------------
0000684E                            ; Update channel portamento
0000684E                            ; ---------------------------------------------------------------------------
0000684E                            ; PARAMETERS:
0000684E                            ;	a0.l - PCM channel data structure
0000684E                            ; ---------------------------------------------------------------------------
0000684E                            
0000684E                            UpdatePCMPorta:
0000684E 0828 0005 0001             	btst	#PCMFPORTA,pcmFlags(a0)			; Is portamento active?
00006854 6700                       	beq.s	.End					; If not, branch
00006856                            	
00006856 2028 000C                  	move.l	pcmFreq(a0),d0				; Get current frequency
0000685A 2228 001A                  	move.l	pcmPortaFreq(a0),d1			; Get distance from target frequency
0000685E                            	sub.l	d0,d1
0000685E                          M 	local	num
0000685E 9280                     M 	sxb.l	d0,d1
00006860 6700                       	beq.s	.End					; If we are at the target frequency, branch
00006862 6A00                       	bpl.s	.AddAccum				; If it's positive, branch
00006864                            
00006864                            .SubAccum:
00006864                            	sub.l	pcmPortaAccum(a0),d0			; Subtract accumulator
00006864                          M 	local	num
00006864 90A8 0016                M 	sxb.l	pcmportaaccum(a0),d0
00006868 B0A8 001A                  	cmp.l	pcmPortaFreq(a0),d0			; Has it reached the target frequency?
0000686C 6E00                       	bgt.s	.UpdateFreq				; If not, branch
0000686E 6000                       	bra.s	.CapFreq				; If so, cap it
00006870                            
00006870                            .AddAccum:
00006870                            	add.l	pcmPortaAccum(a0),d0			; Add accumulator
00006870                          M 	local	num
00006870 D0A8 0016                M 	axd.l	pcmportaaccum(a0),d0
00006874 B0A8 001A                  	cmp.l	pcmPortaFreq(a0),d0			; Has it reached the target frequency?
00006878 6D00                       	blt.s	.UpdateFreq				; If not, branch
0000687A                            	
0000687A                            .CapFreq:
0000687A 2028 001A                  	move.l	pcmPortaFreq(a0),d0			; Cap at target frequency
0000687E                            
0000687E                            .UpdateFreq:
0000687E 2140 000C                  	move.l	d0,pcmFreq(a0)				; Update frequency
00006882                            
00006882                            .End:
00006882 4E75                       	rts
00006884                            
00006884                            ; ---------------------------------------------------------------------------
00006884                            ; Update channel ADSR envelope
00006884                            ; ---------------------------------------------------------------------------
00006884                            ; PARAMETERS:
00006884                            ;	a0.l - PCM channel data structure
00006884                            ; ---------------------------------------------------------------------------
00006884                            
00006884                            UpdatePCMADSREnv:
00006884 7000                       	moveq	#0,d0					; Go to envelope mode
00006886 1028 0021                  	move.b	pcmEnvMode(a0),d0
0000688A 4EFB 0000                  	jmp	.Modes(pc,d0.w)
0000688E                            	
0000688E                            ; ---------------------------------------------------------------------------
0000688E                            
0000688E                            .Modes:
0000688E 6000                       	bra.s	PCMEnv_Attack				; Attack
00006890 6000                       	bra.s	PCMEnv_Decay				; Decay
00006892 6000                       	bra.s	PCMEnv_Sustain				; Sustain
00006894 4E75                       	rts						; Sustain done
00006896 6000                       	bra.s	PCMEnv_Release				; Release
00006898 4E75                       	rts						; Release done
0000689A                            
0000689A                            ; ---------------------------------------------------------------------------
0000689A                            ; Attack mode
0000689A                            ; ---------------------------------------------------------------------------
0000689A                            
0000689A                            PCMEnv_Attack:
0000689A 1028 0023                  	move.b	pcmAttackRate(a0),d0			; Add attack rate
0000689E 1228 0022                  	move.b	pcmEnvVolume(a0),d1
000068A2                            	add.b	d0,d1
000068A2                          M 	local	num
000068A2 D200                     M 	axd.b	d0,d1
000068A4 6500                       	bcs.s	.ModeDone				; If it has overflowed, branch
000068A6 0C01 00FF                  	cmpi.b	#$FF,d1					; Is the envelope volume at max level?
000068AA 6600                       	bne.s	.SetEnvVol				; If not, branch
000068AC                            
000068AC                            .ModeDone:
000068AC                            	addq.b	#2,pcmEnvMode(a0)			; Set to decay mode
000068AC 5428 0021                M 	axdq.b	#2,pcmenvmode(a0)
000068B0 123C 00FF                  	move.b	#$FF,d1					; Cap at max level
000068B4                            
000068B4                            .SetEnvVol:
000068B4 1141 0022                  	move.b	d1,pcmEnvVolume(a0)			; Update volume envelope
000068B8 4E75                       	rts
000068BA                            
000068BA                            ; ---------------------------------------------------------------------------
000068BA                            ; Decay mode
000068BA                            ; ---------------------------------------------------------------------------
000068BA                            
000068BA                            PCMEnv_Decay:
000068BA 1028 0024                  	move.b	pcmDecayRate(a0),d0			; Subtract decay rate
000068BE 1228 0022                  	move.b	pcmEnvVolume(a0),d1
000068C2                            	sub.b	d0,d1
000068C2                          M 	local	num
000068C2 9200                     M 	sxb.b	d0,d1
000068C4 6500                       	bcs.s	.ModeDone				; If it has overflowed, branch
000068C6 B228 0025                  	cmp.b	pcmSustainLvl(a0),d1			; Is the envelope volume at the sustain level?
000068CA 6200                       	bhi.s	.SetEnvVol				; If not, branch
000068CC                            
000068CC                            .ModeDone:
000068CC                            	addq.b	#2,pcmEnvMode(a0)			; Set to sustain mode
000068CC 5428 0021                M 	axdq.b	#2,pcmenvmode(a0)
000068D0 1228 0025                  	move.b	pcmSustainLvl(a0),d1			; Cap at sustain level
000068D4 6600                       	bne.s	.SetEnvVol				; If it isn't at min level, branch
000068D6                            	addq.b	#2,pcmEnvMode(a0)			; Set to done mode
000068D6 5428 0021                M 	axdq.b	#2,pcmenvmode(a0)
000068DA                            
000068DA                            .SetEnvVol:
000068DA 1141 0022                  	move.b	d1,pcmEnvVolume(a0)			; Update volume envelope
000068DE 4E75                       	rts
000068E0                            
000068E0                            ; ---------------------------------------------------------------------------
000068E0                            ; Sustain/release mode
000068E0                            ; ---------------------------------------------------------------------------
000068E0                            
000068E0                            PCMEnv_Sustain:
000068E0 1028 0026                  	move.b	pcmSustainRate(a0),d0			; Use sustain rate
000068E4 6000                       	bra.s	PCMEnv_SustainRel
000068E6                            
000068E6                            ; ---------------------------------------------------------------------------
000068E6                            
000068E6                            PCMEnv_Release:
000068E6 1028 0027                  	move.b	pcmReleaseRate(a0),d0			; Use release rate
000068EA                            
000068EA                            ; ---------------------------------------------------------------------------
000068EA                            
000068EA                            PCMEnv_SustainRel:
000068EA 1228 0022                  	move.b	pcmEnvVolume(a0),d1			; Subtract rate
000068EE                            	sub.b	d0,d1
000068EE                          M 	local	num
000068EE 9200                     M 	sxb.b	d0,d1
000068F0 6500                       	bcs.s	.ModeDone				; If it has overflowed, branch
000068F2 6600                       	bne.s	.SetEnvVol				; If it hasn't gone to min level, branch
000068F4                            
000068F4                            .ModeDone:
000068F4                            	addq.b	#2,pcmEnvMode(a0)			; Set to done mode
000068F4 5428 0021                M 	axdq.b	#2,pcmenvmode(a0)
000068F8 6100 FF38                  	bsr.w	KeyOffPCM				; Key off
000068FC 7200                       	moveq	#0,d1					; Cap at min level
000068FE                            
000068FE                            .SetEnvVol:
000068FE 1141 0022                  	move.b	d1,pcmEnvVolume(a0)			; Update volume envelope
00006902 4E75                       	rts
00006904                            
00006904                            ; ---------------------------------------------------------------------------
00006904                            ; Command table
00006904                            ; ---------------------------------------------------------------------------
00006904                            
00006904                            PCMCommands:
00006904 6000 0000                  	bra.w	PCMCmd_Jump				; Jump
00006908 6000 0000                  	bra.w	PCMCmd_Legato				; Legato
0000690C 6000 0000                  	bra.w	PCMCmd_Instrument			; Instrument
00006910                            
00006910                            ; ---------------------------------------------------------------------------
00006910                            ; Jump
00006910                            ; ---------------------------------------------------------------------------
00006910                            
00006910                            PCMCmd_Jump:
00006910 1F19                       	move.b	(a1)+,-(sp)				; Jump
00006912 301F                       	move.w	(sp)+,d0
00006914 1019                       	move.b	(a1)+,d0
00006916                            	adda.w	d0,a1
00006916 D2C0                     M 	axda.w	d0,a1
00006918 4E75                       	rts
0000691A                            
0000691A                            ; ---------------------------------------------------------------------------
0000691A                            ; Set legato
0000691A                            ; ---------------------------------------------------------------------------
0000691A                            
0000691A                            PCMCmd_Legato:
0000691A 08E8 0004 0001             	bset	#PCMFLEGATO,pcmFlags(a0)		; Set legato flag
00006920 4E75                       	rts
00006922                            
00006922                            ; ---------------------------------------------------------------------------
00006922                            ; Set instrument
00006922                            ; ---------------------------------------------------------------------------
00006922                            
00006922                            PCMCmd_Instrument:
00006922 1019                       	move.b	(a1)+,d0				; Get instrument ID
00006924 B028 0020                  	cmp.b	pcmIns(a0),d0				; Is it different from the current one?
00006928 6700                       	beq.s	.End					; If so, branch
0000692A                            
0000692A 1140 0020                  	move.b	d0,pcmIns(a0)				; Set new instrument ID
0000692E 6000 FF02                  	bra.w	KeyOffPCM				; Key off
00006932                            
00006932                            .End:
00006932 4E75                       	rts
00006934                            
00006934                            ; ---------------------------------------------------------------------------
00006934                            ; Frequency table
00006934                            ; ---------------------------------------------------------------------------
00006934                            
00006934                            	;	A      A#/Bb  B      C      C#/Db  D      D#/Eb  E      F      F#/Gb  G      G#/Ab
00006934 0010 0011 0012 0013 0014+  	dc.w	$0010, $0011, $0012, $0013, $0014, $0015, $0017, $0018, $0019, $001B, $001D, $001E
0000694C 0020 0022 0024 0026 0028+  	dc.w	$0020, $0022, $0024, $0026, $0028, $002B, $002D, $0030, $0033, $0036, $0039, $003C
00006964                            
00006964                            PCMFrequencies:
00006964 0040 0044 0048 004C 0051+  	dc.w	$0040, $0044, $0048, $004C, $0051, $0055, $005B, $0060, $0066, $006C, $0072, $0079
0000697C 0080 0088 0090 0098 00A1+  	dc.w	$0080, $0088, $0090, $0098, $00A1, $00AB, $00B5, $00C0, $00CB, $00D7, $00E4, $00F2
00006994 0100 010F 011F 0130 0143+  	dc.w	$0100, $010F, $011F, $0130, $0143, $0156, $016A, $0180, $0196, $01AF, $01C8, $01E3
000069AC 0200 021E 023F 0261 0285+  	dc.w	$0200, $021E, $023F, $0261, $0285, $02AB, $02D4, $02FF, $032D, $035D, $0390, $03C7
000069C4 0400 043D 047D 04C2 050A+  	dc.w	$0400, $043D, $047D, $04C2, $050A, $0557, $05A8, $05FE, $0659, $06BA, $0721, $078D
000069DC 0800 087A 08FB 0983 0A14+  	dc.w	$0800, $087A, $08FB, $0983, $0A14, $0AAE, $0B50, $0BFD, $0CB3, $0D74, $0E41, $0F1A
000069F4 1000 10F4 11F6 1307 1429+  	dc.w	$1000, $10F4, $11F6, $1307, $1429, $155C, $16A1, $17F9, $1966, $1AE9, $1C82, $1E34
00006A0C 2000 21E7 23EB 260E 2851+  	dc.w	$2000, $21E7, $23EB, $260E, $2851, $2AB7, $2D41, $2FF2, $32CC, $35D1, $3904, $3C68
00006A24                            
00006A24 4000 43CE 47D6 4C1C 50A3+  	dc.w	$4000, $43CE, $47D6, $4C1C, $50A3, $556E, $5A82, $5FE4, $6598, $6BA2, $7209, $78D1
00006A3C 8000 879C 8FAD 9838 A145+  	dc.w	$8000, $879C, $8FAD, $9838, $A145, $AADC, $B505, $BFC9, $CB30, $D745, $E412, $F1A2
00006A54                            
00006A54                            ; ---------------------------------------------------------------------------
00006A54                            ; Update PCM samples
00006A54                            ; ---------------------------------------------------------------------------
00006A54                            
00006A54                            UpdatePCMData:
00006A54 41FA 0000                  	lea	pcm_channel_1(pc),a0			; Channel 1
00006A58 6100                       	bsr.s	UpdatePCMChnData
00006A5A 41FA 0000                  	lea	pcm_channel_2(pc),a0			; Channel 2
00006A5E 6100                       	bsr.s	UpdatePCMChnData
00006A60 41FA 0000                  	lea	pcm_channel_3(pc),a0			; Channel 3
00006A64 6100                       	bsr.s	UpdatePCMChnData
00006A66 41FA 0000                  	lea	pcm_channel_4(pc),a0			; Channel 4
00006A6A 6100                       	bsr.s	UpdatePCMChnData
00006A6C 41FA 0000                  	lea	pcm_channel_5(pc),a0			; Channel 5
00006A70 6100                       	bsr.s	UpdatePCMChnData
00006A72 41FA 0000                  	lea	pcm_channel_6(pc),a0			; Channel 6
00006A76 6100                       	bsr.s	UpdatePCMChnData
00006A78 41FA 0000                  	lea	pcm_channel_7(pc),a0			; Channel 7
00006A7C 6100                       	bsr.s	UpdatePCMChnData
00006A7E 41FA 0000                  	lea	pcm_channel_8(pc),a0			; Channel 8
00006A82                            
00006A82                            ; ---------------------------------------------------------------------------
00006A82                            ; Update PCM channel data
00006A82                            ; ---------------------------------------------------------------------------
00006A82                            ; PARAMETERS:
00006A82                            ;	a0.l - PCM channel data structure
00006A82                            ; ---------------------------------------------------------------------------
00006A82                            
00006A82                            UpdatePCMChnData:
00006A82 4A28 0001                  	tst.b	pcmFlags(a0)				; Is this channel playing?
00006A86 6A00 0000                  	bpl.w	.End					; If not, branch
00006A8A                            
00006A8A 1010                       	move.b	pcmChnID(a0),d0				; Control channel
00006A8C                            	ori.b	#$C0,d0
00006A8C 0000 00C0                M 	oxi.b	#$c0,d0
00006A90                            	PCMREG	d0,PCMCTRL,1,d0
00006A90 13C0 00FF 000F           M 	move.b	d0,pcmctrl
00006A96 7027                     M 	moveq	#$28-1,d0
00006A98 51C8 FFFE                M 	dbf	d0,*
00006A9C                            
00006A9C 7000                       	moveq	#0,d0					; Get channel volume
00006A9E 1028 001E                  	move.b	pcmVolume(a0),d0
00006AA2                            
00006AA2 7200                       	moveq	#0,d1					; Multiply envelope volume level
00006AA4 1228 0022                  	move.b	pcmEnvVolume(a0),d1
00006AA8                            	addq.w	#1,d1
00006AA8 5241                     M 	axdq.w	#1,d1
00006AAA C0C1                       	mulu.w	d1,d0
00006AAC 3F00                       	move.w	d0,-(sp)
00006AAE                            
00006AAE                            	PCMREG	(sp)+,PCMENV,1,d0			; Set volume
00006AAE 13DF 00FF 0001           M 	move.b	(sp)+,pcmenv
00006AB4 7027                     M 	moveq	#$28-1,d0
00006AB6 51C8 FFFE                M 	dbf	d0,*
00006ABA                            	PCMREG	pcmPanning(a0),PCMPAN,1,d0		; Set panning
00006ABA 13E8 001F 00FF 0003      M 	move.b	pcmpanning(a0),pcmpan
00006AC2 7027                     M 	moveq	#$28-1,d0
00006AC4 51C8 FFFE                M 	dbf	d0,*
00006AC8                            	
00006AC8 2028 000C                  	move.l	pcmFreq(a0),d0				; Get calculated frequency
00006ACC                            	add.l	pcmSampleDetune(a0),d0
00006ACC                          M 	local	num
00006ACC D0A8 003C                M 	axd.l	pcmsampledetune(a0),d0
00006AD0                            	add.l	pcmDetune(a0),d0
00006AD0                          M 	local	num
00006AD0 D0A8 0010                M 	axd.l	pcmdetune(a0),d0
00006AD4                            	
00006AD4 43FA FE8E                  	lea	PCMFrequencies(pc),a1			; Get raw base frequency
00006AD8 4840                       	swap	d0
00006ADA                            	add.w	d0,d0
00006ADA                          M 	local	num
00006ADA D040                     M 	axd.w	d0,d0
00006ADC 43F1 0000                  	lea	(a1,d0.w),a1
00006AE0 3219                       	move.w	(a1)+,d1
00006AE2 4840                       	swap	d0
00006AE4                            	
00006AE4 3411                       	move.w	(a1),d2					; Get raw detune
00006AE6                            	sub.w	d1,d2
00006AE6                          M 	local	num
00006AE6 9441                     M 	sxb.w	d1,d2
00006AE8 C0C2                       	mulu.w	d2,d0
00006AEA 4840                       	swap	d0
00006AEC                            	
00006AEC                            	add.w	d0,d1					; Set frequency
00006AEC                          M 	local	num
00006AEC D240                     M 	axd.w	d0,d1
00006AEE 3F01                       	move.w	d1,-(sp)
00006AF0                            	PCMREG	d1,PCMFDL,1,d0
00006AF0 13C1 00FF 0005           M 	move.b	d1,pcmfdl
00006AF6 7027                     M 	moveq	#$28-1,d0
00006AF8 51C8 FFFE                M 	dbf	d0,*
00006AFC                            	PCMREG	(sp)+,PCMFDH,1,d0
00006AFC 13DF 00FF 0007           M 	move.b	(sp)+,pcmfdh
00006B02 7027                     M 	moveq	#$28-1,d0
00006B04 51C8 FFFE                M 	dbf	d0,*
00006B08                            
00006B08                            ; ---------------------------------------------------------------------------
00006B08                            
00006B08                            .UpdateSample:
00006B08 0828 0001 0001             	btst	#PCMFSMPSET,pcmFlags(a0)		; Has the sample already been set up?
00006B0E 6600 0000                  	bne.w	.StreamSample				; If so, branch
00006B12                            
00006B12 2168 002C 0028             	move.l	pcmSampleStart(a0),pcmSamplePos(a0)	; Set sample position
00006B18 6700 0000                  	beq.w	.End					; If there's no sample to stream, branch
00006B1C                            
00006B1C 2028 0034                  	move.l	pcmSampleSize(a0),d0			; Get sample size
00006B20 6700 0000                  	beq.w	.End					; If there's no stample to stream, branch
00006B24 0C80 0000 2000             	cmpi.l	#PCMBANKSZ*2,d0				; Is the sample small enough to be statically stored?
00006B2A 6400 0000                  	bcc.w	.InitStream				; If not, branch
00006B2E                            	
00006B2E                            ; ---------------------------------------------------------------------------
00006B2E                            
00006B2E                            .InitStaticSample:
00006B2E                            	ori.b	#(1<<PCMFSMPSET),pcmFlags(a0)		; Set sample setup flag
00006B2E 0028 0002 0001           M 	oxi.b	#(1<<pcmfsmpset),pcmflags(a0)
00006B34                            
00006B34 1210                       	move.b	pcmChnID(a0),d1				; Set up wave RAM start address
00006B36 E619                       	ror.b	#3,d1
00006B38                            	PCMREG	d1,PCMST,1,d2
00006B38 13C1 00FF 000D           M 	move.b	d1,pcmst
00006B3E 7427                     M 	moveq	#$28-1,d2
00006B40 51CA FFFE                M 	dbf	d2,*
00006B44                            
00006B44 E149                       	lsl.w	#8,d1					; Set up wave RAM loop address
00006B46                            	add.w	pcmSampleLoop+2(a0),d1
00006B46                          M 	local	num
00006B46 D268 0032                M 	axd.w	pcmsampleloop+2(a0),d1
00006B4A                            	PCMREG	d1,PCMLSL,1,d2
00006B4A 13C1 00FF 0009           M 	move.b	d1,pcmlsl
00006B50 7427                     M 	moveq	#$28-1,d2
00006B52 51CA FFFE                M 	dbf	d2,*
00006B56 E049                       	lsr.w	#8,d1
00006B58                            	PCMREG	d1,PCMLSH,1,d2
00006B58 13C1 00FF 000B           M 	move.b	d1,pcmlsh
00006B5E 7427                     M 	moveq	#$28-1,d2
00006B60 51CA FFFE                M 	dbf	d2,*
00006B64                            
00006B64 1210                       	move.b	pcmChnID(a0),d1				; Set up first wave bank
00006B66                            	add.b	d1,d1
00006B66                          M 	local	num
00006B66 D201                     M 	axd.b	d1,d1
00006B68 4AC1                       	tas.b	d1
00006B6A 13C1 00FF 000F             	move.b	d1,PCMCTRL
00006B70                            
00006B70 2268 002C                  	movea.l	pcmSampleStart(a0),a1			; Get pointer to sample
00006B74 45F9 00FF 2001             	lea	PCMDATA,a2				; Wave RAM
00006B7A                            
00006B7A 3400                       	move.w	d0,d2					; Get size of sample
00006B7C 0C42 1000                  	cmpi.w	#PCMBANKSZ,d2				; Is it larger than a wave bank?
00006B80 6500                       	bcs.s	.CopyToBank1				; If not, branch
00006B82 343C 1000                  	move.w	#PCMBANKSZ,d2				; Cap at wave bank size
00006B86                            
00006B86                            .CopyToBank1:
00006B86                            	subq.w	#1,d2					; Subtract 1 for DBF
00006B86 5342                     M 	sxbq.w	#1,d2
00006B88                            
00006B88                            .CopyToBank1Loop:
00006B88 14D9                       	move.b	(a1)+,(a2)+				; Copy first set of sample data
00006B8A                            	addq.w	#1,a2
00006B8A 524A                     M 	axdq.w	#1,a2
00006B8C 51CA FFFA                  	dbf	d2,.CopyToBank1Loop
00006B90                            
00006B90                            	addq.b	#1,d1					; Set up second wave bank
00006B90 5201                     M 	axdq.b	#1,d1
00006B92 13C1 00FF 000F             	move.b	d1,PCMCTRL
00006B98                            
00006B98 3200                       	move.w	d0,d1					; Get remaining number of bytes to copy
00006B9A                            	subi.w	#PCMBANKSZ,d1
00006B9A 0441 1000                M 	sxbi.w	#pcmbanksz,d1
00006B9E                            	subq.w	#1,d1					; Subtract 1 for DBF
00006B9E 5341                     M 	sxbq.w	#1,d1
00006BA0 6B00                       	bmi.s	.NoBank2				; If there are none, branch
00006BA2                            	
00006BA2 45F9 00FF 2001             	lea	PCMDATA,a2				; Wave RAM
00006BA8                            
00006BA8                            .CopyToBank2:
00006BA8 14D9                       	move.b	(a1)+,(a2)+				; Copy second set of sample data
00006BAA                            	addq.w	#1,a2
00006BAA 524A                     M 	axdq.w	#1,a2
00006BAC 51C9 FFFA                  	dbf	d1,.CopyToBank2
00006BB0                            	
00006BB0                            .NoBank2:
00006BB0 4E75                       	rts
00006BB2                            
00006BB2                            ; ---------------------------------------------------------------------------
00006BB2                            
00006BB2                            .InitStream:
00006BB2 2140 0038                  	move.l	d0,pcmSamplesLeft(a0)			; Set number of samples left to stream
00006BB6                            							; Set wave bank ID, sample setup flag, and stream flag
00006BB6                            	ori.b	#(1<<PCMFSMPBANK)|(1<<PCMFSMPSET)|(1<<PCMFSMPSTRM),pcmFlags(a0)
00006BB6 0028 0007 0001           M 	oxi.b	#(1<<pcmfsmpbank)|(1<<pcmfsmpset)|(1<<pcmfsmpstrm),pcmflags(a0)
00006BBC 217C 00FF 2001 0040        	move.l	#PCMDATA,pcmStreamBuf(a0)		; Set buffer address
00006BC4                            
00006BC4 1010                       	move.b	pcmChnID(a0),d0				; Set initial wave RAM address
00006BC6 EB08                       	lsl.b	#5,d0
00006BC8 1140 0044                  	move.b	d0,pcmLastAddr(a0)
00006BCC 4228 0045                  	clr.b	pcmLastAddr+1(a0)
00006BD0                            
00006BD0                            	PCMREG	#0,PCMLSL,1,d1				; Set up wave RAM loop address
00006BD0 13FC 0000 00FF 0009      M 	move.b	#0,pcmlsl
00006BD8 7227                     M 	moveq	#$28-1,d1
00006BDA 51C9 FFFE                M 	dbf	d1,*
00006BDE                            	PCMREG	d0,PCMLSH,1,d1
00006BDE 13C0 00FF 000B           M 	move.b	d0,pcmlsh
00006BE4 7227                     M 	moveq	#$28-1,d1
00006BE6 51C9 FFFE                M 	dbf	d1,*
00006BEA                            	PCMREG	d0,PCMST,1,d1				; Set up wave RAM start address
00006BEA 13C0 00FF 000D           M 	move.b	d0,pcmst
00006BF0 7227                     M 	moveq	#$28-1,d1
00006BF2 51C9 FFFE                M 	dbf	d1,*
00006BF6                            
00006BF6 1010                       	move.b	pcmChnID(a0),d0				; Stream initial sample data
00006BF8                            	add.b	d0,d0
00006BF8                          M 	local	num
00006BF8 D000                     M 	axd.b	d0,d0
00006BFA 4AC0                       	tas.b	d0
00006BFC 13C0 00FF 000F             	move.b	d0,PCMCTRL
00006C02 3F00                       	move.w	d0,-(sp)
00006C04 303C 1000                  	move.w	#PCMBANKSZ,d0
00006C08 3140 0046                  	move.w	d0,pcmBytesLeft(a0)
00006C0C 6100 0000                  	bsr.w	StreamPCMData
00006C10                            	
00006C10 317C 0FE0 0046             	move.w	#PCMBANKSZ-PCMLOOPCNT,pcmBytesLeft(a0)	; Size of second wave bank
00006C16                            
00006C16 301F                       	move.w	(sp)+,d0				; Set up loop flags in second wave bank			
00006C18                            	addq.b	#1,d0
00006C18 5200                     M 	axdq.b	#1,d0
00006C1A 13C0 00FF 000F             	move.b	d0,PCMCTRL
00006C20                            
00006C20 43F9 00FF 3FC1             	lea	PCMDATA+((PCMBANKSZ-PCMLOOPCNT)*2),a1
00006C26 323C 001F                  	move.w	#PCMLOOPCNT-1,d1
00006C2A                            
00006C2A                            .SetupLoopFlags:
00006C2A 12FC 00FF                  	move.b	#$FF,(a1)+
00006C2E                            	addq.w	#1,a1
00006C2E 5249                     M 	axdq.w	#1,a1
00006C30 51C9 FFF8                  	dbf	d1,.SetupLoopFlags
00006C34                            
00006C34 4E75                       	rts
00006C36                            
00006C36                            ; ---------------------------------------------------------------------------
00006C36                            
00006C36                            .StreamSample:
00006C36 0828 0002 0001             	btst	#PCMFSMPSTRM,pcmFlags(a0)		; Are we streaming a sample?
00006C3C 6700 0000                  	beq.w	.End					; If not, branch
00006C40 4AA8 0028                  	tst.l	pcmSamplePos(a0)			; Is there a sample playing?
00006C44 6700 0000                  	beq.w	.End					; If not, branch
00006C48                            
00006C48 43F9 00FF 0021             	lea	PCMADDR,a1				; Get current playback address
00006C4E 7000                       	moveq	#0,d0
00006C50 1010                       	move.b	pcmChnID(a0),d0
00006C52                            	add.b	d0,d0
00006C52                          M 	local	num
00006C52 D000                     M 	axd.b	d0,d0
00006C54                            	add.b	d0,d0
00006C54                          M 	local	num
00006C54 D000                     M 	axd.b	d0,d0
00006C56 1231 0002                  	move.b	2(a1,d0.w),d1
00006C5A 1F01                       	move.b	d1,-(sp)
00006C5C 341F                       	move.w	(sp)+,d2
00006C5E 1431 0000                  	move.b	(a1,d0.w),d2
00006C62                            	
00006C62 3028 0044                  	move.w	pcmLastAddr(a0),d0			; Get number of bytes played back since last time
00006C66 3142 0044                  	move.w	d2,pcmLastAddr(a0)
00006C6A                            
00006C6A 1628 0001                  	move.b	pcmFlags(a0),d3				; Have we swapped wave banks?
00006C6E E809                       	lsr.b	#4,d1
00006C70                            	andi.b	#1,d1
00006C70 0201 0001                M 	anxi.b	#1,d1
00006C74                            	andi.b	#1<<PCMFSMPBANK,d3
00006C74 0203 0001                M 	anxi.b	#1<<pcmfsmpbank,d3
00006C78 B701                       	eor.b	d3,d1
00006C7A 6700                       	beq.s	.End					; If not, branch
00006C7C                            
00006C7C 1210                       	move.b	pcmChnID(a0),d1				; Set up wave bank to stream to
00006C7E                            	add.b	d1,d1
00006C7E                          M 	local	num
00006C7E D201                     M 	axd.b	d1,d1
00006C80                            	add.b	d3,d1
00006C80                          M 	local	num
00006C80 D203                     M 	axd.b	d3,d1
00006C82 4AC1                       	tas.b	d1
00006C84 13C1 00FF 000F             	move.b	d1,PCMCTRL
00006C8A                            
00006C8A B440                       	cmp.w	d0,d2					; Has the playback wrapped to the top of the wave banks?
00006C8C 6400                       	bcc.s	.NoWrap					; If not, branch
00006C8E                            	andi.w	#$1FFF,d0				; Copy count = ($2000 - (last addr & $1FFF))+ new addr
00006C8E 0240 1FFF                M 	anxi.w	#$1fff,d0
00006C92                            	subi.w	#$2000,d0
00006C92 0440 2000                M 	sxbi.w	#$2000,d0
00006C96 4440                       	neg.w	d0
00006C98                            	add.w	d2,d0
00006C98                          M 	local	num
00006C98 D042                     M 	axd.w	d2,d0
00006C9A 6000                       	bra.s	.CopyData
00006C9C                            
00006C9C                            .NoWrap:
00006C9C                            	sub.w	d2,d0					; Copy count = new addr - last addr
00006C9C                          M 	local	num
00006C9C 9042                     M 	sxb.w	d2,d0
00006C9E 4440                       	neg.w	d0
00006CA0                            
00006CA0                            .CopyData:
00006CA0                            	add.w	d0,d0					; Multiply count to stay ahead
00006CA0                          M 	local	num
00006CA0 D040                     M 	axd.w	d0,d0
00006CA2                            	add.w	d0,d0
00006CA2                          M 	local	num
00006CA2 D040                     M 	axd.w	d0,d0
00006CA4 6100 0000                  	bsr.w	StreamPCMData				; Stream sample data
00006CA8                            
00006CA8 4A68 0046                  	tst.w	pcmBytesLeft(a0)			; Has the bank been filled?
00006CAC 6600                       	bne.s	.BlockDone				; If not, branch
00006CAE                            
00006CAE 45F9 00FF 2001             	lea	PCMDATA,a2				; Reset buffer address
00006CB4 323C 1000                  	move.w	#PCMBANKSZ,d1				; Size of wave bank
00006CB8 0868 0000 0001             	bchg	#PCMFSMPBANK,pcmFlags(a0)		; Swap wave banks
00006CBE 6600                       	bne.s	.BankDone				; If we're gonna stream to the first bank, branch
00006CC0                            	subi.w	#PCMLOOPCNT,d1				; Offset loop flag count for second bank
00006CC0 0441 0020                M 	sxbi.w	#pcmloopcnt,d1
00006CC4                            
00006CC4                            .BankDone:
00006CC4 3141 0046                  	move.w	d1,pcmBytesLeft(a0)			; Update bytes left in bank
00006CC8                            
00006CC8                            .BlockDone:
00006CC8 214A 0040                  	move.l	a2,pcmStreamBuf(a0)			; Update buffer address
00006CCC                            
00006CCC                            .End:
00006CCC 4E75                       	rts
00006CCE                            
00006CCE                            ; ---------------------------------------------------------------------------
00006CCE                            ; Stream sample data
00006CCE                            ; ---------------------------------------------------------------------------
00006CCE                            ; PARAMETERS:
00006CCE                            ;	d0.w - Number of samples to copy
00006CCE                            ;	a0.l - PCM channel data structure
00006CCE                            ; RETURNS:
00006CCE                            ;	a2.l - Next buffer address
00006CCE                            ; ---------------------------------------------------------------------------
00006CCE                            
00006CCE                            StreamPCMData:
00006CCE                            	andi.l	#$FFFF,d0				; Get total number of samples to copy
00006CCE 0280 0000 FFFF           M 	anxi.l	#$ffff,d0
00006CD4 2200                       	move.l	d0,d1
00006CD6 2468 0040                  	movea.l	pcmStreamBuf(a0),a2			; Get buffer address
00006CDA                            
00006CDA                            .StreamLoop:
00006CDA 7400                       	moveq	#0,d2					; Is there enough room in the bank to copy into?
00006CDC 3428 0046                  	move.w	pcmBytesLeft(a0),d2
00006CE0 B082                       	cmp.l	d2,d0
00006CE2 6300                       	bls.s	.ChkSamplesLeft				; If so, branch
00006CE4 2002                       	move.l	d2,d0					; If not, only stream what can be fit
00006CE6                            
00006CE6                            .ChkSamplesLeft:
00006CE6 B0A8 0038                  	cmp.l	pcmSamplesLeft(a0),d0			; Is there enough sample data to copy?
00006CEA 6300                       	bls.s	.CopySamples				; If so, branch
00006CEC 2028 0038                  	move.l	pcmSamplesLeft(a0),d0			; If not, only copy the samples that are left
00006CF0                            
00006CF0                            .CopySamples:
00006CF0                            	sub.l	d0,d1					; Get number of samples left in this packet to copy afterwards
00006CF0                          M 	local	num
00006CF0 9280                     M 	sxb.l	d0,d1
00006CF2                            	sub.l	d0,pcmSamplesLeft(a0)			; Get number of samples left in data to copy afterwards
00006CF2                          M 	local	num
00006CF2 91A8 0038                M 	sxb.l	d0,pcmsamplesleft(a0)
00006CF6                            	sub.w	d0,pcmBytesLeft(a0)			; Get number of bytes left in bank to copy to afterwards
00006CF6                          M 	local	num
00006CF6 9168 0046                M 	sxb.w	d0,pcmbytesleft(a0)
00006CFA                            	
00006CFA                            	subq.w	#1,d0					; Subtract 1 for DBF
00006CFA 5340                     M 	sxbq.w	#1,d0
00006CFC 6B00                       	bmi.s	.End					; If there are no samples to stream, branch
00006CFE                            
00006CFE 2268 0028                  	movea.l	pcmSamplePos(a0),a1			; Get current sample position
00006D02                            	
00006D02                            .CopySamplesLoop:
00006D02 14D9                       	move.b	(a1)+,(a2)+				; Copy sample data
00006D04                            	addq.w	#1,a2
00006D04 524A                     M 	axdq.w	#1,a2
00006D06 51C8 FFFA                  	dbf	d0,.CopySamplesLoop
00006D0A                            
00006D0A 4AA8 0038                  	tst.l	pcmSamplesLeft(a0)			; Are we at the end of the sample?
00006D0E 6600                       	bne.s	.CheckStreamDone			; If not, branch
00006D10                            
00006D10 2268 002C                  	movea.l	pcmSampleStart(a0),a1			; Get sample loop position
00006D14 2028 0030                  	move.l	pcmSampleLoop(a0),d0
00006D18 6B00 FB18                  	bmi.w	KeyOffPCM				; If the sample is done playing, branch
00006D1C                            	add.l	d0,a1
00006D1C                          M 	local	num
00006D1C D3C0                     M 	axd.l	d0,a1
00006D1E                            	
00006D1E                            	sub.l	pcmSampleSize(a0),d0			; Get length between loop and end positions
00006D1E                          M 	local	num
00006D1E 90A8 0034                M 	sxb.l	pcmsamplesize(a0),d0
00006D22 4480                       	neg.l	d0
00006D24 2140 0038                  	move.l	d0,pcmSamplesLeft(a0)
00006D28                            
00006D28                            .CheckStreamDone:
00006D28 2149 0028                  	move.l	a1,pcmSamplePos(a0)			; Update sample position
00006D2C                            
00006D2C 2001                       	move.l	d1,d0					; Get number of samples left to stream
00006D2E 66AA                       	bne.s	.StreamLoop				; If there are some, branch
00006D30                            
00006D30                            .End:
00006D30 4E75                       	rts
00006D32                            
00006D32                            ; ---------------------------------------------------------------------------
00006D32                            ; PCM data
00006D32                            ; ---------------------------------------------------------------------------
00006D32                            
00006D32 FF                         pcmOnFlags:	dc.b	$FF				; On/off flags
00006D34 00                         		even
00006D34                            
00006D34                            pcm_channel_1:	PCMCHNDAT 0				; PCM channel 1
00006D34                          M 	dcb.b	pcmchnid,0
00006D34 00                       M 	dc.b	0
00006D35 0000 0000 0000 0000 0000+M 	dcb.b	pcmchnsize-(pcmchnid+1),0
00006D7C                            pcm_channel_2:	PCMCHNDAT 1				; PCM channel 2
00006D7C                          M 	dcb.b	pcmchnid,0
00006D7C 01                       M 	dc.b	1
00006D7D 0000 0000 0000 0000 0000+M 	dcb.b	pcmchnsize-(pcmchnid+1),0
00006DC4                            pcm_channel_3:	PCMCHNDAT 2				; PCM channel 3
00006DC4                          M 	dcb.b	pcmchnid,0
00006DC4 02                       M 	dc.b	2
00006DC5 0000 0000 0000 0000 0000+M 	dcb.b	pcmchnsize-(pcmchnid+1),0
00006E0C                            pcm_channel_4:	PCMCHNDAT 3				; PCM channel 4
00006E0C                          M 	dcb.b	pcmchnid,0
00006E0C 03                       M 	dc.b	3
00006E0D 0000 0000 0000 0000 0000+M 	dcb.b	pcmchnsize-(pcmchnid+1),0
00006E54                            pcm_channel_5:	PCMCHNDAT 4				; PCM channel 5
00006E54                          M 	dcb.b	pcmchnid,0
00006E54 04                       M 	dc.b	4
00006E55 0000 0000 0000 0000 0000+M 	dcb.b	pcmchnsize-(pcmchnid+1),0
00006E9C                            pcm_channel_6:	PCMCHNDAT 5				; PCM channel 6
00006E9C                          M 	dcb.b	pcmchnid,0
00006E9C 05                       M 	dc.b	5
00006E9D 0000 0000 0000 0000 0000+M 	dcb.b	pcmchnsize-(pcmchnid+1),0
00006EE4                            pcm_channel_7:	PCMCHNDAT 6				; PCM channel 7
00006EE4                          M 	dcb.b	pcmchnid,0
00006EE4 06                       M 	dc.b	6
00006EE5 0000 0000 0000 0000 0000+M 	dcb.b	pcmchnsize-(pcmchnid+1),0
00006F2C                            pcm_channel_8:	PCMCHNDAT 7				; PCM channel 8
00006F2C                          M 	dcb.b	pcmchnid,0
00006F2C 07                       M 	dc.b	7
00006F2D 0000 0000 0000 0000 0000+M 	dcb.b	pcmchnsize-(pcmchnid+1),0
00006F74                            
00006F74                            ; ---------------------------------------------------------------------------
00006F74                            
00006F74                            TestTrack:
00006F74                            	PCMTRKSTART
00006F74 =00000000                M 	__pcm_track_id:	= __pcm_track_id+1
00006F74 =00006F74                M 	__pcm_origin_0:	equ *
00006F74                            	PCMINSTBL	TestTrack_Instruments
00006F74 0000                     M 	dc.w	(testtrack_instruments)-(__pcm_origin_0)
00006F76                            
00006F76                            	PCMCHNSTART
00006F76 =FFFFFFFF                M 	__pcm_chn_cnt:	= -1
00006F76 0000                     M 	dc.w	__pcm_chn_cnt_0
00006F78                            	PCMCHNPTR	TestTrack_PCM1, 0, $BF, $FF
00006F78 =00000000                M 	__pcm_chn_cnt:	= __pcm_chn_cnt+1
00006F78 0000                     M 	dc.w	(testtrack_pcm1)-(__pcm_origin_0)
00006F7A 00                       M 	dc.b	0
00006F7B BFFF 00                  M 	dc.b	$bf,$ff,0
00006F7E                            	PCMCHNPTR	TestTrack_PCM2, 1, $EF, $FF
00006F7E =00000001                M 	__pcm_chn_cnt:	= __pcm_chn_cnt+1
00006F7E 0000                     M 	dc.w	(testtrack_pcm2)-(__pcm_origin_0)
00006F80 01                       M 	dc.b	1
00006F81 EFFF 00                  M 	dc.b	$ef,$ff,0
00006F84                            	PCMCHNPTR	TestTrack_PCM3, 2, $DF, $0F
00006F84 =00000002                M 	__pcm_chn_cnt:	= __pcm_chn_cnt+1
00006F84 0000                     M 	dc.w	(testtrack_pcm3)-(__pcm_origin_0)
00006F86 02                       M 	dc.b	2
00006F87 DF0F 00                  M 	dc.b	$df,$0f,0
00006F8A                            	PCMCHNPTR	TestTrack_PCM4, 3, $FF, $F0
00006F8A =00000003                M 	__pcm_chn_cnt:	= __pcm_chn_cnt+1
00006F8A 0000                     M 	dc.w	(testtrack_pcm4)-(__pcm_origin_0)
00006F8C 03                       M 	dc.b	3
00006F8D FFF0 00                  M 	dc.b	$ff,$f0,0
00006F90                            	PCMCHNPTR	TestTrack_PCM5, 4, $6F, $FF
00006F90 =00000004                M 	__pcm_chn_cnt:	= __pcm_chn_cnt+1
00006F90 0000                     M 	dc.w	(testtrack_pcm5)-(__pcm_origin_0)
00006F92 04                       M 	dc.b	4
00006F93 6FFF 00                  M 	dc.b	$6f,$ff,0
00006F96                            	PCMCHNEND
00006F96 =00000004                M 	__pcm_chn_cnt_0:	equ __pcm_chn_cnt
00006F96                            
00006F96                            TestTrack_PCM1:
00006F96                            	PCMCINS		$00
00006F96 A400                     M 	dc.b	pcmcidins,$00
00006F98 660F                       	dc.b		NA3, $0F
00006F9A 720F                       	dc.b		NA4, $0F
00006F9C                            	PCMCJUMP	TestTrack_PCM1
00006F9C A2                       M 	dc.b	pcmcidjump
00006F9D FFF7                     M 	dc.w	(testtrack_pcm1)-(*+2)
00006F9F                            
00006F9F                            TestTrack_PCM2:
00006F9F                            	PCMCINS		$01
00006F9F A401                     M 	dc.b	pcmcidins,$01
00006FA1 7E3F                       	dc.b		NA5, $3F
00006FA3 A3                         	dc.b		PCMCLEGATO
00006FA4 7E3F                       	dc.b		NA5, $3F
00006FA6                            	PCMCJUMP	TestTrack_PCM2
00006FA6 A2                       M 	dc.b	pcmcidjump
00006FA7 FFF6                     M 	dc.w	(testtrack_pcm2)-(*+2)
00006FA9                            	
00006FA9                            TestTrack_PCM3:
00006FA9                            	PCMCINS		$02
00006FA9 A402                     M 	dc.b	pcmcidins,$02
00006FAB 721F                       	dc.b		NA4, $1F
00006FAD 401F                       	dc.b		NREST, $1F
00006FAF                            	PCMCJUMP	TestTrack_PCM3
00006FAF A2                       M 	dc.b	pcmcidjump
00006FB0 FFF7                     M 	dc.w	(testtrack_pcm3)-(*+2)
00006FB2                            	
00006FB2                            TestTrack_PCM4:
00006FB2                            	PCMCINS		$02
00006FB2 A402                     M 	dc.b	pcmcidins,$02
00006FB4 401F                       	dc.b		NREST, $1F
00006FB6 731F                       	dc.b		NAS4, $1F
00006FB8                            	PCMCJUMP	TestTrack_PCM4
00006FB8 A2                       M 	dc.b	pcmcidjump
00006FB9 FFF7                     M 	dc.w	(testtrack_pcm4)-(*+2)
00006FBB                            	
00006FBB                            TestTrack_PCM5:
00006FBB                            	PCMCINS		$02
00006FBB A402                     M 	dc.b	pcmcidins,$02
00006FBD 7407                       	dc.b		NB4, $07
00006FBF                            	PCMCJUMP	TestTrack_PCM5
00006FBF A2                       M 	dc.b	pcmcidjump
00006FC0 FFF9                     M 	dc.w	(testtrack_pcm5)-(*+2)
00006FC2                            
00006FC2                            	even
00006FC2                            
00006FC2                            TestTrack_Instruments:
00006FC2                            	PCMINSSTART
00006FC2 =00006FC2                M 	__pcm_instbl_0:	equ *
00006FC2                            	PCMINSPTR	.0
00006FC2 0000                     M 	dc.w	(.0)-(__pcm_instbl_0)
00006FC4                            	PCMINSPTR	.1
00006FC4 0000                     M 	dc.w	(.1)-(__pcm_instbl_0)
00006FC6                            	PCMINSPTR	.2
00006FC6 0000                     M 	dc.w	(.2)-(__pcm_instbl_0)
00006FC8                            
00006FC8                            .0:
00006FC8                            	PCMINSDAT	TestSample, &
00006FC8 0000 0000                M 	dc.l	testsample
00006FCC 0000 0000                M 	dc.l	testsample_end-testsample
00006FD0 0000 0000                M 	dc.l	testsample_end-testsample-$21
00006FD4 0000 0000                M 	dc.l	((na4-(na4))<<16)+(0)
00006FD8 FF01 E001 08             M 	dc.b	$ff,$01,$e0,$01,$08
00006FDD 005F                     M 	dc.b	(na0)-na0,(ngs8)-na0
00006FE0 00                       M 	even
00006FE0                            	PCMINSEND
00006FE0 FFFF                     M 	dc.w	-1
00006FE2                            
00006FE2                            .1:
00006FE2                            	PCMINSDAT	PadSample, &
00006FE2 0000 0000                M 	dc.l	padsample
00006FE6 0000 0000                M 	dc.l	padsample_end-padsample
00006FEA 0000 0000                M 	dc.l	0
00006FEE 0000 0000                M 	dc.l	((na4-(na4))<<16)+(0)
00006FF2 1002 0000 FF             M 	dc.b	$10,$02,$00,$00,$ff
00006FF7 005F                     M 	dc.b	(na0)-na0,(ngs8)-na0
00006FFA 00                       M 	even
00006FFA                            	PCMINSEND
00006FFA FFFF                     M 	dc.w	-1
00006FFC                            
00006FFC                            .2:
00006FFC                            	PCMINSDAT	KickSample, &
00006FFC 0000 0000                M 	dc.l	kicksample
00007000 0000 0000                M 	dc.l	kicksample_end-kicksample
00007004 0000 0000                M 	dc.l	kicksample_end-kicksample-$21
00007008 0000 0000                M 	dc.l	((na4-(na4))<<16)+(0)
0000700C FF00 0000 FF             M 	dc.b	$ff,$00,$00,$00,$ff
00007011 3030                     M 	dc.b	(na4)-na0,(na4)-na0
00007014 00                       M 	even
00007014                            	PCMINSDAT	SnareSample, &
00007014 0000 0000                M 	dc.l	snaresample
00007018 0000 0000                M 	dc.l	snaresample_end-snaresample
0000701C 0000 0000                M 	dc.l	snaresample_end-snaresample-$21
00007020 FFFF 0000                M 	dc.l	((na4-(nas4))<<16)+(0)
00007024 FF00 0000 FF             M 	dc.b	$ff,$00,$00,$00,$ff
00007029 3131                     M 	dc.b	(nas4)-na0,(nas4)-na0
0000702C 00                       M 	even
0000702C                            	PCMINSDAT	HatSample, &
0000702C 0000 0000                M 	dc.l	hatsample
00007030 0000 0000                M 	dc.l	hatsample_end-hatsample
00007034 0000 0000                M 	dc.l	hatsample_end-hatsample-$21
00007038 FFFE 0000                M 	dc.l	((na4-(nb4))<<16)+(0)
0000703C FF00 0000 FF             M 	dc.b	$ff,$00,$00,$00,$ff
00007041 3232                     M 	dc.b	(nb4)-na0,(nb4)-na0
00007044 00                       M 	even
00007044                            	PCMINSEND
00007044 FFFF                     M 	dc.w	-1
00007046                            
00007046                            ; ---------------------------------------------------------------------------
00007046                            
00007046                            TestSample:
00007046                            	incbin	"bass.pcm"
00007665                            TestSample_End:
00007666 00                         	even
00007666                            
00007666                            PadSample:
00007666                            	incbin	"pad.pcm"
0000D3D6                            PadSample_End:
0000D3D6                            	even
0000D3D6                            
0000D3D6                            KickSample:
0000D3D6                            	incbin	"kick.pcm"
0000DA9C                            KickSample_End:
0000DA9C                            	even
0000DA9C                            
0000DA9C                            SnareSample:
0000DA9C                            	incbin	"snare.pcm"
0000F4C9                            SnareSample_End:
0000F4CA 00                         	even
0000F4CA                            
0000F4CA                            HatSample:
0000F4CA                            	incbin	"hat.pcm"
0000FACA                            HatSample_End:
0000FACA                            	even
0000FACA                            
0000FACA                            ; ---------------------------------------------------------------------------
0000FACA                            
0000FACA                            ; ---------------------------------------------------------------------------
0000FACA                            ; Variables
0000FACA                            ; ---------------------------------------------------------------------------
0000FACA                            
0000FACA                            BIOSParams:
0000FACA 01FF 0000                  	dc.b	$01, $FF, $00, $00			; BIOS parameters
0000FACE 0000 0000                  	dc.b	$00, $00, $00, $00
0000FAD2                            
0000FAD2                            ; ---------------------------------------------------------------------------

00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Mega Drive Framework
00000000                            ; By Devon 2022
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Core source
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	include	"megadrive.i"
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Mega Drive Framework
00000000                            ; By Devon 2022
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Mega Drive definitions
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	include	"_config.i"
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Mode 1 Demo
00000000                            ; By Devon 2022
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Assembler options
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	opt	ae-					; Disable automatic evens
00000000                            	opt	m+					; Expand macros
00000000                            	opt	l.					; Local label character
00000000                            	opt	op+					; PC relative optimizations
00000000                            	opt	os+					; Short branch optimizations
00000000                            	opt	ow+					; Absolute word numessing optimizations
00000000                            	opt	oz+					; Zero offset optimizations
00000000                            	opt	oaq+					; ADDQ optimizations
00000000                            	opt	osq+					; SUBQ optimizations
00000000                            	opt	omq+					; MOVEQ optimizations
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Flags
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ; Debug flag
00000000 =00000001                  DEBUG		EQU	1
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; ROM information
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ; Copyright
00000000                            COPYRIGHT	EQUS	"DEVON"
00000000                            ; Game name
00000000                            GAME_NAME	EQUS	"MEGA CD MODE 1 DEMO BY DEVON"
00000000                            ; I/O support
00000000                            IO_SUPPORT	EQUS	"JC"
00000000                            ; Serial number
00000000                            SERIAL		EQUS	"00000000"
00000000                            ; Revision
00000000 =00000000                  REVISION	EQU	0
00000000                            ; Save RAM size
00000000 =00000000                  SRAM_SIZE	EQU	0
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            	include	"macros.i"
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Mega Drive Framework
00000000                            ; By Devon 2022
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; General macros
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Align to size boundary
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	bound - Size boundary
00000000                            ;	value - (OPTIONAL) Value to pad with
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ALIGN macro bound, value
00000000                            	local	pad
00000000                            	pad: = ((\bound)-((*)%(\bound)))%(\bound)
00000000                            	if narg>1
00000000                            		dcb.b	pad, \value
00000000                            	else
00000000                            		dcb.b	pad, 0
00000000                            	endif
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Align RS offset to be even
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            RSEVEN macro
00000000                            	rs.b	__rs&1
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Align RS offset to boundary
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            RSALIGN macro bound
00000000                            	rs.b	((\bound)-((__rs)%(\bound)))%(\bound)
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Generate repeated RS structure entries
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	name  - Entry name base
00000000                            ;	count - Number of entries
00000000                            ;	size  - Size of entry
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            RSRPT macro name, count, size
00000000                            	local	cnt
00000000                            	cnt: = 0
00000000                            	rept	\count
00000000                            		\name\\$Cnt:	rs.\0	\size
00000000                            		cnt: = cnt+1
00000000                            	endr
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Push RS value
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =00000000                  rsStack: = 0
00000000                            RSPUSH macro
00000000                            	rsStackVal\#rsStack\: =	__rs
00000000                            	rsStack: = rsStack+1
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Pop RS value
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            RSPOP macro
00000000                            	rsStack: = rsStack-1
00000000                            	rsset	rsStackVal\#rsStack
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Store string with fixed size
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	len - Length of string
00000000                            ;	str - String to store
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            STRSZ macro len, str
00000000                            	local	len2, str2
00000000                            	if strlen(\str)>(\len)
00000000                            		len2: =	\len
00000000                            		str2: SUBSTR 1,\len,\str
00000000                            	else
00000000                            		len2: =	strlen(\str)
00000000                            		str2: EQUS \str
00000000                            	endif
00000000                            	dc.b	"\str2"
00000000                            	dcb.b	(\len)-len2, " "
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Store number with fixed number of digits
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	digits - Number of digits
00000000                            ;	num    - Number to store
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            NUMSTR macro digits, num
00000000                            	local	num2, dig2, mask
00000000                            	num2: = \num
00000000                            	dig2: = 1
00000000                            	mask: = 10
00000000                            	while	(num2<>0)&(dig2<(\digits))
00000000                            		num2: = num2/10
00000000                            		mask: = mask*10
00000000                            		dig2: = dig2+1
00000000                            	endw
00000000                            		num2: = (\num)%mask
00000000                            	dcb.b	(\digits)-strlen("\#num2"), "0"
00000000                            	dc.b	"\#num2"
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Store month string
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	month - Month ID
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            MTHSTR macro month
00000000                            	local	mth
00000000                            	mth: SUBSTR 1+(((\month)-1)*3), 3+(((\month)-1)*3), &
00000000                            	dc.b	"\mth"
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Store build date
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            BUILDDATE macro
00000000                            	NUMSTR	4, _year+1900
00000000                            	dc.b	"/"
00000000                            	NUMSTR	2, _month
00000000                            	dc.b	"/"
00000000                            	NUMSTR	2, _day
00000000                            	dc.b	" "
00000000                            	NUMSTR	2, _hours
00000000                            	dc.b	":"
00000000                            	NUMSTR	2, _minutes
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Check if a parameter is a data register
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	param  - Parameter to check
00000000                            ; RETURNS:
00000000                            ;	is_reg - 0 = Not data register
00000000                            ;	         1 = Data register
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ISDREG macro param
00000000                            	local	num_str, num
00000000                            	is_reg: = 0
00000000                            	if strlen("\param")=2
00000000                            		if instr("\param","d")=1
00000000                            			num_str: SUBSTR 2,2,"\param"
00000000                            			num: EQU \num_str
00000000                            			if (num>=0)&(num<=7)
00000000                            				is_reg: = 1
00000000                            			endif
00000000                            		endif
00000000                            	endif
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Check if a parameter is an address register
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	param  - Parameter to check
00000000                            ; RETURNS:
00000000                            ;	is_reg - 0 = Not address register
00000000                            ;	         1 = Address register
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ISAREG macro param
00000000                            	local	numStr, num
00000000                            	is_reg: = 0
00000000                            	if strlen("\param")=2
00000000                            		if instr("\param","a")=1
00000000                            			numStr: SUBSTR 2,2,"\param"
00000000                            			num: EQU \numStr
00000000                            			if (num>=0)&(num<=7)
00000000                            				is_reg: = 1
00000000                            			endif
00000000                            		endif
00000000                            	endif
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            	include	"axm68k.i"
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Change CPU
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            cpu:		macro
00000000                            		if strcmp("\1","z80")
00000000                            		pusho						; save previous options
00000000                            		cpu_mode:	= 1				; Z80
00000000                            		opt	an+					; 1234h style numbering
00000000                            		opt	ae-					; disable auto evens
00000000                            
00000000                            		else
00000000                            		if def(cpu_mode)
00000000                            		popo						; restore options
00000000                            		endc
00000000                            
00000000                            		cpu_mode:	= 0				; 68000 by default
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; AS compatibility
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            phase:		macros
00000000                            		obj \1
00000000                            
00000000                            dephase:	macros
00000000                            		objend
00000000                            
00000000                            listing:	macro
00000000                            		if strcmp("\1","on")
00000000                            		list
00000000                            		else
00000000                            		nolist
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            binclude:	macros
00000000                            		incbin	\_
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Z80 instruction set
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            getzreg:	macro						; convert register to numerical value
00000000                            		if strcmp("\1","a")
00000000                            		zreg: = 7
00000000                            		elseif strcmp("\1","b")
00000000                            		zreg: = 0
00000000                            		elseif strcmp("\1","c")
00000000                            		zreg: = 1
00000000                            		elseif strcmp("\1","d")
00000000                            		zreg: = 2
00000000                            		elseif strcmp("\1","e")
00000000                            		zreg: = 3
00000000                            		elseif strcmp("\1","h")
00000000                            		zreg: = 4
00000000                            		elseif strcmp("\1","l")
00000000                            		zreg: = 5
00000000                            		elseif strcmp("\1","(hl)")
00000000                            		zreg: = 6
00000000                            		else
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            getindex:	macro						; convert index register to register offset and value
00000000                            		if instr("\1","(ix")
00000000                            		ireg: = $dd
00000000                            		elseif instr("\1","(iy")
00000000                            		ireg: = $fd
00000000                            		else
00000000                            			fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000 =00000000                  ix: =		0						; allows (ix+n) to be parsed as n
00000000 =00000000                  iy: =		0
00000000                            
00000000                            adc:		macro
00000000                            		local num
00000000                            		if strcmp("\1","hl")
00000000                            			if strcmp("\2","bc")
00000000                            			dc.w $ed4a
00000000                            			elseif strcmp("\2","de")
00000000                            			dc.w $ed5a
00000000                            			elseif strcmp("\2","hl")
00000000                            			dc.w $ed6a
00000000                            			elseif strcmp("\2","sp")
00000000                            			dc.w $ed7a
00000000                            			else
00000000                            			fail
00000000                            			endc
00000000                            			mexit
00000000                            		endc
00000000                            
00000000                            		; "adc a, x" or "adc x"
00000000                            		if narg=2 & strcmp("\1","a")
00000000                            			shift					; ignore a
00000000                            		endc
00000000                            
00000000                            		if (narg=1) | (narg=2)
00000000                            			if instr("a b c d e h l (hl) ","\1\ ")
00000000                            			getzreg	\1
00000000                            			dc.b $88+zreg
00000000                            			elseif strcmp("\1","ixh")
00000000                            			dc.w $dd8c
00000000                            			elseif strcmp("\1","ixl")
00000000                            			dc.w $dd8d
00000000                            			elseif strcmp("\1","iyh")
00000000                            			dc.w $fd8c
00000000                            			elseif strcmp("\1","iyl")
00000000                            			dc.w $fd8d
00000000                            			elseif instr("\1","(i")			; adc (ix+n)
00000000                            				num: equ \1
00000000                            				getindex \1
00000000                            				dc.b ireg, $8e, num
00000000                            			else					; adc n
00000000                            			num: equ \1
00000000                            			dc.b $ce, num
00000000                            			endc
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            bit:		macro
00000000                            		local num, num2
00000000                            		num: equ \1
00000000                            		if instr("a b c d e h l (hl) ","\2\ ")
00000000                            		getzreg	\2
00000000                            		dc.b $cb, $40+(num*8)+zreg
00000000                            		elseif instr("\2","(i")				; bit n,(ix+n)
00000000                            			num2: equ \2
00000000                            			getindex \2
00000000                            			dc.b ireg, $cb, num2, $40+(num*8)
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            call:		macro
00000000                            		local num
00000000                            		if narg=1					; call n
00000000                            		num: equ \1
00000000                            		dc.b $cd
00000000                            		elseif narg=2					; call x, n
00000000                            			num: equ \2
00000000                            			if strcmp("\1","nz")
00000000                            			dc.b $c4
00000000                            			elseif strcmp("\1","z")
00000000                            			dc.b $cc
00000000                            			elseif strcmp("\1","nc")
00000000                            			dc.b $d4
00000000                            			elseif strcmp("\1","c")
00000000                            			dc.b $dc
00000000                            			elseif strcmp("\1","po")
00000000                            			dc.b $e4
00000000                            			elseif strcmp("\1","pe")
00000000                            			dc.b $ec
00000000                            			elseif strcmp("\1","p")
00000000                            			dc.b $f4
00000000                            			elseif strcmp("\1","m")
00000000                            			dc.b $fc
00000000                            			else
00000000                            				fail
00000000                            			endc
00000000                            
00000000                            			shift
00000000                            		else
00000000                            			fail
00000000                            		endc
00000000                            
00000000                            		dc.b num&$FF, num>>8
00000000                            		endm
00000000                            
00000000                            ccf:		macros
00000000                            		dc.b $3f
00000000                            
00000000                            
00000000                            cp:		macro
00000000                            		local num
00000000                            		if instr("a b c d e h l (hl) ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $b8+zreg
00000000                            		elseif strcmp("\1","ixh")
00000000                            		dc.w $ddbc
00000000                            		elseif strcmp("\1","ixl")
00000000                            		dc.w $ddbd
00000000                            		elseif strcmp("\1","iyh")
00000000                            		dc.w $fdbc
00000000                            		elseif strcmp("\1","iyl")
00000000                            		dc.w $fdbd
00000000                            		elseif instr("\1","(i")				; cp (ix+n)
00000000                            			num: equ \1
00000000                            			getindex \1
00000000                            			dc.b ireg, $be, num
00000000                            		else						; cp n
00000000                            		num: equ \1
00000000                            		dc.b $fe, num
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            cpd:		macros
00000000                            		dc.w $eda9
00000000                            
00000000                            
00000000                            cpdr:		macros
00000000                            		dc.w $edb9
00000000                            
00000000                            
00000000                            cpi:		macros
00000000                            		dc.w $eda1
00000000                            
00000000                            
00000000                            cpir:		macros
00000000                            		dc.w $edb1
00000000                            
00000000                            
00000000                            cpl:		macros
00000000                            		dc.b $2f
00000000                            
00000000                            
00000000                            daa:		macros
00000000                            		dc.b $27
00000000                            
00000000                            
00000000                            dec:		macro
00000000                            		local num
00000000                            		if instr("a b c d e h l ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $5+(zreg*8)
00000000                            		elseif strcmp("\1","ixh")
00000000                            		dc.w $dd25
00000000                            		elseif strcmp("\1","ixl")
00000000                            		dc.w $dd2d
00000000                            		elseif strcmp("\1","iyh")
00000000                            		dc.w $fd25
00000000                            		elseif strcmp("\1","iyl")
00000000                            		dc.w $fd2d
00000000                            		elseif strcmp("\1","bc")
00000000                            		dc.b $b
00000000                            		elseif strcmp("\1","de")
00000000                            		dc.b $1b
00000000                            		elseif strcmp("\1","hl")
00000000                            		dc.b $2b
00000000                            		elseif strcmp("\1","ix")
00000000                            		dc.w $dd2b
00000000                            		elseif strcmp("\1","iy")
00000000                            		dc.w $fd2b
00000000                            		elseif strcmp("\1","sp")
00000000                            		dc.b $3b
00000000                            		elseif instr("\1","(i")				; dec (ix+n)
00000000                            			num: equ \1
00000000                            			getindex \1
00000000                            			dc.b ireg, $35, num
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            di:		macros
00000000                            		dc.b $f3
00000000                            
00000000                            
00000000                            djnz:		macro
00000000                            		local num
00000000                            		num: equ \1
00000000                            		dc.b $10, num-*-2
00000000                            		endm
00000000                            
00000000                            
00000000                            ei:		macros
00000000                            		dc.b $fb
00000000                            
00000000                            
00000000                            ex:		macro
00000000                            		if strcmp("\_","af,af")				; ex af,af'
00000000                            		dc.b 8
00000000                            		elseif strcmp("\_","(sp),hl")
00000000                            		dc.b $e3
00000000                            		elseif strcmp("\_","(sp),ix")
00000000                            		dc.w $dde3
00000000                            		elseif strcmp("\_","(sp),iy")
00000000                            		dc.w $fde3
00000000                            		elseif strcmp("\_","de,hl")
00000000                            		dc.b $eb
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            exx:		macros
00000000                            		dc.b $d9
00000000                            
00000000                            
00000000                            halt:		macros
00000000                            		dc.b $76
00000000                            
00000000                            
00000000                            im:		macro
00000000                            		if \1=0
00000000                            		dc.w $ed46
00000000                            		elseif \1=1
00000000                            		dc.w $ed56
00000000                            		elseif \1=2
00000000                            		dc.w $ed5e
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            in:		macro
00000000                            		local num
00000000                            		if strcmp("\1","a")
00000000                            			if strcmp("\2","(c)")
00000000                            			dc.w $ed78
00000000                            			else					; in a,n
00000000                            			num: equ \2
00000000                            			dc.b $db, num
00000000                            			endc
00000000                            		elseif instr("b c d e h l ","\1\ ")&strcmp("\2","(c)")
00000000                            		getzreg	\1
00000000                            		dc.w $ed40+(zreg*8)
00000000                            		elseif strcmp("\1","(c)")
00000000                            		dc.w $ed70
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            inc:		macro
00000000                            		local num
00000000                            		if instr("a b c d e h l ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $4+(zreg*8)
00000000                            		elseif strcmp("\1","ixh")
00000000                            		dc.w $dd24
00000000                            		elseif strcmp("\1","ixl")
00000000                            		dc.w $dd2c
00000000                            		elseif strcmp("\1","iyh")
00000000                            		dc.w $fd24
00000000                            		elseif strcmp("\1","iyl")
00000000                            		dc.w $fd2c
00000000                            		elseif strcmp("\1","bc")
00000000                            		dc.b $3
00000000                            		elseif strcmp("\1","de")
00000000                            		dc.b $13
00000000                            		elseif strcmp("\1","hl")
00000000                            		dc.b $23
00000000                            		elseif strcmp("\1","ix")
00000000                            		dc.w $dd23
00000000                            		elseif strcmp("\1","iy")
00000000                            		dc.w $fd23
00000000                            		elseif strcmp("\1","sp")
00000000                            		dc.b $33
00000000                            		elseif instr("\1","(i")				; inc (ix+n)
00000000                            			num: equ \1
00000000                            			getindex \1
00000000                            			dc.b ireg, $34, num
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            ind:		macros
00000000                            		dc.w $edaa
00000000                            
00000000                            
00000000                            indr:		macros
00000000                            		dc.w $edba
00000000                            
00000000                            
00000000                            ini:		macros
00000000                            		dc.w $eda2
00000000                            
00000000                            
00000000                            inir:		macros
00000000                            		dc.w $edb2
00000000                            
00000000                            
00000000                            jp:		macro
00000000                            		local num
00000000                            		if strcmp("\1","(hl)")
00000000                            		dc.b $e9
00000000                            		elseif strcmp("\1","(ix)")
00000000                            		dc.w $dde9
00000000                            		elseif strcmp("\1","(iy)")
00000000                            		dc.w $fde9
00000000                            		else
00000000                            			if strcmp("\1","nz")
00000000                            			num: equ \2
00000000                            			dc.b $c2
00000000                            			elseif strcmp("\1","z")
00000000                            			num: equ \2
00000000                            			dc.b $ca
00000000                            			elseif strcmp("\1","nc")
00000000                            			num: equ \2
00000000                            			dc.b $d2
00000000                            			elseif strcmp("\1","c")
00000000                            			num: equ \2
00000000                            			dc.b $da
00000000                            			elseif strcmp("\1","po")
00000000                            			num: equ \2
00000000                            			dc.b $e2
00000000                            			elseif strcmp("\1","pe")
00000000                            			num: equ \2
00000000                            			dc.b $ea
00000000                            			elseif strcmp("\1","p")
00000000                            			num: equ \2
00000000                            			dc.b $f2
00000000                            			elseif strcmp("\1","m")
00000000                            			num: equ \2
00000000                            			dc.b $fa
00000000                            			else					; jp n
00000000                            			num: equ \1
00000000                            			dc.b $c3
00000000                            			endc
00000000                            			if narg=2
00000000                            			shift
00000000                            			endc
00000000                            			dc.b num&$FF, num>>8
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            jr:		macro
00000000                            		local num
00000000                            		if strcmp("\1","nz")
00000000                            		num: equ \2
00000000                            		dc.b $20
00000000                            		elseif strcmp("\1","z")
00000000                            		num: equ \2
00000000                            		dc.b $28
00000000                            		elseif strcmp("\1","nc")
00000000                            		num: equ \2
00000000                            		dc.b $30
00000000                            		elseif strcmp("\1","c")
00000000                            		num: equ \2
00000000                            		dc.b $38
00000000                            		else						; jr n
00000000                            		num: equ \1
00000000                            		dc.b $18
00000000                            		endc
00000000                            		if narg=2
00000000                            		shift
00000000                            		endc
00000000                            		dc.b num-*-1
00000000                            		;if ((num-*)>=-$80)&((num-*)<=$7f)
00000000                            		;fail
00000000                            		;endc
00000000                            		endm
00000000                            
00000000                            
00000000                            ld:		macro
00000000                            		local num, num2
00000000                            		if strcmp("\1","a")
00000000                            			if instr("a b c d e h l (hl) ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.b $78+zreg
00000000                            			elseif strcmp("\2","i")
00000000                            			dc.w $ed57
00000000                            			elseif strcmp("\2","r")
00000000                            			dc.w $ed5f
00000000                            			elseif strcmp("\2","ixh")
00000000                            			dc.w $dd7c
00000000                            			elseif strcmp("\2","ixl")
00000000                            			dc.w $dd7d
00000000                            			elseif strcmp("\2","iyh")
00000000                            			dc.w $fd7c
00000000                            			elseif strcmp("\2","iyl")
00000000                            			dc.w $fd7d
00000000                            			elseif strcmp("\2","(bc)")
00000000                            			dc.b $0a
00000000                            			elseif strcmp("\2","(de)")
00000000                            			dc.b $1a
00000000                            			elseif instr("\2","(i")			; ld a,(ix+n)
00000000                            				num: equ \2
00000000                            				getindex \2
00000000                            				dc.b ireg, $7e, num
00000000                            			else
00000000                            				num: equ \2
00000000                            				tmp_len: = strlen("\2")
00000000                            				tmp_fc:	substr	1,1,"\2"
00000000                            				tmp_lc:	substr	tmp_len,tmp_len,"\2"
00000000                            				if strcmp("\tmp_fc","(") & strcmp("\tmp_lc",")") ; ld a,(n)
00000000                            				dc.b $3a, num&$ff, num>>8
00000000                            				else				; ld a,n
00000000                            				dc.b $3e, num
00000000                            				endc
00000000                            			endc
00000000                            		elseif strcmp("\1","b")
00000000                            			if instr("a b c d e h l (hl) ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.b $40+zreg
00000000                            			elseif strcmp("\2","ixh")
00000000                            			dc.w $dd44
00000000                            			elseif strcmp("\2","ixl")
00000000                            			dc.w $dd45
00000000                            			elseif strcmp("\2","iyh")
00000000                            			dc.w $fd44
00000000                            			elseif strcmp("\2","iyl")
00000000                            			dc.w $fd45
00000000                            			elseif instr("\2","(i")			; ld b,(ix+n)
00000000                            				num: equ \2
00000000                            				getindex \2
00000000                            				dc.b ireg, $46, num
00000000                            			else					; ld b,n
00000000                            			num: equ \2
00000000                            			dc.b $6, num
00000000                            			endc
00000000                            		elseif strcmp("\1","c")
00000000                            			if instr("a b c d e h l (hl) ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.b $48+zreg
00000000                            			elseif strcmp("\2","ixh")
00000000                            			dc.w $dd4c
00000000                            			elseif strcmp("\2","ixl")
00000000                            			dc.w $dd4d
00000000                            			elseif strcmp("\2","iyh")
00000000                            			dc.w $fd4c
00000000                            			elseif strcmp("\2","iyl")
00000000                            			dc.w $fd4d
00000000                            			elseif instr("\2","(i")			; ld c,(ix+n)
00000000                            				num: equ \2
00000000                            				getindex \2
00000000                            				dc.b ireg, $4e, num
00000000                            			else					; ld c,n
00000000                            			num: equ \2
00000000                            			dc.b $e, num
00000000                            			endc
00000000                            		elseif strcmp("\1","d")
00000000                            			if instr("a b c d e h l (hl) ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.b $50+zreg
00000000                            			elseif strcmp("\2","ixh")
00000000                            			dc.w $dd54
00000000                            			elseif strcmp("\2","ixl")
00000000                            			dc.w $dd55
00000000                            			elseif strcmp("\2","iyh")
00000000                            			dc.w $fd54
00000000                            			elseif strcmp("\2","iyl")
00000000                            			dc.w $fd55
00000000                            			elseif instr("\2","(i")			; ld d,(ix+n)
00000000                            				num: equ \2
00000000                            				getindex \2
00000000                            				dc.b ireg, $56, num
00000000                            			else					; ld d,n
00000000                            			num: equ \2
00000000                            			dc.b $16, num
00000000                            			endc
00000000                            		elseif strcmp("\1","e")
00000000                            			if instr("a b c d e h l (hl) ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.b $58+zreg
00000000                            			elseif strcmp("\2","ixh")
00000000                            			dc.w $dd5c
00000000                            			elseif strcmp("\2","ixl")
00000000                            			dc.w $dd5d
00000000                            			elseif strcmp("\2","iyh")
00000000                            			dc.w $fd5c
00000000                            			elseif strcmp("\2","iyl")
00000000                            			dc.w $fd5d
00000000                            			elseif instr("\2","(i")			; ld e,(ix+n)
00000000                            				num: equ \2
00000000                            				getindex \2
00000000                            				dc.b ireg, $5e, num
00000000                            			else					; ld e,n
00000000                            			num: equ \2
00000000                            			dc.b $1e, num
00000000                            			endc
00000000                            		elseif strcmp("\1","h")
00000000                            			if instr("a b c d e h l (hl) ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.b $60+zreg
00000000                            			elseif instr("\2","(i")			; ld h,(ix+n)
00000000                            				num: equ \2
00000000                            				getindex \2
00000000                            				dc.b ireg, $66, num
00000000                            			else					; ld h,n
00000000                            			num: equ \2
00000000                            			dc.b $26, num
00000000                            			endc
00000000                            		elseif strcmp("\1","l")
00000000                            			if instr("a b c d e h l (hl) ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.b $68+zreg
00000000                            			elseif instr("\2","(i")			; ld l,(ix+n)
00000000                            				num: equ \2
00000000                            				getindex \2
00000000                            				dc.b ireg, $6e, num
00000000                            			else					; ld l,n
00000000                            			num: equ \2
00000000                            			dc.b $2e, num
00000000                            			endc
00000000                            		elseif strcmp("\1","i")
00000000                            		dc.w $ed47
00000000                            		elseif strcmp("\1","r")
00000000                            		dc.w $ed4f
00000000                            		elseif strcmp("\1","ixh")
00000000                            			if instr("a b c d e ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.w $dd60+zreg
00000000                            			elseif strcmp("\2","ixh")
00000000                            			dc.w $dd64
00000000                            			elseif strcmp("\2","ixl")
00000000                            			dc.w $dd65
00000000                            			else					; ld ixh,n
00000000                            			num: equ \2
00000000                            			dc.b $dd, $26, num
00000000                            			endc
00000000                            		elseif strcmp("\1","ixl")
00000000                            			if instr("a b c d e ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.w $dd68+zreg
00000000                            			elseif strcmp("\2","ixh")
00000000                            			dc.w $dd6c
00000000                            			elseif strcmp("\2","ixl")
00000000                            			dc.w $dd6d
00000000                            			else					; ld ixl,n
00000000                            			num: equ \2
00000000                            			dc.b $dd, $2e, num
00000000                            			endc
00000000                            		elseif strcmp("\1","iyh")
00000000                            			if instr("a b c d e ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.w $fd60+zreg
00000000                            			elseif strcmp("\2","iyh")
00000000                            			dc.w $fd64
00000000                            			elseif strcmp("\2","iyl")
00000000                            			dc.w $fd65
00000000                            			else					; ld iyh,n
00000000                            			num: equ \2
00000000                            			dc.b $fd, $26, num
00000000                            			endc
00000000                            		elseif strcmp("\1","iyl")
00000000                            			if instr("a b c d e ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.w $fd68+zreg
00000000                            			elseif strcmp("\2","iyh")
00000000                            			dc.w $fd6c
00000000                            			elseif strcmp("\2","iyl")
00000000                            			dc.w $fd6d
00000000                            			else					; ld iyl,n
00000000                            			num: equ \2
00000000                            			dc.b $fd, $2e, num
00000000                            			endc
00000000                            		elseif strcmp("\1","bc")
00000000                            			num: equ \2
00000000                            			tmp_len: = strlen("\2")
00000000                            			tmp_fc:	substr	1,1,"\2"
00000000                            			tmp_lc:	substr	tmp_len,tmp_len,"\2"
00000000                            			if strcmp("\tmp_fc","(") & strcmp("\tmp_lc",")") ; ld bc,(n)
00000000                            			dc.b $ed, $4b, num&$ff, num>>8
00000000                            			else					; ld bc,n
00000000                            			dc.b $1, num&$ff, num>>8
00000000                            			endc
00000000                            		elseif strcmp("\1","de")
00000000                            			num: equ \2
00000000                            			tmp_len: = strlen("\2")
00000000                            			tmp_fc:	substr	1,1,"\2"
00000000                            			tmp_lc:	substr	tmp_len,tmp_len,"\2"
00000000                            			if strcmp("\tmp_fc","(") & strcmp("\tmp_lc",")") ; ld de,(n)
00000000                            			dc.b $ed, $5b, num&$ff, num>>8
00000000                            			else					; ld de,n
00000000                            			dc.b $11, num&$ff, num>>8
00000000                            			endc
00000000                            		elseif strcmp("\1","hl")
00000000                            			num: equ \2
00000000                            			tmp_len: = strlen("\2")
00000000                            			tmp_fc:	substr	1,1,"\2"
00000000                            			tmp_lc:	substr	tmp_len,tmp_len,"\2"
00000000                            			if strcmp("\tmp_fc","(") & strcmp("\tmp_lc",")") ; ld hl,(n)
00000000                            			dc.b $ed, $6b, num&$ff, num>>8
00000000                            			else					; ld hl,n
00000000                            			dc.b $21, num&$ff, num>>8
00000000                            			endc
00000000                            		elseif strcmp("\1","sp")
00000000                            			if strcmp("\2","hl")
00000000                            			dc.b $f9
00000000                            			elseif strcmp("\2","ix")
00000000                            			dc.w $ddf9
00000000                            			elseif strcmp("\2","iy")
00000000                            			dc.w $fdf9
00000000                            			else
00000000                            				num: equ \2
00000000                            				tmp_len: = strlen("\2")
00000000                            				tmp_fc:	substr	1,1,"\2"
00000000                            				tmp_lc:	substr	tmp_len,tmp_len,"\2"
00000000                            				if strcmp("\tmp_fc","(") & strcmp("\tmp_lc",")") ; ld sp,(n)
00000000                            				dc.b $ed, $7b, num&$ff, num>>8
00000000                            				else				; ld sp,n
00000000                            				dc.b $31, num&$ff, num>>8
00000000                            				endc
00000000                            			endc
00000000                            		elseif strcmp("\1","ix")
00000000                            			num: equ \2
00000000                            			tmp_len: = strlen("\2")
00000000                            			tmp_fc:	substr	1,1,"\2"
00000000                            			tmp_lc:	substr	tmp_len,tmp_len,"\2"
00000000                            			if strcmp("\tmp_fc","(") & strcmp("\tmp_lc",")") ; ld ix,(n)
00000000                            			dc.b $dd, $2a, num&$ff, num>>8
00000000                            			else					; ld ix,n
00000000                            			dc.b $dd, $21, num&$ff, num>>8
00000000                            			endc
00000000                            		elseif strcmp("\1","iy")
00000000                            			num: equ \2
00000000                            			tmp_len: = strlen("\2")
00000000                            			tmp_fc:	substr	1,1,"\2"
00000000                            			tmp_lc:	substr	tmp_len,tmp_len,"\2"
00000000                            			if strcmp("\tmp_fc","(") & strcmp("\tmp_lc",")") ; ld iy,(n)
00000000                            			dc.b $fd, $2a, num&$ff, num>>8
00000000                            			else					; ld iy,n
00000000                            			dc.b $fd, $21, num&$ff, num>>8
00000000                            			endc
00000000                            		elseif strcmp("\1","(bc)")
00000000                            		dc.b 2
00000000                            		elseif strcmp("\1","(de)")
00000000                            		dc.b $12
00000000                            		elseif strcmp("\1","(hl)")
00000000                            			if instr("a b c d e h l ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.b $70+zreg
00000000                            			else					; ld (hl),n
00000000                            			num: equ \2
00000000                            			dc.b $36, num
00000000                            			endc
00000000                            		elseif instr("\1","(i")				; ld (ix+n),?
00000000                            			if instr("a b c d e h l ","\2\ ")
00000000                            				num: equ \1
00000000                            				getzreg	\2
00000000                            				getindex \1
00000000                            				dc.b ireg, $70|zreg, num
00000000                            			else					; ld (ix+n),n
00000000                            				num: equ \1
00000000                            				num2: equ \2
00000000                            				getindex \1
00000000                            				dc.b ireg, $36, num, num2
00000000                            			endc
00000000                            		else						; ld (n),?
00000000                            			num: equ \1
00000000                            			if strcmp("\2","a")
00000000                            			dc.b $32
00000000                            			elseif strcmp("\2","bc")
00000000                            			dc.w $ed43
00000000                            			elseif strcmp("\2","de")
00000000                            			dc.w $ed53
00000000                            			elseif strcmp("\2","hl")
00000000                            			dc.w $ed63
00000000                            			elseif strcmp("\2","sp")
00000000                            			dc.w $ed73
00000000                            			elseif strcmp("\2","ix")
00000000                            			dc.w $dd22
00000000                            			elseif strcmp("\2","iy")
00000000                            			dc.w $fd22
00000000                            			else
00000000                            			fail
00000000                            			endc
00000000                            			dc.b num&$FF, num>>8
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            ldd:		macros
00000000                            		dc.w $eda8
00000000                            
00000000                            
00000000                            lddr:		macros
00000000                            		dc.w $edb8
00000000                            
00000000                            
00000000                            ldi:		macros
00000000                            		dc.w $eda0
00000000                            
00000000                            
00000000                            ldir:		macros
00000000                            		dc.w $edb0
00000000                            
00000000                            
00000000                            otdr:		macros
00000000                            		dc.w $edbb
00000000                            
00000000                            
00000000                            otir:		macros
00000000                            		dc.w $edb3
00000000                            
00000000                            
00000000                            out:		macro
00000000                            		local num
00000000                            		if strcmp("\1","(c)")&instr("a b c d e h l ","\2\ ")
00000000                            		getzreg	\2
00000000                            		dc.w $ed41+(zreg*8)
00000000                            		elseif strcmp("\_","(c),0")
00000000                            		dc.w $ed71
00000000                            		elseif strcmp("\2","a")				; out n,a
00000000                            		num: equ \1
00000000                            		dc.b $d3, num
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            outd:		macros
00000000                            		dc.w $edab
00000000                            
00000000                            
00000000                            outi:		macros
00000000                            		dc.w $eda3
00000000                            
00000000                            
00000000                            pop:		macro
00000000                            		if strcmp("\1","bc")
00000000                            		dc.b $c1
00000000                            		elseif strcmp("\1","de")
00000000                            		dc.b $d1
00000000                            		elseif strcmp("\1","hl")
00000000                            		dc.b $e1
00000000                            		elseif strcmp("\1","af")
00000000                            		dc.b $f1
00000000                            		elseif strcmp("\1","ix")
00000000                            		dc.w $dde1
00000000                            		elseif strcmp("\1","iy")
00000000                            		dc.w $fde1
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            push:		macro
00000000                            		if strcmp("\1","bc")
00000000                            		dc.b $c5
00000000                            		elseif strcmp("\1","de")
00000000                            		dc.b $d5
00000000                            		elseif strcmp("\1","hl")
00000000                            		dc.b $e5
00000000                            		elseif strcmp("\1","af")
00000000                            		dc.b $f5
00000000                            		elseif strcmp("\1","ix")
00000000                            		dc.w $dde5
00000000                            		elseif strcmp("\1","iy")
00000000                            		dc.w $fde5
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            res:		macro
00000000                            		local num, num2
00000000                            		num: equ \1
00000000                            		if instr("a b c d e h l (hl) ","\2\ ")
00000000                            		getzreg	\2
00000000                            		dc.b $cb, $80+(num*8)+zreg
00000000                            		elseif instr("\2","(i")				; res n,(ix+n)
00000000                            			num2: equ \2
00000000                            			getindex \2
00000000                            			dc.b ireg, $cb, num2
00000000                            		dc.b $80+(num*8)
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            ret:		macro
00000000                            		if strcmp("\1","nz")
00000000                            		dc.b $c0
00000000                            		elseif strcmp("\1","z")
00000000                            		dc.b $c8
00000000                            		elseif strcmp("\1","nc")
00000000                            		dc.b $d0
00000000                            		elseif strcmp("\1","c")
00000000                            		dc.b $d8
00000000                            		elseif strcmp("\1","po")
00000000                            		dc.b $e0
00000000                            		elseif strcmp("\1","pe")
00000000                            		dc.b $e8
00000000                            		elseif strcmp("\1","p")
00000000                            		dc.b $f0
00000000                            		elseif strcmp("\1","m")
00000000                            		dc.b $f8
00000000                            		elseif strlen("\1")=0				; ret
00000000                            		dc.b $c9
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            reti:		macros
00000000                            		dc.w $ed4d
00000000                            
00000000                            
00000000                            retn:		macros
00000000                            		dc.w $ed45
00000000                            
00000000                            
00000000                            rl:		macro
00000000                            		local num
00000000                            		if instr("a b c d e h l (hl) ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $cb, $10+zreg
00000000                            		elseif instr("\1","(i")				; rl (ix+n)
00000000                            			num: equ \1
00000000                            			getindex \1
00000000                            			dc.b ireg, $cb, num
00000000                            
00000000                            			if narg=2				; rl (ix+n),?
00000000                            			getzreg	\2
00000000                            			dc.b $10+zreg
00000000                            			else
00000000                            			dc.b $16
00000000                            			endc
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            rla:		macros
00000000                            		dc.b $17
00000000                            
00000000                            
00000000                            rlc:		macro
00000000                            		local num
00000000                            		if instr("a b c d e h l (hl) ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $cb, zreg
00000000                            		elseif instr("\1","(i")				; rlc (ix+n)
00000000                            			num: equ \1
00000000                            			getindex \1
00000000                            			dc.b ireg, $cb, num
00000000                            
00000000                            			if narg=2				; rlc (ix+n),?
00000000                            			getzreg	\2
00000000                            			dc.b zreg
00000000                            			else
00000000                            			dc.b $6
00000000                            			endc
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            rlca:		macros
00000000                            		dc.b $7
00000000                            
00000000                            
00000000                            rld:		macros
00000000                            		dc.w $ed6f
00000000                            
00000000                            
00000000                            rr:		macro
00000000                            		local num
00000000                            		if instr("a b c d e h l (hl) ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $cb, $18+zreg
00000000                            		elseif instr("\1","(i")				; rr (ix+n)
00000000                            			num: equ \1
00000000                            			getindex \1
00000000                            			dc.b ireg, $cb, num
00000000                            
00000000                            			if narg=2				; rr (ix+n),?
00000000                            			getzreg	\2
00000000                            			dc.b $18+zreg
00000000                            			else
00000000                            			dc.b $1e
00000000                            			endc
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            rra:		macros
00000000                            		dc.b $1f
00000000                            
00000000                            
00000000                            rrc:		macro
00000000                            		local num
00000000                            		if instr("a b c d e h l (hl) ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $cb, $8+zreg
00000000                            		elseif instr("\1","(i")				; rrc (ix+n)
00000000                            			num: equ \1
00000000                            			getindex \1
00000000                            			dc.b ireg, $cb, num
00000000                            
00000000                            			if narg=2				; rrc (ix+n),?
00000000                            			getzreg	\2
00000000                            			dc.b $8+zreg
00000000                            			else
00000000                            			dc.b $e
00000000                            			endc
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            rrca:		macros
00000000                            		dc.b $f
00000000                            
00000000                            
00000000                            rrd:		macros
00000000                            		dc.w $ed67
00000000                            
00000000                            
00000000                            rst:		macro
00000000                            		local num
00000000                            		num: equ \1
00000000                            		dc.b $c7+(num&$38)
00000000                            		endm
00000000                            
00000000                            
00000000                            sbc:		macro
00000000                            		local num
00000000                            		if strcmp("\1","a")
00000000                            			if instr("a b c d e h l (hl) ","\2\ ")
00000000                            			getzreg	\2
00000000                            			dc.b $98+zreg
00000000                            			elseif strcmp("\2","ixh")
00000000                            			dc.w $dd9c
00000000                            			elseif strcmp("\2","ixl")
00000000                            			dc.w $dd9d
00000000                            			elseif strcmp("\2","iyh")
00000000                            			dc.w $fd9c
00000000                            			elseif strcmp("\2","iyl")
00000000                            			dc.w $fd9d
00000000                            			elseif instr("\2","(i")			; sbc a,(ix+n)
00000000                            				num: equ \2
00000000                            				getindex \2
00000000                            				dc.b ireg, $9e, num
00000000                            			else					; sbc a,n
00000000                            			num: equ \2
00000000                            			dc.b $de, num
00000000                            			endc
00000000                            		elseif strcmp("\1","hl")
00000000                            			if strcmp("\2","bc")
00000000                            			dc.w $ed42
00000000                            			elseif strcmp("\2","de")
00000000                            			dc.w $ed52
00000000                            			elseif strcmp("\2","hl")
00000000                            			dc.w $ed62
00000000                            			elseif strcmp("\2","sp")
00000000                            			dc.w $ed72
00000000                            			else
00000000                            			fail
00000000                            			endc
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            scf:		macros
00000000                            		dc.b $37
00000000                            
00000000                            
00000000                            set:		macro
00000000                            		local num, num2
00000000                            		num: equ \1
00000000                            		if instr("a b c d e h l (hl) ","\2\ ")
00000000                            		getzreg	\2
00000000                            		dc.b $cb, $c0+(num*8)+zreg
00000000                            		elseif instr("\2","(i")				; set n,(ix+n)
00000000                            			num2: equ \2
00000000                            			getindex \2
00000000                            			dc.b ireg, $cb, num2, $c0+(num*8)
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            sla:		macro
00000000                            		local num
00000000                            		if instr("a b c d e h l (hl) ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $cb, $20+zreg
00000000                            		elseif instr("\1","(i")
00000000                            			num: equ \1
00000000                            			getindex \1
00000000                            			dc.b ireg, $cb, num
00000000                            
00000000                            			if narg=2				; sla (ix+n),?
00000000                            			getzreg	\2
00000000                            			dc.b $20+zreg
00000000                            			else					; sla (ix+n)
00000000                            			dc.b $26
00000000                            			endc
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            sll:		macro
00000000                            		local num
00000000                            		if instr("a b c d e h l (hl) ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $cb, $30+zreg
00000000                            		elseif instr("\1","(i")
00000000                            			num: equ \1
00000000                            			getindex \1
00000000                            			dc.b ireg, $cb, num
00000000                            
00000000                            			if narg=2				; sll (ix+n),?
00000000                            			getzreg	\2
00000000                            			dc.b $30+zreg
00000000                            			else					; sll (ix+n)
00000000                            			dc.b $36
00000000                            			endc
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            sra:		macro
00000000                            		local num
00000000                            		if instr("a b c d e h l (hl) ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $cb, $28+zreg
00000000                            		elseif instr("\1","(i")
00000000                            			num: equ \1
00000000                            			getindex \1
00000000                            			dc.b ireg, $cb, num
00000000                            
00000000                            			if narg=2				; sra (ix+n),?
00000000                            			getzreg	\2
00000000                            			dc.b $28+zreg
00000000                            			else					; sra (ix+n)
00000000                            			dc.b $2e
00000000                            			endc
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            srl:		macro
00000000                            		local num
00000000                            		if instr("a b c d e h l (hl) ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $cb, $38+zreg
00000000                            		elseif instr("\1","(i")
00000000                            			num: equ \1
00000000                            			getindex \1
00000000                            			dc.b ireg, $cb, num
00000000                            
00000000                            			if narg=2				; srl (ix+n),?
00000000                            			getzreg	\2
00000000                            			dc.b $38+zreg
00000000                            			else					; srl (ix+n)
00000000                            			dc.b $3e
00000000                            			endc
00000000                            		else
00000000                            		fail
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            xor:		macro
00000000                            		local num
00000000                            		if instr("a b c d e h l (hl) ","\1\ ")
00000000                            		getzreg	\1
00000000                            		dc.b $a8+zreg
00000000                            		elseif strcmp("\1","ixh")
00000000                            		dc.w $ddac
00000000                            		elseif strcmp("\1","ixl")
00000000                            		dc.w $ddad
00000000                            		elseif strcmp("\1","iyh")
00000000                            		dc.w $fdac
00000000                            		elseif strcmp("\1","iyl")
00000000                            		dc.w $fdad
00000000                            		elseif instr("\1","(i")				; xor (ix+n)
00000000                            			num: equ \1
00000000                            			getindex \1
00000000                            			dc.b ireg, $ae, num
00000000                            		else						; xor n
00000000                            		num: equ \1
00000000                            		dc.b $ee, num
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            db:		macros
00000000                            		dc.b \_
00000000                            
00000000                            
00000000                            dw:		macro
00000000                            		local c
00000000                            		c: = 0
00000000                            		rept narg
00000000                            			local num\#c
00000000                            			num\#c\: equ \1
00000000                            			dc.b (num\#c\)&$FF, (num\#c\)>>8
00000000                            			shift
00000000                            			c: = c+1
00000000                            		endr
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Mixed instruction set
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            add:		macro
00000000                            		local num
00000000                            		if cpu_mode=1					; Z80
00000000                            			if strcmp("\1","hl")
00000000                            				if strcmp("\2","bc")
00000000                            				dc.b $9
00000000                            				elseif strcmp("\2","de")
00000000                            				dc.b $19
00000000                            				elseif strcmp("\2","hl")
00000000                            				dc.b $29
00000000                            				elseif strcmp("\2","sp")
00000000                            				dc.b $39
00000000                            				else
00000000                            				fail
00000000                            				endc
00000000                            				mexit
00000000                            
00000000                            			elseif strcmp("\1","ix")
00000000                            				if strcmp("\2","bc")
00000000                            				dc.w $dd09
00000000                            				elseif strcmp("\2","de")
00000000                            				dc.w $dd19
00000000                            				elseif strcmp("\2","ix")
00000000                            				dc.w $dd29
00000000                            				elseif strcmp("\2","sp")
00000000                            				dc.w $dd39
00000000                            				else
00000000                            				fail
00000000                            				endc
00000000                            				mexit
00000000                            
00000000                            			elseif strcmp("\1","iy")
00000000                            				if strcmp("\2","bc")
00000000                            				dc.w $fd09
00000000                            				elseif strcmp("\2","de")
00000000                            				dc.w $fd19
00000000                            				elseif strcmp("\2","iy")
00000000                            				dc.w $fd29
00000000                            				elseif strcmp("\2","sp")
00000000                            				dc.w $fd39
00000000                            				else
00000000                            				fail
00000000                            				endc
00000000                            				mexit
00000000                            			endc
00000000                            
00000000                            								; "add a, x" or "add x"
00000000                            			if (narg=2) & strcmp("\1","a")
00000000                            				shift				; ignore a
00000000                            			endc
00000000                            
00000000                            			if (narg=1) | (narg=2)
00000000                            				if instr("a b c d e h l (hl) ","\1\ ")
00000000                            				getzreg	\1
00000000                            				dc.b $80+zreg
00000000                            				elseif strcmp("\1","ixh")
00000000                            				dc.w $dd84
00000000                            				elseif strcmp("\1","ixl")
00000000                            				dc.w $dd85
00000000                            				elseif strcmp("\1","iyh")
00000000                            				dc.w $fd84
00000000                            				elseif strcmp("\1","iyl")
00000000                            				dc.w $fd85
00000000                            				elseif instr("\1","(i")		; add (ix+n)
00000000                            					num: equ \1
00000000                            					getindex \1
00000000                            					dc.b ireg, $86, num
00000000                            				else				; add n
00000000                            				num: equ \1
00000000                            				dc.b $c6, num
00000000                            				endc
00000000                            			else
00000000                            			fail
00000000                            			endc
00000000                            		else						; 68k
00000000                            		axd.\0	\_
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            and:		macro
00000000                            		local num
00000000                            		if cpu_mode=1					; Z80
00000000                            			if instr("a b c d e h l (hl) ","\1\ ")
00000000                            			getzreg	\1
00000000                            			dc.b $a0+zreg
00000000                            			elseif strcmp("\1","ixh")
00000000                            			dc.w $dda4
00000000                            			elseif strcmp("\1","ixl")
00000000                            			dc.w $dda5
00000000                            			elseif strcmp("\1","iyh")
00000000                            			dc.w $fda4
00000000                            			elseif strcmp("\1","iyl")
00000000                            			dc.w $fda5
00000000                            			elseif instr("\1","(i")			; and (ix+n)
00000000                            				num: equ \1
00000000                            				getindex \1
00000000                            				dc.b ireg, $a6, num
00000000                            			else					; and n
00000000                            			num: equ \1
00000000                            			dc.b $e6, num
00000000                            			endc
00000000                            		else						; 68k
00000000                            		anx.\0	\_
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            neg:		macro
00000000                            		if cpu_mode=1					; Z80
00000000                            		dc.w $ed44
00000000                            		else						; 68k
00000000                            		nxg.\0	\_
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            nop:		macro
00000000                            		if cpu_mode=1					; Z80
00000000                            		dc.b 0
00000000                            		else						; 68k
00000000                            		nxp
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            or:		macro
00000000                            		local num
00000000                            		if cpu_mode=1					; Z80
00000000                            			if instr("a b c d e h l (hl) ","\1\ ")
00000000                            			getzreg	\1
00000000                            			dc.b $b0+zreg
00000000                            			elseif strcmp("\1","ixh")
00000000                            			dc.w $ddb4
00000000                            			elseif strcmp("\1","ixl")
00000000                            			dc.w $ddb5
00000000                            			elseif strcmp("\1","iyh")
00000000                            			dc.w $fdb4
00000000                            			elseif strcmp("\1","iyl")
00000000                            			dc.w $fdb5
00000000                            			elseif instr("\1","(i")			; or (ix+n)
00000000                            				num: equ \1
00000000                            				getindex \1
00000000                            				dc.b ireg, $b6, num
00000000                            			else					; or n
00000000                            			num: equ \1
00000000                            			dc.b $f6, num
00000000                            			endc
00000000                            		else						; 68k
00000000                            		ox.\0	\_
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            
00000000                            sub:		macro
00000000                            		local num
00000000                            		if cpu_mode=1					; Z80
00000000                            			if instr("a b c d e h l (hl) ","\1\ ")
00000000                            			getzreg	\1
00000000                            			dc.b $90+zreg
00000000                            			elseif strcmp("\1","ixh")
00000000                            			dc.w $dd94
00000000                            			elseif strcmp("\1","ixl")
00000000                            			dc.w $dd95
00000000                            			elseif strcmp("\1","iyh")
00000000                            			dc.w $fd94
00000000                            			elseif strcmp("\1","iyl")
00000000                            			dc.w $fd95
00000000                            			elseif instr("\1","(i")			; sub (ix+n)
00000000                            				um: equ \1
00000000                            				getindex \1
00000000                            				dc.b ireg, $96, num
00000000                            			else					; sub n
00000000                            			num: equ \1
00000000                            			dc.b $d6, num
00000000                            			endc
00000000                            		else						; 68k
00000000                            		sxb.\0	\_
00000000                            		endc
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Restored ASM68k instruction set
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            adda:		macros
00000000                            		axda.\0	\_
00000000                            
00000000                            addi:		macros
00000000                            		axdi.\0	\_
00000000                            
00000000                            addq:		macros
00000000                            		axdq.\0	\_
00000000                            
00000000                            addx:		macros
00000000                            		axdx.\0	\_
00000000                            
00000000                            andi:		macros
00000000                            		anxi.\0	\_
00000000                            
00000000                            negx:		macros
00000000                            		nxgx.\0	\_
00000000                            
00000000                            ori:		macros
00000000                            		oxi.\0	\_
00000000                            
00000000                            suba:		macros
00000000                            		sxba.\0	\_
00000000                            
00000000                            subi:		macros
00000000                            		sxbi.\0	\_
00000000                            
00000000                            subq:		macros
00000000                            		sxbq.\0	\_
00000000                            
00000000                            subx:		macros
00000000                            		sxbx.\0	\_
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Memory map (68000)
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ; ROM
00000000 =00000000                  CARTROM		EQU	$000000				; Cartridge ROM start
00000000 =003FFFFF                  CARTROM_END	EQU	$3FFFFF				; Cartridge ROM end
00000000 =00400000                  CARTROM_SIZE	EQU	(CARTROM_END+1)-CARTROM	; Cartridge ROM size
00000000                            
00000000                            ; Expansion
00000000 =00400000                  EXPANSION	EQU	$400000				; Expansion memory start
00000000 =007FFFFF                  EXPANSION_END	EQU	$7FFFFF				; Expansion memory end
00000000 =00400000                  EXPANSION_SIZE	EQU	(EXPANSION_END+1)-EXPANSION	; Expansion memory size
00000000                            
00000000                            ; Z80
00000000 =00A00000                  Z80RAM		EQU	$A00000				; Z80 RAM start
00000000 =00A01FFF                  Z80RAM_END	EQU	$A01FFF				; Z80 RAM end
00000000 =00002000                  Z80RAM_SIZE	EQU	(Z80RAM_END+1)-Z80RAM		; Z80 RAM size
00000000 =00A11100                  Z80BUS		EQU	$A11100				; Z80 bus request
00000000 =00A11200                  Z80RESET	EQU	$A11200				; Z80 reset
00000000                            
00000000                            ; Work RAM
00000000 =FFFF0000                  WORKRAM		EQU	$FFFF0000			; Work RAM start
00000000 =FFFFFFFF                  WORKRAM_END	EQU	$FFFFFFFF			; Work RAM end
00000000                            WORKRAM_SIZE	EQU	(MD_RAM_END+1)-MD_RAM		; Work RAM size
00000000                            
00000000                            ; Save RAM
00000000 =00000000                  SRAMPAD_SIZE: =	0
00000000 =00200001                  SRAM		EQU	$200001				; Save RAM start
00000000 =001FFFFF                  SRAM_END	EQU	SRAM+((SRAMPAD_SIZE-1)*2)	; Save RAM end
00000000 =00A130F1                  SRAM_ON		EQU	$A130F1				; Save RAM enable port
00000000                            
00000000                            ; Sound
00000000 =00A04000                  YMADDR0		EQU	$A04000				; YM2612 address port 0
00000000 =00A04001                  YMDATA0		EQU	$A04001				; YM2612 data port 0
00000000 =00A04002                  YMADDR1		EQU	$A04002				; YM2612 address port 1
00000000 =00A04003                  YMDATA1		EQU	$A04003				; YM2612 data port 1
00000000 =00C00011                  PSGCTRL		EQU	$C00011				; PSG control port
00000000                            
00000000                            ; VDP
00000000 =00C00000                  VDPDATA		EQU	$C00000				; VDP data port
00000000 =00C00004                  VDPCTRL		EQU	$C00004				; VDP control port
00000000 =00C00008                  VDPHV		EQU	$C00008				; VDP H/V counter
00000000 =00C0001C                  VDPDEBUG	EQU	$C0001C				; VDP debug register
00000000                            
00000000                            ; I/O
00000000 =00A10001                  VERSION		EQU	$A10001				; Hardware version
00000000 =00A10003                  IODATA1		EQU	$A10003				; I/O port 1 data port
00000000 =00A10005                  IODATA2		EQU	$A10005				; I/O port 2 data port
00000000 =00A10007                  IODATA3		EQU	$A10007				; I/O port 3 data port
00000000 =00A10009                  IOCTRL1		EQU	$A10009				; I/O port 1 control port
00000000 =00A1000B                  IOCTRL2		EQU	$A1000B				; I/O port 2 control port
00000000 =00A1000D                  IOCTRL3		EQU	$A1000D				; I/O port 3 control port
00000000                            
00000000                            ; TMSS
00000000 =00A14000                  TMSSSEGA	EQU	$A14000				; TMSS "SEGA" register
00000000 =00A14100                  TMSSMODE	EQU	$A14100				; TMSS bus mode
00000000                            
00000000                            ; Mega CD memory
00000000 =00400000                  MCDBIOS		EQU	EXPANSION			; BIOS
00000000 =00420000                  PRGRAM		EQU	EXPANSION+$20000		; Sub CPU Program RAM bank
00000000 =0043FFFF                  PRGRAM_END	EQU	EXPANSION+$3FFFF		; End of Sub CPU Program RAM bank
00000000 =00020000                  PRGRAM_SIZE	EQU	(PRGRAM_END+1)-PRGRAM		; Size of Sub CPU Program RAM bank
00000000 =00600000                  WORDRAM		EQU	EXPANSION+$200000		; Word RAM
00000000 =0063FFFF                  WORDRAM2M_END	EQU	EXPANSION+$23FFFF		; End of Word RAM (2M)
00000000 =0061FFFF                  WORDRAM1M_END	EQU	EXPANSION+$21FFFF		; End of Word RAM (1M/1M)
00000000 =00040000                  WORDRAM2M_SIZE	EQU	(WORDRAM2M_END+1)-WORDRAM	; Size of Word RAM (2M)
00000000 =00020000                  WORDRAM1M_SIZE	EQU	(WORDRAM1M_END+1)-WORDRAM	; Size of Word RAM (1M/1M)
00000000                            
00000000                            ; Mega CD registers
00000000 =00A12000                  MCDREGS		EQU	$A12000				; Registers base
00000000 =00A12000                  MCDINT2		EQU	MCDREGS+0			; Sub CPU level 2 interrupt flags
00000000 =00A12001                  MCDBUSREQ	EQU	MCDREGS+1			; Sub CPU bus request
00000000 =00A12002                  MCDPROTECT	EQU	MCDREGS+2			; Sub CPU Program RAM write protect
00000000 =00A12003                  MCDMEMMODE	EQU	MCDREGS+3			; Memory mode
00000000 =00A12004                  MCDCDCMODE	EQU	MCDREGS+4			; CDC mode
00000000 =00A12006                  MCDHINT		EQU	MCDREGS+6			; H-BLANK interrupt vector
00000000 =00A12008                  MCDCDCREAD	EQU	MCDREGS+8			; CDC host data
00000000 =00A1200C                  MCDSTOPWATCH	EQU	MCDREGS+$C			; Stop watch
00000000                            
00000000                            ; Mega CD communication (Main CPU)
00000000 =00A1200E                  MAINFLAG	EQU	MCDREGS+$E			; Main CPU flag
00000000 =00A12010                  MAINCOM0	EQU	MCDREGS+$10			; Communication command 0
00000000 =00A12010                  MAINCOM0H	EQU	MAINCOM0
00000000 =00A12011                  MAINCOM0L	EQU	MAINCOM0+1
00000000 =00A12012                  MAINCOM1	EQU	MCDREGS+$12			; Communication command 1
00000000 =00A12012                  MAINCOM1H	EQU	MAINCOM1
00000000 =00A12013                  MAINCOM1L	EQU	MAINCOM1+1
00000000 =00A12014                  MAINCOM2	EQU	MCDREGS+$14			; Communication command 2
00000000 =00A12014                  MAINCOM2H	EQU	MAINCOM2
00000000 =00A12015                  MAINCOM2L	EQU	MAINCOM2+1
00000000 =00A12016                  MAINCOM3	EQU	MCDREGS+$16			; Communication command 3
00000000 =00A12016                  MAINCOM3H	EQU	MAINCOM3
00000000 =00A12017                  MAINCOM3L	EQU	MAINCOM3+1
00000000 =00A12018                  MAINCOM4	EQU	MCDREGS+$18			; Communication command 4
00000000 =00A12018                  MAINCOM4H	EQU	MAINCOM4
00000000 =00A12019                  MAINCOM4L	EQU	MAINCOM4+1
00000000 =00A1201A                  MAINCOM5	EQU	MCDREGS+$1A			; Communication command 5
00000000 =00A1201A                  MAINCOM5H	EQU	MAINCOM5
00000000 =00A1201B                  MAINCOM5L	EQU	MAINCOM5+1
00000000 =00A1201C                  MAINCOM6	EQU	MCDREGS+$1C			; Communication command 6
00000000 =00A1201C                  MAINCOM6H	EQU	MAINCOM6
00000000 =00A1201D                  MAINCOM6L	EQU	MAINCOM6+1
00000000 =00A1201E                  MAINCOM7	EQU	MCDREGS+$1E			; Communication command 7
00000000 =00A1201E                  MAINCOM7H	EQU	MAINCOM7
00000000 =00A1201F                  MAINCOM7L	EQU	MAINCOM7+1
00000000                            
00000000                            ; Mega CD communication (Sub CPU)
00000000 =00A1200F                  SUBFLAG		EQU	MCDREGS+$F			; Sub CPU flag
00000000 =00A12020                  SUBCOM0		EQU	MCDREGS+$20			; Communication status 0
00000000 =00A12020                  SUBCOM0H	EQU	SUBCOM0
00000000 =00A12021                  SUBCOM0L	EQU	SUBCOM0+1
00000000 =00A12022                  SUBCOM1		EQU	MCDREGS+$22			; Communication status 1
00000000 =00A12022                  SUBCOM1H	EQU	SUBCOM1
00000000 =00A12023                  SUBCOM1L	EQU	SUBCOM1+1
00000000 =00A12024                  SUBCOM2		EQU	MCDREGS+$24			; Communication status 2
00000000 =00A12024                  SUBCOM2H	EQU	SUBCOM2
00000000 =00A12025                  SUBCOM2L	EQU	SUBCOM2+1
00000000 =00A12026                  SUBCOM3		EQU	MCDREGS+$26			; Communication status 3
00000000 =00A12026                  SUBCOM3H	EQU	SUBCOM3
00000000 =00A12027                  SUBCOM3L	EQU	SUBCOM3+1
00000000 =00A12028                  SUBCOM4		EQU	MCDREGS+$28			; Communication status 4
00000000 =00A12028                  SUBCOM4H	EQU	SUBCOM4
00000000 =00A12029                  SUBCOM4L	EQU	SUBCOM4+1
00000000 =00A1202A                  SUBCOM5		EQU	MCDREGS+$2A			; Communication status 5
00000000 =00A1202A                  SUBCOM5H	EQU	SUBCOM5
00000000 =00A1202B                  SUBCOM5L	EQU	SUBCOM5+1
00000000 =00A1202C                  SUBCOM6		EQU	MCDREGS+$2C			; Communication status 6
00000000 =00A1202C                  SUBCOM6H	EQU	SUBCOM6
00000000 =00A1202D                  SUBCOM6L	EQU	SUBCOM6+1
00000000 =00A1202E                  SUBCOM7		EQU	MCDREGS+$2E			; Communication status 7
00000000 =00A1202E                  SUBCOM7H	EQU	SUBCOM7
00000000 =00A1202F                  SUBCOM7L	EQU	SUBCOM7+1
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Memory map (Z80)
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ; Sound
00000000 =00004000                  ZYMADDR0	EQU	$4000				; YM2612 address port 0
00000000 =00004001                  ZYMDATA0	EQU	$4001				; YM2612 data port 0
00000000 =00004002                  ZYMADDR1	EQU	$4002				; YM2612 address port 1
00000000 =00004003                  ZYMDATA1	EQU	$4003				; YM2612 data port 1
00000000 =00007F11                  ZPSGCTRL	EQU	$7F11				; PSG control port
00000000                            
00000000                            ; Bank
00000000 =00006000                  ZBANKREG	EQU	$6000				; 68000 bank register
00000000 =00008000                  ZBANK		EQU	$8000				; 68000 bank
00000000 =00008000                  ZBANKSIZE	EQU	$8000				; Size of 68000 bank
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Constants
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =00000080                  CRAM_SIZE	EQU	16*4*2				; Size of color RAM
00000000 =00000380                  HSCROLL_SIZE	EQU	224*4				; Size of horizontal scroll data
00000000 =00000050                  VSRAM_SIZE	EQU	(320/16)*4			; Size of vertical scroll RAM
00000000 =00000280                  SPRITES_SIZE	EQU	80*8				; Size of sprite data
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Request Z80 bus access
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            Z80REQ macro
00000000                            	move.w	#$100,Z80BUS				; Request Z80 bus access
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Wait for Z80 bus request acknowledgement
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            Z80WAIT macro
00000000                            .Wait\@:
00000000                            	btst	#0,Z80BUS				; Was the request acknowledged?
00000000                            	bne.s	.Wait\@					; If not, wait
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Request Z80 bus access
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            Z80STOP macro
00000000                            	Z80REQ						; Request Z80 bus access
00000000                            	Z80WAIT						; Wait for acknowledgement
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Release the Z80 bus
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            Z80START macro
00000000                            	move.w	#0,Z80BUS				; Release the bus
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Request Z80 reset
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            Z80RESON macro
00000000                            	move.w	#0,Z80RESET				; Request Z80 reset
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Cancel Z80 reset
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            Z80RESOFF macro
00000000                            	move.w	#$100,Z80RESET				; Cancel Z80 reset
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Wait for DMA to finish
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	ctrl - (OPTIONAL) VDP control port address register
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            DMAWAIT macro ctrl
00000000                            .Wait\@:
00000000                            	if narg>0					; Is DMA active?
00000000                            		move.w	(\ctrl),ccr
00000000                            	else
00000000                            		move.w	VDPCTRL,ccr
00000000                            	endif
00000000                            	bvs.s	.Wait\@					; If so, wait
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; VDP command instruction
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	addr - Address in VDP memory
00000000                            ;	type - Type of VDP memory
00000000                            ;	rwd  - VDP command
00000000                            ;	end  - Destination, or modifier if end2 is defined
00000000                            ;	end2 - Destination if defined
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =40000000                  VRAM_WRITE	EQU	$40000000			; VRAM write
00000000 =C0000000                  CRAM_WRITE	EQU	$C0000000			; CRAM write
00000000 =40000010                  VSRAM_WRITE	EQU	$40000010			; VSRAM write
00000000 =00000000                  VRAM_READ	EQU	$00000000			; VRAM read
00000000 =00000020                  CRAM_READ	EQU	$00000020			; CRAM read
00000000 =00000010                  VSRAM_READ	EQU	$00000010			; VSRAM read
00000000 =40000080                  VRAM_DMA	EQU	VRAM_WRITE|$80			; VRAM DMA
00000000 =C0000080                  CRAM_DMA	EQU	CRAM_WRITE|$80			; CRAM DMA
00000000 =40000090                  VSRAM_DMA	EQU	VSRAM_WRITE|$80			; VSRAM DMA
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            VDPCMD macro ins, addr, type, rwd, end, end2
00000000                            	local	cmd
00000000                            	cmd: =	(\type\_\rwd\)|(((\addr)&$3FFF)<<16)|((\addr)/$4000)
00000000                            	if narg=5
00000000                            		\ins	#$\$cmd,\end
00000000                            	elseif narg>=6
00000000                            		\ins	#$\$cmd\\end,\end2
00000000                            	else
00000000                            		\ins	$\$cmd
00000000                            	endif
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; VDP DMA from 68000 memory to VDP memory
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	src  - Source address in 68000 memory
00000000                            ;	dest - Destination address in VDP memory
00000000                            ;	len  - Length of data in bytes
00000000                            ;	type - Type of VDP memory
00000000                            ;	ctrl - (OPTIONAL) VDP control port address register
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            DMA68K macro src, dest, len, type, ctrl
00000000                            	if narg>4
00000000                            		move.l	#$94009300|((((\len)/2)&$FF00)<<8)|(((\len)/2)&$FF),(\ctrl)
00000000                            		move.l	#$96009500|((((\src)/2)&$FF00)<<8)|(((\src)/2)&$FF),(\ctrl)
00000000                            		move.w	#$9700|(((\src)>>17)&$7F),(\ctrl)
00000000                            		VDPCMD	move.w,\dest,\type,DMA,>>16,(\ctrl)
00000000                            		VDPCMD	move.w,\dest,\type,DMA,&$FFFF,-(sp)
00000000                            		move.w	(sp)+,(\ctrl)
00000000                            	else
00000000                            		move.l	#$94009300|((((\len)/2)&$FF00)<<8)|(((\len)/2)&$FF),VDPCTRL
00000000                            		move.l	#$96009500|((((\src)/2)&$FF00)<<8)|(((\src)/2)&$FF),VDPCTRL
00000000                            		move.w	#$9700|(((\src)>>17)&$7F),VDPCTRL
00000000                            		VDPCMD	move.w,\dest,\type,DMA,>>16,VDPCTRL
00000000                            		VDPCMD	move.w,\dest,\type,DMA,&$FFFF,-(sp)
00000000                            		move.w	(sp)+,VDPCTRL
00000000                            	endif
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; VDP DMA fill VRAM with byte
00000000                            ; Auto-increment should be set to 1 beforehand
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	byte - Byte to fill VRAM with
00000000                            ;	addr - Address in VRAM
00000000                            ;	len  - Length of fill in bytes
00000000                            ;	ctrl - (OPTIONAL) VDP control port address register
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            DMAFILL macro byte, addr, len, ctrl
00000000                            	if narg>3
00000000                            		move.l	#$94009300|((((\len)-1)&$FF00)<<8)|(((\len)-1)&$FF),(\ctrl)
00000000                            		move.w	#$9780,(\ctrl)
00000000                            		move.l	#$40000080|(((\addr)&$3FFF)<<16)|(((\addr)&$C000)>>14),(\ctrl)
00000000                            		move.w	#(\byte)<<8,-4(\ctrl)
00000000                            		DMAWAIT	\ctrl
00000000                            	else
00000000                            		move.l	#$94009300|((((\len)-1)&$FF00)<<8)|(((\len)-1)&$FF),VDPCTRL
00000000                            		move.w	#$9780,VDPCTRL
00000000                            		move.l	#$40000080|(((\addr)&$3FFF)<<16)|(((\addr)&$C000)>>14),VDPCTRL
00000000                            		move.w	#(\byte)<<8,VDPDATA
00000000                            		DMAWAIT
00000000                            	endif
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; VDP DMA copy region of VRAM to another location in VRAM
00000000                            ; Auto-increment should be set to 1 beforehand
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	src  - Source address in VRAM
00000000                            ;	dest - Destination address in VRAM
00000000                            ;	len  - Length of copy in bytes
00000000                            ;	ctrl - (OPTIONAL) VDP control port address register
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            DMACOPY macro src, dest, len, ctrl
00000000                            	if narg>3
00000000                            		move.l	#$94009300|((((\len)-1)&$FF00)<<8)|(((\len)-1)&$FF),(\ctrl)
00000000                            		move.l	#$96009500|(((\src)&$FF00)<<8)|((\src)&$FF),(\ctrl)
00000000                            		move.w	#$97C0,(\ctrl)
00000000                            		move.l	#$0000C0|(((\dest)&$3FFF)<<16)|(((\dest)&$C000)>>14),(\ctrl)
00000000                            		DMAWAIT	\ctrl
00000000                            	else
00000000                            		move.l	#$94009300|((((\len)-1)&$FF00)<<8)|(((\len)-1)&$FF),VDPCTRL
00000000                            		move.l	#$96009500|(((\src)&$FF00)<<8)|((\src)&$FF),VDPCTRL
00000000                            		move.w	#$97C0,VDPCTRL
00000000                            		move.l	#$0000C0|(((\dest)&$3FFF)<<16)|(((\dest)&$C000)>>14),VDPCTRL
00000000                            		DMAWAIT
00000000                            	endif
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            	include	"debugger.i"
00000000                            
00000000                            ; ===============================================================
00000000                            ; ---------------------------------------------------------------
00000000                            ; Error handling and debugging modules
00000000                            ; 2016-2017, Vladikcomper
00000000                            ; ---------------------------------------------------------------
00000000                            ; Debugging macros definitions file
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000                            ; ===============================================================
00000000                            ; ---------------------------------------------------------------
00000000                            ; Constants
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000                            ; ----------------------------
00000000                            ; Arguments formatting flags
00000000                            ; ----------------------------
00000000                            
00000000                            ; General arguments format flags
00000000 =00000080                  fhex	equ		$80				; flag to display as hexadecimal number
00000000 =00000090                  fdec	equ		$90				; flag to display as decimal number
00000000 =000000A0                  fbin	equ		$A0				; flag to display as binary number
00000000 =000000B0                  fsym	equ		$B0				; flag to display as symbol (treat as offset, decode into symbol +displacement, if present)
00000000 =000000C0                  fsymdsp	equ		$C0				; flag to display as symbol's displacement alone (DO NOT USE, unless complex formatting is required, see notes below)
00000000 =000000D0                  fstr	equ		$D0				; flag to display as string (treat as offset, insert string from that offset)
00000000                            
00000000                            ; NOTES:
00000000                            ;	* By default, the "sym" flag displays both symbol and displacement (e.g.: "Map_Sonic+$2E")
00000000                            ;		In case, you need a different formatting for the displacement part (different text color and such),
00000000                            ;		use "sym|split", so the displacement won't be displayed until symdsp is met
00000000                            ;	* The "symdsp" can only be used after the "sym|split" instance, which decodes offset, otherwise, it'll
00000000                            ;		display a garbage offset.
00000000                            ;	* No other argument format flags (hex, dec, bin, str) are allowed between "sym|split" and "symdsp",
00000000                            ;		otherwise, the "symdsp" results are undefined.
00000000                            ;	* When using "str" flag, the argument should point to string offset that will be inserted.
00000000                            ;		Arguments format flags CAN NOT be used in the string (as no arguments are meant to be here),
00000000                            ;		only console control flags (see below).
00000000                            
00000000                            
00000000                            ; Additional flags ...
00000000                            ; ... for number formatters (hex, dec, bin)
00000000 =00000008                  signed	equ		8				; treat number as signed (display + or - before the number depending on sign)
00000000                            
00000000                            ; ... for symbol formatter (sym)
00000000 =00000008                  split	equ		8				; DO NOT write displacement (if present), skip and wait for "symdsp" flag to write it later (optional)
00000000 =00000004                  forced	equ		4				; display "<unknown>" if symbol was not found, otherwise, plain offset is displayed by the displacement formatter
00000000                            
00000000                            ; ... for symbol displacement formatter (symdsp)
00000000 =00000008                  weak	equ		8				; DO NOT write plain offset if symbol is displayed as "<unknown>"
00000000                            
00000000                            ; Argument type flags:
00000000                            ; - DO NOT USE in formatted strings processed by macros, as these are included automatically
00000000                            ; - ONLY USE when writting down strings manually with DC.B
00000000 =00000000                  byte	equ		0
00000000 =00000001                  word	equ		1
00000000 =00000003                  long	equ		3
00000000                            
00000000                            ; -----------------------
00000000                            ; Console control flags
00000000                            ; -----------------------
00000000                            
00000000                            ; Plain control flags: no arguments following
00000000 =000000E0                  endl	equ		$E0				; "End of line": flag for line break
00000000 =000000E6                  cr	equ		$E6				; "Carriage return": jump to the beginning of the line
00000000 =000000E8                  pal0	equ		$E8				; use palette line #0
00000000 =000000EA                  pal1	equ		$EA				; use palette line #1
00000000 =000000EC                  pal2	equ		$EC				; use palette line #2
00000000 =000000EE                  pal3	equ		$EE				; use palette line #3
00000000                            
00000000                            ; Parametrized control flags: followed by 1-byte argument
00000000 =000000F0                  setw	equ		$F0				; set line width: number of characters before automatic line break
00000000 =000000F4                  setoff	equ		$F4				; set tile offset: lower byte of base pattern, which points to tile index of ASCII character 00
00000000 =000000F8                  setpat	equ		$F8				; set tile pattern: high byte of base pattern, which determines palette flags and $100-tile section id
00000000 =000000FA                  setx	equ		$FA				; set x-position
00000000                            
00000000                            
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            ; Macros
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000                            RaiseError &
00000000                            
00000000                            	pea		*(pc)
00000000                            	move.w	sr, -(sp)
00000000                            	__FSTRING_GenerateArgumentsCode \string
00000000                            	jsr		ErrorHandler
00000000                            	__FSTRING_GenerateDecodedString \string
00000000                            	if strlen("\console_program")			; if console program offset is specified ...
00000000                            		dc.b	\opts+_eh_enter_console|(((*&1)^1)*_eh_align_offset)	; add flag "_eh_align_offset" if the next byte is at odd offset ...
00000000                            		even															; ... to tell Error handler to skip this byte, so it'll jump to ...
00000000                            		jmp		\console_program										; ... an aligned "jmp" instruction that calls console program itself
00000000                            	else
00000000                            		dc.b	\opts+0						; otherwise, just specify \opts for error handler, +0 will generate dc.b 0 ...
00000000                            		even								; ... in case \opts argument is empty or skipped
00000000                            	endc
00000000                            	even
00000000                            
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            Console &
00000000                            
00000000                            	if strcmp("\0","write")|strcmp("\0","writeline")
00000000                            		move.w	sr, -(sp)
00000000                            		__FSTRING_GenerateArgumentsCode \1
00000000                            		movem.l	a0-a2/d7, -(sp)
00000000                            		if (__sp>0)
00000000                            			lea		4*4(sp), a2
00000000                            		endc
00000000                            		lea		@str\@(pc), a1
00000000                            		jsr		ErrorHandler.__global__console_\0\_formatted
00000000                            		movem.l	(sp)+, a0-a2/d7
00000000                            		if (__sp>8)
00000000                            			lea		__sp(sp), sp
00000000                            		elseif (__sp>0)
00000000                            			addq.w	#__sp, sp
00000000                          M 	axdq.w	#__sp,sp
00000000                            		endc
00000000                            		move.w	(sp)+, sr
00000000                            		bra.w	@instr_end\@
00000000                            	@str\@:
00000000                            		__FSTRING_GenerateDecodedString \1
00000000                            		even
00000000                            	@instr_end\@:
00000000                            
00000000                            	elseif strcmp("\0","run")
00000000                            		jsr		ErrorHandler.__extern__console_only
00000000                            		jsr		\1
00000000                            		bra.s	*
00000000                            
00000000                            	elseif strcmp("\0","setxy")
00000000                            		move.w	sr, -(sp)
00000000                            		movem.l	d0-d1, -(sp)
00000000                            		move.w	\2, -(sp)
00000000                            		move.w	\1, -(sp)
00000000                            		jsr		ErrorHandler.__global__console_setposasxy_stack
00000000                            		addq.w	#4, sp
00000000                          M 	axdq.w	#4,sp
00000000                            		movem.l	(sp)+, d0-d1
00000000                            		move.w	(sp)+, sr
00000000                            
00000000                            	elseif strcmp("\0","breakline")
00000000                            		move.w	sr, -(sp)
00000000                            		jsr		ErrorHandler.__global__console_startnewline
00000000                            		move.w	(sp)+, sr
00000000                            
00000000                            	else
00000000                            		inform	2,"""\0"" isn't a member of ""Console"""
00000000                            
00000000                            	endc
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            __ErrorMessage &
00000000                            		__FSTRING_GenerateArgumentsCode \string
00000000                            		jsr		ErrorHandler
00000000                            		__FSTRING_GenerateDecodedString \string
00000000                            		dc.b	\opts+0
00000000                            		even
00000000                            
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            __FSTRING_GenerateArgumentsCode &
00000000                            
00000000                            	__pos:	set 	instr(\string,'%<')		; token position
00000000                            	__stack:set		0						; size of actual stack
00000000                            	__sp:	set		0						; stack displacement
00000000                            
00000000                            	; Parse string itself
00000000                            	while (__pos)
00000000                            
00000000                            		; Retrive expression in brackets following % char
00000000                                	__endpos:	set		instr(__pos+1,\string,'>')
00000000                                	__midpos:	set		instr(__pos+5,\string,' ')
00000000                                	if (__midpos<1)|(__midpos>__endpos)
00000000                            			__midpos: = __endpos
00000000                                	endc
00000000                            		__substr:	substr	__pos+1+1,__endpos-1,\string			; .type ea param
00000000                            		__type:		substr	__pos+1+1,__pos+1+1+1,\string			; .type
00000000                            
00000000                            		; Expression is an effective address (e.g. %(.w d0 hex) )
00000000                            		if "\__type">>8="."
00000000                            			__operand:	substr	__pos+1+1,__midpos-1,\string			; .type ea
00000000                            			__param:	substr	__midpos+1,__endpos-1,\string			; param
00000000                            
00000000                            			if "\__type"=".b"
00000000                            				pushp	"move\__operand\,1(sp)"
00000000                            				pushp	"subq.w	#2, sp"
00000000                            				__stack: = __stack+2
00000000                            				__sp: = __sp+2
00000000                            
00000000                            			elseif "\__type"=".w"
00000000                            				pushp	"move\__operand\,-(sp)"
00000000                            				__stack: = __stack+1
00000000                            				__sp: = __sp+2
00000000                            
00000000                            			elseif "\__type"=".l"
00000000                            				pushp	"move\__operand\,-(sp)"
00000000                            				__stack: = __stack+1
00000000                            				__sp: = __sp+4
00000000                            
00000000                            			else
00000000                            				fatal 'Unrecognized type in string operand: %<\__substr>'
00000000                            			endc
00000000                            		endc
00000000                            
00000000                            		__pos:	set		instr(__pos+1,\string,'%<')
00000000                            	endw
00000000                            
00000000                            	; Generate stack code
00000000                            	rept __stack
00000000                            		popp	__command
00000000                            		\__command
00000000                            	endr
00000000                            
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            __FSTRING_GenerateDecodedString &
00000000                            
00000000                            	__lpos:	set		1						; start position
00000000                            	__pos:	set 	instr(\string,'%<')		; token position
00000000                            
00000000                            	while (__pos)
00000000                            
00000000                            		; Write part of string before % token
00000000                            		__substr:	substr	__lpos,__pos-1,\string
00000000                            		dc.b	"\__substr"
00000000                            
00000000                            		; Retrive expression in brakets following % char
00000000                                	__endpos:	set		instr(__pos+1,\string,'>')
00000000                                	__midpos:	set		instr(__pos+5,\string,' ')
00000000                                	if (__midpos<1)|(__midpos>__endpos)
00000000                            			__midpos: = __endpos
00000000                                	endc
00000000                            		__type:		substr	__pos+1+1,__pos+1+1+1,\string			; .type
00000000                            
00000000                            		; Expression is an effective address (e.g. %<.w d0 hex> )
00000000                            		if "\__type">>8="."    
00000000                            			__param:	substr	__midpos+1,__endpos-1,\string			; param
00000000                            			if strlen("\__param")<1
00000000                            				__param: substr ,,"hex"			; if param is ommited, set it to "hex"
00000000                            			endc
00000000                            			if "\__type"=".b"
00000000                            				dc.b	f\__param
00000000                            			elseif "\__type"=".w"
00000000                            				dc.b	f\__param|1
00000000                            			else
00000000                            				dc.b	f\__param|3
00000000                            			endc
00000000                            
00000000                            		; Expression is an inline constant (e.g. %<endl> )
00000000                            		else
00000000                            			__substr:	substr	__pos+1+1,__endpos-1,\string
00000000                            			dc.b	\__substr
00000000                            		endc
00000000                            
00000000                            		__lpos:	set		__endpos+1
00000000                            		__pos:	set		instr(__pos+1,\string,'%<')
00000000                            	endw
00000000                            
00000000                            	; Write part of string before the end
00000000                            	__substr:	substr	__lpos,,\string
00000000                            	dc.b	"\__substr"
00000000                            	dc.b	0
00000000                            
00000000                            	endm
00000000                            	include	"variables.i"
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Mega Drive Framework
00000000                            ; By Devon 2022
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; RAM map/variables
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	include	"_inc/dma.i"
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Mega Drive Framework
00000000                            ; By Devon 2022
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; DMA definitions
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Ultra DMA Queue by Flamewing
00000000                            ; https://github.com/flamewing/ultra-dma-queue
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Options
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; This option makes the function work as a drop-in replacement of the original
00000000                            ; functions. If you modify all callers to supply a position in words instead of
00000000                            ; bytes (i.e., divide source address by 2) you can set this to 0 to gain 10(1/0)
00000000 =00000001                  DMA_SRC_BYTES		EQU	1
00000000                            
00000000                            ; This option (which is disabled by default) makes the DMA queue assume that the
00000000                            ; source address is given to the function in a way that makes them safe to use
00000000                            ; with RAM sources. You need to edit all callers to ensure this.
00000000                            ; Enabling this option turns off DMA_RAM_SAFE_USE, and saves 14(2/0).
00000000 =00000000                  DMA_RAM_SAFE		EQU	0
00000000                            
00000000                            ; This option (which is enabled by default) makes source addresses in RAM safe
00000000                            ; at the cost of 14(2/0). If you modify all callers so as to clear the top byte
00000000                            ; of source addresses (i.e., by ANDing them with $FFFFFF).
00000000 =00000001                  DMA_RAM_SAFE_USE	EQU	1&(DMA_RAM_SAFE=0)
00000000                            
00000000                            ; This option breaks DMA transfers that crosses a 128kB block into two. It is
00000000                            ; disabled by default because you can simply align the art in ROM and avoid the
00000000                            ; issue altogether. It is here so that you have a high-performance routine to do
00000000                            ; the job in situations where you can't align it in ROM.
00000000 =00000000                  DMA_128KB_SAFE		EQU	0
00000000                            
00000000                            ; Option to mask interrupts while updating the DMA queue. This fixes many race
00000000                            ; conditions in the DMA funcion, but it costs 46(6/1) cycles. The better way to
00000000                            ; handle these race conditions would be to make unsafe callers (such as S3&K's
00000000                            ; KosM decoder) prevent these by masking off interrupts before calling and then
00000000                            ; restore interrupts after.
00000000 =00000000                  DMA_VINT_SAFE		EQU	0
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; DMA entry slot structure
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsreset
00000000 =00000000                  dmaSlotReg94	rs.b	1				; Size (high) register ID
00000000 =00000001                  dmaSlotSize	rs.b	0				; Size register data start
00000000 =00000001                  dmaSlotSizeH	rs.b	1				; Size (high) register data
00000000 =00000002                  dmaSlotReg93	rs.b	1				; Size (low) register ID
00000000 =00000003                  dmaSlotSrc	rs.b	0				; Source register data start
00000000 =00000003                  dmaSlotSizeL	rs.b	1				; Size (low) register data
00000000                            
00000000 =00000004                  dmaSlotReg97	rs.b	1				; Source (high) register ID
00000000 =00000005                  dmaSlotSrcH	rs.b	1				; Source (high) register data
00000000 =00000006                  dmaSlotReg96	rs.b	1				; Source (middle) register ID
00000000 =00000007                  dmaSlotSrcM	rs.b	1				; Source (middle) register data
00000000 =00000008                  dmaSlotReg95	rs.b	1				; Source (low) register ID
00000000 =00000009                  dmaSlotSrcL	rs.b	1				; Source (low) register data
00000000                            
00000000 =0000000A                  dmaSlotCmd	rs.l	1				; VDP command
00000000 =0000000E                  dmaSlotLen	rs.b	0				; Size of structure
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Constants
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =00000012                  DMASLOT_COUNT	EQU	$12				; Number of DMA entry slots
00000000 =000000FC                  DMAQUEUE_SIZE	EQU	DMASLOT_COUNT*dmaSlotLen	; Size of DMA queue
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Convert VDP address in register to VDP command
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	reg   - Register containing source address in 68000 memory
00000000                            ;	type  - Type of VDP memory
00000000                            ;	rwd   - VDP command
00000000                            ;	clear - Mask out garbage bits
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            VDPCMDR macro reg, type, rwd, clear
00000000                            	local	upperbits, lowerbits
00000000                            	lsl.l	#2,\reg					; Move high bits into (word-swapped) position, accidentally moving everything else
00000000                            	upperbits: EQU	(\type\_\rwd\)>>30
00000000                            	if upperbits<>0
00000000                            		addq.w	#upperbits,\reg			; Add upper access type bits
00000000                          M 	axdq.w	#upperbits,\reg
00000000                            	endif
00000000                            	
00000000                            	ror.w	#2,\reg					; Put upper access type bits into place, also moving all other bits into their correct (word-swapped) places
00000000                            	swap	\reg					; Put all bits in proper places
00000000                            	if (\clear)<>0
00000000                            		andi.w	#3,\reg				; Strip whatever junk was in upper word of reg
00000000                          M 	anxi.w	#3,\reg
00000000                            	endif
00000000                            
00000000                            	lowerbits: EQU	(\type\_\rwd\)&$F0
00000000                            	if lowerbits=$80
00000000                            		tas.b	\reg				; Add in the DMA flag -- tas fails on memory, but works on registers
00000000                            	elseif lowerbits<>0
00000000                            		ori.w	#(lowerbits<<2),\reg		; Add in missing access type bits
00000000                          M 	oxi.w	#(lowerbits<<2),\reg
00000000                            	endif
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Clears the DMA queue, discarding all previously-queued DMAs.
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            RESETDMA macro
00000000                            	move.w	#dma_queue,dma_queue_cur.w
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Directly queues a DMA on the spot. Requires all parameters to be known at
00000000                            ; assembly time; that is, no registers. Gives assembly errors when the DMA
00000000                            ; crosses a 128kB boundary, is at an odd ROM location, or is zero length.
00000000                            ; Expects source address and DMA length in bytes. Also, expects source, size,
00000000                            ; and dest to be known at assembly time. Gives errors if DMA starts at an
00000000                            ; odd address, transfers crosses a 128kB boundary, or has size 0.
00000000                            ;
00000000                            ; With the default settings, runs in:
00000000                            ; * 32(7/0) cycles if queue is full (DMA discarded)
00000000                            ; * 122(21/8) cycles otherwise (DMA queued)
00000000                            ; Passing a register as destination is faster by 8(2/0) when the DMA is queued,
00000000                            ; but requires initializing the register elsewhere, which is probably slower.
00000000                            ;
00000000                            ; Setting DMA_VINT_SAFE to 1 adds 46(6/1) cycles to both cases.
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; The destination parameter can be either:
00000000                            ;	- A VRAM address literal
00000000                            ;	- A register initialized with `VDPCMD move.l,dest,VRAM,DMA`
00000000                            ;	- A register initialized with `vdpCommReg <reg>,VRAM,DMA`
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; OPTIONS:
00000000                            ; 	DMA_VINT_SAFE (default 0)
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ; 	src    - Source address (in bytes)
00000000                            ;	length - transfer length (in bytes)
00000000                            ;	dest   - destination address
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            DMAIMM macro src, length, dest
00000000                            	if ((\src)&1)<>0
00000000                            		inform 3,"DMA queued from odd source $%h!", src
00000000                            	endif
00000000                            	if ((\length)&1)<>0
00000000                            		inform 3,"DMA an odd number of bytes $%h!", length
00000000                            	endif
00000000                            	if (\length)=0
00000000                            		inform 3,"DMA transferring 0 bytes (becomes a 128kB transfer). If you really mean it, pass 128kB instead."
00000000                            	endif
00000000                            	if (((\src)+(\length)-1)>>17)<>((\src)>>17)
00000000                            		inform 3,"DMA crosses a 128kB boundary. You should either split the DMA manually or align the source adequately."
00000000                            	endif
00000000                            
00000000                            	if DMA_VINT_SAFE=1
00000000                            		move.w	sr,-(sp)			; Save current interrupt mask
00000000                            		move	#$2700,sr			; Mask off interrupts
00000000                            	endif	; DMA_VINT_SAFE=1
00000000                            
00000000                            	movea.w	dma_queue_cur.w,a1
00000000                            	cmpa.w	#dma_queue_cur,a1
00000000                            	beq.s	.done					; Return if there's no more room in the buffer
00000000                            	move.b	#((\length)>>8)&$7F,dmaSlotSizeH(a1)	; Write top byte of size/2
00000000                            							; Set d0 to bottom byte of size/2 and the low 3 bytes of source/2
00000000                            	move.l	#(((\length)&$FF)<<24)|(((\src)>>1)&$7FFFFF),d0
00000000                            	movep.l	d0,dmaSlotSizeL(a1)			; Write it all to the queue
00000000                            	lea	dmaSlotCmd(a1),a1			; Seek to correct RAM address to store VDP DMA command
00000000                            
00000000                            	ISDREG	\dest
00000000                            	if is_reg
00000000                            		move.l	\dest,(a1)+
00000000                            	else
00000000                            		VDPCMD	move.l,\dest,VRAM,DMA,(a1)+	; Write VDP DMA command for destination address
00000000                            	endif
00000000                            
00000000                            	move.w	a1,dma_queue_cur.w			; Write next queue slot
00000000                            .done:
00000000                            	if DMA_VINT_SAFE=1
00000000                            		move.w	(sp)+,sr			; Restore interrupts to previous state
00000000                            	endif	; DMA_VINT_SAFE=1
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Work RAM layout
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset	WORKRAM
00000000                            
00000000                            ; Global program variables
00000000 =FFFF0000                  global_vars	rs.b	0
00000000                            		include	"_globalvars.i"
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Mode 1 Demo
00000000                            ; By Devon 2022
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	RSPUSH
00000000 =FFFF0000                M 	rsstackval0:	= __rs
00000000 =00000001                M 	rsstack:	= rsstack+1
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Variables
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	RSPOP
00000000 =00000000                M 	rsstack:	= rsstack-1
00000000                          M 	rsset	rsstackval0
00000000 =FFFF0000                  buffer		rs.b	$8000				; General buffer
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000 =FFFF8000                  global_vars_end	rs.b	0
00000000                            
00000000                            ; Framework variables
00000000 =FFFF8000                  palette		rs.b	CRAM_SIZE			; Palette buffer
00000000 =FFFF8080                  hscroll		rs.b	HSCROLL_SIZE			; Horizontal scroll buffer
00000000 =FFFF8400                  vscroll		rs.b	VSRAM_SIZE			; Vertical scroll buffer
00000000 =FFFF8450                  sprites		rs.b	SPRITES_SIZE			; Sprite buffer
00000000                            
00000000 =FFFF86D0                  dma_queue	rs.b	DMAQUEUE_SIZE			; DMA queue
00000000 =FFFF87CC                  dma_queue_cur	rs.w	1				; DMA queue cursor
00000000                            
00000000 =FFFF87CE                  external_int	rs.b	6				; External interrupt jump opcode
00000000 =FFFF87D4                  hblank_int	rs.b	6				; H-BLANK interrupt jump opcode
00000000 =FFFF87DA                  vblank_int	rs.b	6				; V-BLANK interrupt jump opcode
00000000                            
00000000 =FFFF87E0                  console_ver	rs.b	1				; Console version
00000000                            
00000000 =FFFF87E1                  mcd_found	rs.b	1				; Found Mega CD flag
00000000 =FFFF87E2                  mcd_sub_bios	rs.l	1				; Found Mega CD Sub CPU BIOS
00000000                            
00000000                            ; Saved program variables
00000000 =FFFF87E6                  saved_vars	rs.b	0
00000000 =FFFF87E6                  initialized	rs.l	1				; Initialized flag
00000000 =FFFF87EA                  saved_vars_end	rs.b	0
00000000                            
00000000                            ; Local program variables
00000000 =FFFF87EA                  local_vars	rs.b	(WORKRAM+$FF00)-__rs
00000000 =FFFFFF00                  local_vars_end	rs.b	0
00000000                            
00000000                            ; Stack
00000000 =FFFFFF00                  stack		rs.b	$100
00000000 =00000000                  stack_base	rs.b	0
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Vector table
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	ORG	CARTROM
00000000                            	CPU	68000
00000000 =00000000                M 	cpu_mode:	= 0
00000000                            
00000000 0000 0000                  	dc.l	stack_base				; Stack pointer
00000004 0000 0000                  	dc.l	Initialize				; Program start
00000008                            
00000008 0000 0000                  	dc.l	BusError				; Bus error
0000000C 0000 0000                  	dc.l	AddressError				; Address error
00000010 0000 0000                  	dc.l	IllegalInstr				; Illegal instruction
00000014 0000 0000                  	dc.l	ZeroDivide				; Division by zero
00000018 0000 0000                  	dc.l	ChkInstr				; CHK exception
0000001C 0000 0000                  	dc.l	TrapvInstr				; TRAPV exception
00000020 0000 0000                  	dc.l	PrivilegeViol				; Privilege violation
00000024 0000 0000                  	dc.l	Trace					; TRACE exception
00000028 0000 0000                  	dc.l	Line1010Emu				; Line-A emulator
0000002C 0000 0000                  	dc.l	Line1111Emu				; Line-F emulator
00000030                            
00000030                            	dcb.l	12, ErrorExcept				; Reserved
00000060                            
00000060 0000 0000                  	dc.l	ErrorExcept				; Spurious exception
00000064 0000 0000                  	dc.l	ErrorExcept				; IRQ1
00000068 FFFF 87CE                  	dc.l	external_int				; External interrupt
0000006C 0000 0000                  	dc.l	ErrorExcept				; IRQ3
00000070 FFFF 87D4                  	dc.l	hblank_int				; H-BLANK interrupt
00000074 0000 0000                  	dc.l	ErrorExcept				; IRQ5
00000078 FFFF 87DA                  	dc.l	VBlank_int				; V-BLANK interrupt
0000007C 0000 0000                  	dc.l	ErrorExcept				; IRQ7
00000080                            
00000080 0000 0000                  	dc.l	ErrorExcept				; TRAP #00
00000084 0000 0000                  	dc.l	ErrorExcept				; TRAP #01
00000088 0000 0000                  	dc.l	ErrorExcept				; TRAP #02
0000008C 0000 0000                  	dc.l	ErrorExcept				; TRAP #03
00000090 0000 0000                  	dc.l	ErrorExcept				; TRAP #04
00000094 0000 0000                  	dc.l	ErrorExcept				; TRAP #05
00000098 0000 0000                  	dc.l	ErrorExcept				; TRAP #06
0000009C 0000 0000                  	dc.l	ErrorExcept				; TRAP #07
000000A0 0000 0000                  	dc.l	ErrorExcept				; TRAP #08
000000A4 0000 0000                  	dc.l	ErrorExcept				; TRAP #09
000000A8 0000 0000                  	dc.l	ErrorExcept				; TRAP #10
000000AC 0000 0000                  	dc.l	ErrorExcept				; TRAP #11
000000B0 0000 0000                  	dc.l	ErrorExcept				; TRAP #12
000000B4 0000 0000                  	dc.l	ErrorExcept				; TRAP #13
000000B8 0000 0000                  	dc.l	ErrorExcept				; TRAP #14
000000BC 0000 0000                  	dc.l	ErrorExcept				; TRAP #15
000000C0                            
000000C0                            	dcb.l	16, ErrorExcept				; Reserved
00000100                            
00000100                            ; ---------------------------------------------------------------------------
00000100                            ; ROM header
00000100                            ; ---------------------------------------------------------------------------
00000100                            
00000100 5345 4741 204D 4547 4120+  	dc.b	"SEGA MEGA DRIVE "			; Hardware ID
00000110                            
00000110                            	STRSZ	7, "\COPYRIGHT"				; Copyright
00000110                          M 	local	len2,str2
00000110 =00000005                M 	len2:	= strlen("DEVON")
00000110                          M 	str2:	equs "DEVON"
00000110 4445 564F 4E             M 	dc.b	"DEVON"
00000115 2020                     M 	dcb.b	(7)-len2," "
00000117 20                         	dc.b	" "
00000118                            	NUMSTR	4, _year+1900
00000118                          M 	local	num2,dig2,mask
00000118 =000007E6                M 	num2:	= _year+1900
00000118 =00000001                M 	dig2:	= 1
00000118 =0000000A                M 	mask:	= 10
00000118                          M 	while	(num2<>0)&(dig2<(4))
00000118 =000000CA                M 	num2:	= num2/10
00000118 =00000064                M 	mask:	= mask*10
00000118 =00000002                M 	dig2:	= dig2+1
00000118 =00000014                M 	num2:	= num2/10
00000118 =000003E8                M 	mask:	= mask*10
00000118 =00000003                M 	dig2:	= dig2+1
00000118 =00000002                M 	num2:	= num2/10
00000118 =00002710                M 	mask:	= mask*10
00000118 =00000004                M 	dig2:	= dig2+1
00000118 =000007E6                M 	num2:	= (_year+1900)%mask
00000118                          M 	dcb.b	(4)-strlen("2022"),"0"
00000118 3230 3232                M 	dc.b	"2022"
0000011C 2E                         	dc.b	"."
0000011D                            	MTHSTR	_month
0000011D                          M 	local	mth
0000011D                          M 	mth:	substr 1+(((_month)-1)*3),3+(((_month)-1)*3),"JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC"
0000011D 4D41 59                  M 	dc.b	"MAY"
00000120                            
00000120                            		STRSZ	$20, "\GAME_NAME"
00000120                          M 	local	len2,str2
00000120 =0000001C                M 	len2:	= strlen("MEGA CD MODE 1 DEMO BY DEVON")
00000120                          M 	str2:	equs "MEGA CD MODE 1 DEMO BY DEVON"
00000120 4D45 4741 2043 4420 4D4F+M 	dc.b	"MEGA CD MODE 1 DEMO BY DEVON"
0000013C 2020 2020                M 	dcb.b	($20)-len2," "
00000140                            		BUILDDATE
00000140                          M 	numstr	4,_year+1900
00000140                          M 	local	num2,dig2,mask
00000140 =000007E6                M 	num2:	= _year+1900
00000140 =00000001                M 	dig2:	= 1
00000140 =0000000A                M 	mask:	= 10
00000140                          M 	while	(num2<>0)&(dig2<(4))
00000140 =000000CA                M 	num2:	= num2/10
00000140 =00000064                M 	mask:	= mask*10
00000140 =00000002                M 	dig2:	= dig2+1
00000140 =00000014                M 	num2:	= num2/10
00000140 =000003E8                M 	mask:	= mask*10
00000140 =00000003                M 	dig2:	= dig2+1
00000140 =00000002                M 	num2:	= num2/10
00000140 =00002710                M 	mask:	= mask*10
00000140 =00000004                M 	dig2:	= dig2+1
00000140 =000007E6                M 	num2:	= (_year+1900)%mask
00000140                          M 	dcb.b	(4)-strlen("2022"),"0"
00000140 3230 3232                M 	dc.b	"2022"
00000144 2F                       M 	dc.b	"/"
00000145                          M 	numstr	2,_month
00000145                          M 	local	num2,dig2,mask
00000145 =00000005                M 	num2:	= _month
00000145 =00000001                M 	dig2:	= 1
00000145 =0000000A                M 	mask:	= 10
00000145                          M 	while	(num2<>0)&(dig2<(2))
00000145 =00000000                M 	num2:	= num2/10
00000145 =00000064                M 	mask:	= mask*10
00000145 =00000002                M 	dig2:	= dig2+1
00000145 =00000005                M 	num2:	= (_month)%mask
00000145 30                       M 	dcb.b	(2)-strlen("5"),"0"
00000146 35                       M 	dc.b	"5"
00000147 2F                       M 	dc.b	"/"
00000148                          M 	numstr	2,_day
00000148                          M 	local	num2,dig2,mask
00000148 =00000014                M 	num2:	= _day
00000148 =00000001                M 	dig2:	= 1
00000148 =0000000A                M 	mask:	= 10
00000148                          M 	while	(num2<>0)&(dig2<(2))
00000148 =00000002                M 	num2:	= num2/10
00000148 =00000064                M 	mask:	= mask*10
00000148 =00000002                M 	dig2:	= dig2+1
00000148 =00000014                M 	num2:	= (_day)%mask
00000148                          M 	dcb.b	(2)-strlen("20"),"0"
00000148 3230                     M 	dc.b	"20"
0000014A 20                       M 	dc.b	" "
0000014B                          M 	numstr	2,_hours
0000014B                          M 	local	num2,dig2,mask
0000014B =00000011                M 	num2:	= _hours
0000014B =00000001                M 	dig2:	= 1
0000014B =0000000A                M 	mask:	= 10
0000014B                          M 	while	(num2<>0)&(dig2<(2))
0000014B =00000001                M 	num2:	= num2/10
0000014B =00000064                M 	mask:	= mask*10
0000014B =00000002                M 	dig2:	= dig2+1
0000014B =00000011                M 	num2:	= (_hours)%mask
0000014B                          M 	dcb.b	(2)-strlen("17"),"0"
0000014B 3137                     M 	dc.b	"17"
0000014D 3A                       M 	dc.b	":"
0000014E                          M 	numstr	2,_minutes
0000014E                          M 	local	num2,dig2,mask
0000014E =00000034                M 	num2:	= _minutes
0000014E =00000001                M 	dig2:	= 1
0000014E =0000000A                M 	mask:	= 10
0000014E                          M 	while	(num2<>0)&(dig2<(2))
0000014E =00000005                M 	num2:	= num2/10
0000014E =00000064                M 	mask:	= mask*10
0000014E =00000002                M 	dig2:	= dig2+1
0000014E =00000034                M 	num2:	= (_minutes)%mask
0000014E                          M 	dcb.b	(2)-strlen("52"),"0"
0000014E 3532                     M 	dc.b	"52"
00000150                            		STRSZ	$20, "\GAME_NAME"
00000150                          M 	local	len2,str2
00000150 =0000001C                M 	len2:	= strlen("MEGA CD MODE 1 DEMO BY DEVON")
00000150                          M 	str2:	equs "MEGA CD MODE 1 DEMO BY DEVON"
00000150 4D45 4741 2043 4420 4D4F+M 	dc.b	"MEGA CD MODE 1 DEMO BY DEVON"
0000016C 2020 2020                M 	dcb.b	($20)-len2," "
00000170                            		BUILDDATE
00000170                          M 	numstr	4,_year+1900
00000170                          M 	local	num2,dig2,mask
00000170 =000007E6                M 	num2:	= _year+1900
00000170 =00000001                M 	dig2:	= 1
00000170 =0000000A                M 	mask:	= 10
00000170                          M 	while	(num2<>0)&(dig2<(4))
00000170 =000000CA                M 	num2:	= num2/10
00000170 =00000064                M 	mask:	= mask*10
00000170 =00000002                M 	dig2:	= dig2+1
00000170 =00000014                M 	num2:	= num2/10
00000170 =000003E8                M 	mask:	= mask*10
00000170 =00000003                M 	dig2:	= dig2+1
00000170 =00000002                M 	num2:	= num2/10
00000170 =00002710                M 	mask:	= mask*10
00000170 =00000004                M 	dig2:	= dig2+1
00000170 =000007E6                M 	num2:	= (_year+1900)%mask
00000170                          M 	dcb.b	(4)-strlen("2022"),"0"
00000170 3230 3232                M 	dc.b	"2022"
00000174 2F                       M 	dc.b	"/"
00000175                          M 	numstr	2,_month
00000175                          M 	local	num2,dig2,mask
00000175 =00000005                M 	num2:	= _month
00000175 =00000001                M 	dig2:	= 1
00000175 =0000000A                M 	mask:	= 10
00000175                          M 	while	(num2<>0)&(dig2<(2))
00000175 =00000000                M 	num2:	= num2/10
00000175 =00000064                M 	mask:	= mask*10
00000175 =00000002                M 	dig2:	= dig2+1
00000175 =00000005                M 	num2:	= (_month)%mask
00000175 30                       M 	dcb.b	(2)-strlen("5"),"0"
00000176 35                       M 	dc.b	"5"
00000177 2F                       M 	dc.b	"/"
00000178                          M 	numstr	2,_day
00000178                          M 	local	num2,dig2,mask
00000178 =00000014                M 	num2:	= _day
00000178 =00000001                M 	dig2:	= 1
00000178 =0000000A                M 	mask:	= 10
00000178                          M 	while	(num2<>0)&(dig2<(2))
00000178 =00000002                M 	num2:	= num2/10
00000178 =00000064                M 	mask:	= mask*10
00000178 =00000002                M 	dig2:	= dig2+1
00000178 =00000014                M 	num2:	= (_day)%mask
00000178                          M 	dcb.b	(2)-strlen("20"),"0"
00000178 3230                     M 	dc.b	"20"
0000017A 20                       M 	dc.b	" "
0000017B                          M 	numstr	2,_hours
0000017B                          M 	local	num2,dig2,mask
0000017B =00000011                M 	num2:	= _hours
0000017B =00000001                M 	dig2:	= 1
0000017B =0000000A                M 	mask:	= 10
0000017B                          M 	while	(num2<>0)&(dig2<(2))
0000017B =00000001                M 	num2:	= num2/10
0000017B =00000064                M 	mask:	= mask*10
0000017B =00000002                M 	dig2:	= dig2+1
0000017B =00000011                M 	num2:	= (_hours)%mask
0000017B                          M 	dcb.b	(2)-strlen("17"),"0"
0000017B 3137                     M 	dc.b	"17"
0000017D 3A                       M 	dc.b	":"
0000017E                          M 	numstr	2,_minutes
0000017E                          M 	local	num2,dig2,mask
0000017E =00000034                M 	num2:	= _minutes
0000017E =00000001                M 	dig2:	= 1
0000017E =0000000A                M 	mask:	= 10
0000017E                          M 	while	(num2<>0)&(dig2<(2))
0000017E =00000005                M 	num2:	= num2/10
0000017E =00000064                M 	mask:	= mask*10
0000017E =00000002                M 	dig2:	= dig2+1
0000017E =00000034                M 	num2:	= (_minutes)%mask
0000017E                          M 	dcb.b	(2)-strlen("52"),"0"
0000017E 3532                     M 	dc.b	"52"
00000180                            
00000180 474D 20                    	dc.b	"GM "					; Serial number
00000183                            	STRSZ	8, "\SERIAL"
00000183                          M 	local	len2,str2
00000183 =00000008                M 	len2:	= strlen("00000000")
00000183                          M 	str2:	equs "00000000"
00000183 3030 3030 3030 3030      M 	dc.b	"00000000"
0000018B                          M 	dcb.b	(8)-len2," "
0000018B 2D                         	dc.b	"-"
0000018C                            	NUMSTR	2, REVISION
0000018C                          M 	local	num2,dig2,mask
0000018C =00000000                M 	num2:	= revision
0000018C =00000001                M 	dig2:	= 1
0000018C =0000000A                M 	mask:	= 10
0000018C                          M 	while	(num2<>0)&(dig2<(2))
0000018C =00000000                M 	num2:	= (revision)%mask
0000018C 30                       M 	dcb.b	(2)-strlen("0"),"0"
0000018D 30                       M 	dc.b	"0"
0000018E                            
0000018E 0000                       	dc.w	0					; Checksum
00000190                            	STRSZ	$10, "\IO_SUPPORT"			; I/O suuport
00000190                          M 	local	len2,str2
00000190 =00000002                M 	len2:	= strlen("JC")
00000190                          M 	str2:	equs "JC"
00000190 4A43                     M 	dc.b	"JC"
00000192 2020 2020 2020 2020 2020+M 	dcb.b	($10)-len2," "
000001A0                            
000001A0 0000 0000                  	dc.l	CARTROM					; ROM addresses
000001A4 003F FFFF                  	dc.l	CARTROM_END
000001A8 00FF 0000                  	dc.l	WORKRAM&$FFFFFF				; Work RAM addresses
000001AC 00FF FFFF                  	dc.l	WORKRAM_END&$FFFFFF
000001B0 2020 2020 2020 2020 2020+  		dcb.b	$C, " "
000001BC                            	
000001BC 2020 2020 2020 2020 2020+  	dcb.b	$C, " "					; Modem support
000001C8 2020 2020 2020 2020 2020+  	dcb.b	$28, " "				; Reserved
000001F0                            	STRSZ	$10, "JUE"				; Region support
000001F0                          M 	local	len2,str2
000001F0 =00000003                M 	len2:	= strlen("JUE")
000001F0                          M 	str2:	equs "JUE"
000001F0 4A55 45                  M 	dc.b	"JUE"
000001F3 2020 2020 2020 2020 2020+M 	dcb.b	($10)-len2," "
00000200                            
00000200                            ; ---------------------------------------------------------------------------
00000200                            ; Program initialization
00000200                            ; ---------------------------------------------------------------------------
00000200                            
00000200                            Initialize:
00000200 46FC 2700                  	move	#$2700,sr				; Reset status register
00000204 4CFA FF00 0000             	movem.l	.InitAddrRegs(pc),a0-sp			; Get address register values
0000020A                            
0000020A 162F FFF8                  	move.b	VERSION-IOCTRL1(sp),d3			; Get console version
0000020E 700F                       	moveq	#$F,d0					; Satisfy TMSS
00000210                            	and.b	d3,d0
00000210                          M 	local	num
00000210 C003                     M 	anx.b	d3,d0
00000212 6700                       	beq.s	.SkipTMSS
00000214 2F53 3FF7                  	move.l	(a3),TMSSSEGA-IOCTRL1(sp)
00000218                            
00000218                            .SkipTMSS:
00000218 3011                       	move.w	(a1),d0					; Test VDP
0000021A                            
0000021A 200E                       	move.l	a6,d0					; Clear d0
0000021C 4E66                       	move.l	a6,usp					; Clear usp
0000021E                            
0000021E 7200                       	moveq	#.PSGRegsEnd-.PSGRegs-1,d1		; Initialize PSG registers
00000220                            
00000220                            .InitPSG:
00000220 115C 0011                  	move.b	(a4)+,PSGCTRL-VDPDATA(a0)
00000224 51C9 FFFA                  	dbf	d1,.InitPSG
00000228                            
00000228 7200                       	moveq	#.VDPRegsEnd-.VDPRegs-1,d1		; Initialize VDP registers
0000022A 343C 8000                  	move.w	#$8000,d2
0000022E                            
0000022E                            .InitVDPRegs:
0000022E 141C                       	move.b	(a4)+,d2
00000230 3282                       	move.w	d2,(a1)
00000232                            	add.w	a3,d2
00000232                          M 	local	num
00000232 D44B                     M 	axd.w	a3,d2
00000234 51C9 FFF8                  	dbf	d1,.InitVDPRegs
00000238                            
00000238 348B                       	move.w	a3,(a2)					; Stop Z80
0000023A 354B 0100                  	move.w	a3,Z80RESET-Z80BUS(a2)			; Cancel Z80 reset
0000023E                            
0000023E                            .WaitZ80Stop:
0000023E 0112                       	btst	d0,(a2)					; Wait for Z80 to stop
00000240 66FC                       	bne.s	.WaitZ80Stop
00000242                            
00000242 323C 3C0A                  	move.w	#(stack_base-local_vars)/2-1,d1		; Clear stack and local variables
00000246                            
00000246                            .ClearVars:
00000246 3D00                       	move.w	d0,-(a6)
00000248 51C9 FFFC                  	dbf	d1,.ClearVars
0000024C                            
0000024C 323C 43F4                  	move.w	#(saved_vars_end-WORKRAM)/2-1,d1	; Set to clear saved variables
00000250 4AAF FFFF                  		tst.l	-1(sp)				; Was there a soft reset?
00000254 6600                       		bne.s	.SkipSavedVars			; If so, branch
00000256 4A6F 0003                  		tst.w	(IODATA3-IODATA1)-1(sp)
0000025A 6700                       		beq.s	.ClearVars2			; If not, branch
0000025C                            
0000025C                            .SkipSavedVars:
0000025C                            			subq.w	#(saved_vars_end-saved_vars)/2,d1
0000025C 5541                     M 	sxbq.w	#(saved_vars_end-saved_vars)/2,d1
0000025E 4DEE FFFC                  		lea	-(saved_vars_end-saved_vars)(a6),a6
00000262                            
00000262                            .ClearVars2:
00000262 3D00                       	move.w	d0,-(a6)
00000264 51C9 FFFC                  	dbf	d1,.ClearVars2
00000268                            	
00000268                            .InitIOPorts:
00000268 1ED4                       	move.b	(a4),(sp)+				; Initialize I/O ports
0000026A 1ED4                       	move.b	(a4),(sp)+
0000026C 1ED4                       	move.b	(a4),(sp)+
0000026E                            	
0000026E 2E78 0000                  	movea.l	CARTROM.w,sp				; Reset stack pointer
00000272                            
00000272 229C                       	move.l	(a4)+,(a1)				; Set VRAM clear command
00000274 3080                       	move.w	d0,(a0)					; Start VRAM clear
00000276                            	
00000276 7200                       	moveq	#.InitZ80PrgEnd-.InitZ80Prg,d1		; Load Z80 program
00000278                            
00000278                            .LoadZ80Prg:
00000278 1ADC                       	move.b	(a4)+,(a5)+
0000027A 51C9 FFFC                  	dbf	d1,.LoadZ80Prg
0000027E                            
0000027E 3540 0100                  	move.w	d0,Z80RESET-Z80BUS(a2)			; Reset Z80
00000282 727F                       	moveq	#$7F,d1
00000284 51C9 FFFE                  	dbf	d1,*
00000288 3480                       	move.w	d0,(a2)					; Start Z80
0000028A 354B 0100                  	move.w	a3,Z80RESET-Z80BUS(a2)			; Cancel Z80 reset
0000028E                            
0000028E                            	DMAWAIT	a1					; Wait for the DMA to finish
0000028E                          M .wait_34:
0000028E 44D1                     M 	move.w	(a1),ccr
00000290 69FC                     M 	bvs.s	.wait_34
00000292 32BC 8F02                  	move.w	#$8F02,(a1)				; Set VDP auto increment to 2
00000296                            
00000296                            	VDPCMD	move.l,$0000,CRAM,WRITE,d2		; Clear CRAM
00000296                          M 	local	cmd
00000296 =C0000000                M 	cmd:	= (cram_write)|((($0000)&$3fff)<<16)|(($0000)/$4000)
00000296 243C C000 0000           M 	move.l	#$c0000000,d2
0000029C 2282                       	move.l	d2,(a1)
0000029E 721F                       	moveq	#CRAM_SIZE/4-1,d1
000002A0                            
000002A0                            .ClearCRAM:
000002A0 2080                       	move.l	d0,(a0)
000002A2 51C9 FFFC                  	dbf	d1,.ClearCRAM
000002A6                            
000002A6                            	VDPCMD	move.l,$0000,VSRAM,WRITE,(a1)		; Clear VSRAM
000002A6                          M 	local	cmd
000002A6 =40000010                M 	cmd:	= (vsram_write)|((($0000)&$3fff)<<16)|(($0000)/$4000)
000002A6 22BC 4000 0010           M 	move.l	#$40000010,(a1)
000002AC 7213                       	moveq	#VSRAM_SIZE/4-1,d1
000002AE                            
000002AE                            .ClearVSRAM:
000002AE 2080                       	move.l	d0,(a0)
000002B0 51C9 FFFC                  	dbf	d1,.ClearVSRAM
000002B4                            
000002B4 223C 494E 4954             	move.l	#"INIT",d1				; Initialized flag value
000002BA B2B8 87E6                  	cmp.l	initialized.w,d1			; Has the checksum check already been run?
000002BE 6700                       	beq.s	.ChecksumGood				; If so, branch
000002C0                            
000002C0 45F8 0200                  	lea	CARTROM+$200.w,a2			; Calculate checksum
000002C4                            
000002C4                            .CalcChecksum:
000002C4                            	add.w	(a2)+,d0
000002C4                          M 	local	num
000002C4 D05A                     M 	axd.w	(a2)+,d0
000002C6 B5F8 01A4                  	cmp.l	CARTROM+$1A4.w,a2
000002CA 65F8                       	bcs.s	.CalcChecksum
000002CC B078 018E                  	cmp.w	CARTROM+$18E.w,d0			; Does it match the checksum in the header?
000002D0 6700                       	beq.s	.ChecksumGood				; If so, branch
000002D2                            
000002D2 2282                       	move.l	d2,(a1)					; If not, make screen red
000002D4 30BC 000E                  	move.w	#$E,(a0)
000002D8 4E72 2700                  	stop	#$2700					; Stop here forever
000002DC                            
000002DC                            .ChecksumGood:
000002DC 21C1 87E6                  	move.l	d1,initialized.w			; Mark checksum as checked
000002E0 11C3 87E0                  	move.b	d3,console_ver.w			; Set console version
000002E4                            
000002E4 303C 4E73                  	move.w	#$4E73,d0				; Set up interrupts
000002E8 31C0 87CE                  	move.w	d0,external_int.w
000002EC 31C0 87D4                  	move.w	d0,hblank_int.w
000002F0 31C0 87DA                  	move.w	d0,vblank_int.w
000002F4                            
000002F4 6100 0000                  	bsr.w	FindMCDBIOS				; Find Mega CD BIOS
000002F8 54F8 87E1                  	scc	mcd_found.w
000002FC 6500                       	bcs.s	.NoMCD					; If it wasn't found, branch
000002FE 21C8 87E2                  	move.l	a0,mcd_sub_bios.w			; Store Sub CPU BIOS address
00000302                            
00000302                            .NoMCD:
00000302 4CD6 7FFF                  	movem.l	(a6),d0-a6				; Clear registers
00000306                            	
00000306 4EF9 0000 0000             	jmp	Main					; Go to main routine
0000030C                            
0000030C                            ; ---------------------------------------------------------------------------
0000030C                            
0000030C                            .InitAddrRegs:
0000030C 00C0 0000                  	dc.l	VDPDATA					; a0: VDP data port
00000310 00C0 0004                  	dc.l	VDPCTRL					; a1: VDP control port
00000314 00A1 1100                  	dc.l	Z80BUS					; a2: Z80 bus request port
00000318 0000 0100                  	dc.l	$100					; a3: $100
0000031C 0000 0000                  	dc.l	.InitData				; a4: Initialization data
00000320 00A0 0000                  	dc.l	Z80RAM					; a5: Z80 RAM
00000324 0000 0000                  	dc.l	0					; a6: 0
00000328 00A1 0009                  	dc.l	IOCTRL1					; sp: I/O control port 1
0000032C                            
0000032C                            .InitData:
0000032C                            .PSGRegs:
0000032C 9F                         	dc.b	(((0)<<5)|$90)|15			; PSG1 minimum volume
0000032D BF                         	dc.b	(((1)<<5)|$90)|15			; PSG2 minimum volume
0000032E DF                         	dc.b	(((2)<<5)|$90)|15			; PSG3 minimum volume
0000032F FF                         	dc.b	(((3)<<5)|$90)|15			; PSG4 minimum volume
00000330                            .PSGRegsEnd:
00000330                            
00000330                            .VDPRegs:
00000330 04                         	dc.b	%00000100				; H-INT off
00000331 34                         	dc.b	%00110100				; Display off, V-INT on, DMA on
00000332 30                         	dc.b	$C000/$400				; Plane A address
00000333 34                         	dc.b	$D000/$400				; Window plane address
00000334 07                         	dc.b	$E000/$2000				; Plane B address
00000335 7C                         	dc.b	$F800/$200				; Sprite table address
00000336 00                         	dc.b	0					; Unused
00000337 00                         	dc.b	0					; Background color line 0, color 0
00000338 00                         	dc.b	0					; Unused
00000339 00                         	dc.b	0					; Unused
0000033A FF                         	dc.b	256-1					; H-INT every 256 scanlines
0000033B 00                         	dc.b	0					; EXT-INT off, scroll by screen
0000033C 81                         	dc.b	%10000001				; H40 mode, S/H mode off, no interlace
0000033D 3F                         	dc.b	$FC00/$400				; HScroll table address
0000033E 00                         	dc.b	0					; Unused
0000033F 01                         	dc.b	1					; Auto increment 1 (for DMA)
00000340 01                         	dc.b	%00000001				; 64x32 tilemap
00000341 00                         	dc.b	0					; Window X
00000342 00                         	dc.b	0					; Window Y
00000343 FF                         	dc.b	$FF					; DMA clear length $10000 bytes
00000344 FF                         	dc.b	$FF
00000345 00                         	dc.b	$00					; DMA clear source $0000
00000346 00                         	dc.b	$00
00000347 80                         	dc.b	$80
00000348                            .VDPRegsEnd:
00000348                            
00000348                            	VDPCMD	dc.l,$0000,VRAM,DMA			; VRAM DMA command
00000348                          M 	local	cmd
00000348 =40000080                M 	cmd:	= (vram_dma)|((($0000)&$3fff)<<16)|(($0000)/$4000)
00000348 4000 0080                M 	dc.l	$40000080
0000034C                            
0000034C                            .InitZ80Prg:
0000034C                            	CPU	Z80
0000034C                          M 	pusho
0000034C =00000001                M 	cpu_mode:	= 1
0000034C                          M 	opt	an+
0000034C                          M 	opt	ae-
0000034C                            	OBJ	0
00000000                            		di					; Disable interrupts
00000000 F3                       M 	dc.b	$f3
00000001                            		ld	hl,.Z80Clear			; Clear the rest of Z80 RAM
00000001                          M 	local	num,num2
00000001                          M 	num:	equ .z80clear
00000001 =00000009                M 	tmp_len:	= strlen(".z80clear")
00000001                          M 	tmp_fc:	substr 1,1,".z80clear"
00000001                          M 	tmp_lc:	substr tmp_len,tmp_len,".z80clear"
00000001 2100 00                  M 	dc.b	$21,num&$ff,num>>8
00000004                            		ld	de,.Z80Clear+1
00000004                          M 	local	num,num2
00000004                          M 	num:	equ .z80clear+1
00000004 =0000000B                M 	tmp_len:	= strlen(".z80clear+1")
00000004                          M 	tmp_fc:	substr 1,1,".z80clear+1"
00000004                          M 	tmp_lc:	substr tmp_len,tmp_len,".z80clear+1"
00000004 1100 00                  M 	dc.b	$11,num&$ff,num>>8
00000007                            		ld	bc,2000h-(.Z80Clear+1)
00000007                          M 	local	num,num2
00000007                          M 	num:	equ 2000h-(.z80clear+1)
00000007 =00000013                M 	tmp_len:	= strlen("2000h-(.z80clear+1)")
00000007                          M 	tmp_fc:	substr 1,1,"2000h-(.z80clear+1)"
00000007                          M 	tmp_lc:	substr tmp_len,tmp_len,"2000h-(.z80clear+1)"
00000007 0100 00                  M 	dc.b	$1,num&$ff,num>>8
0000000A                            		ldir
0000000A EDB0                     M 	dc.w	$edb0
0000000C                            		jr	*				; Loop here forever
0000000C                          M 	local	num
0000000C =0000000C                M 	num:	equ *
0000000C 18                       M 	dc.b	$18
0000000D FE                       M 	dc.b	num-*-1
0000000E                            .Z80Clear:
0000000E                            	db	0
0000000E 00                       M 	dc.b	0
0000000F                            	OBJEND
0000035B                            	CPU	68000
0000035B                          M 	popo
0000035B =00000000                M 	cpu_mode:	= 0
0000035B                            .InitZ80PrgEnd:
0000035C 00                         	even
0000035C                            
0000035C                            ; ---------------------------------------------------------------------------
0000035C                            ; Error exceptions
0000035C                            ; ---------------------------------------------------------------------------
0000035C                            
0000035C                            		include	"_lib/error.m68k"
0000035C                            
0000035C                            ; ===============================================================
0000035C                            ; ---------------------------------------------------------------
0000035C                            ; Error handling and debugging modules
0000035C                            ; 2016-2017, Vladikcomper
0000035C                            ; ---------------------------------------------------------------
0000035C                            ; Error handler functions and calls
0000035C                            ; ---------------------------------------------------------------
0000035C                            
0000035C                            ; ---------------------------------------------------------------
0000035C                            ; Error handler control flags
0000035C                            ; ---------------------------------------------------------------
0000035C                            
0000035C                            ; Screen appearence flags
0000035C =00000001                  _eh_address_error	equ	$01		; use for address and bus errors only (tells error handler to display additional "Address" field)
0000035C =00000002                  _eh_show_sr_usp		equ	$02		; displays SR and USP registers content on error screen
0000035C                            
0000035C                            ; Advanced execution flags
0000035C                            ; WARNING! For experts only, DO NOT USES them unless you know what you're doing
0000035C =00000020                  _eh_return			equ	$20
0000035C =00000040                  _eh_enter_console	equ	$40
0000035C =00000080                  _eh_align_offset	equ	$80
0000035C                            
0000035C                            ; ---------------------------------------------------------------
0000035C                            ; Errors vector table
0000035C                            ; ---------------------------------------------------------------
0000035C                            
0000035C                            ; Default screen configuration
0000035C =00000000                  _eh_default			equ	0 ;_eh_show_sr_usp
0000035C                            
0000035C                            ; ---------------------------------------------------------------
0000035C                            
0000035C                            BusError:
0000035C                            	__ErrorMessage "BUS ERROR", _eh_default|_eh_address_error
0000035C                          M 	__fstring_generateargumentscode	"BUS ERROR"
0000035C =00000000                M 	__pos:	set instr("BUS ERROR",'%<')
0000035C =00000000                M 	__stack:set	0
0000035C =00000000                M 	__sp:	set 0
0000035C                          M 	while	(__pos)
0000035C                          M 	rept	__stack
0000035C 4EB9 0000 0000           M 	jsr	errorhandler
00000362                          M 	__fstring_generatedecodedstring	"BUS ERROR"
00000362 =00000001                M 	__lpos:	set 1
00000362 =00000000                M 	__pos:	set instr("BUS ERROR",'%<')
00000362                          M 	while	(__pos)
00000362                          M 	__substr:	substr __lpos,,"BUS ERROR"
00000362 4255 5320 4552 524F 52   M 	dc.b	"BUS ERROR"
0000036B 00                       M 	dc.b	0
0000036C 01                       M 	dc.b	_eh_default|_eh_address_error+0
0000036E 00                       M 	even
0000036E                            
0000036E                            AddressError:
0000036E                            	__ErrorMessage "ADDRESS ERROR", _eh_default|_eh_address_error
0000036E                          M 	__fstring_generateargumentscode	"ADDRESS ERROR"
0000036E =00000000                M 	__pos:	set instr("ADDRESS ERROR",'%<')
0000036E =00000000                M 	__stack:set	0
0000036E =00000000                M 	__sp:	set 0
0000036E                          M 	while	(__pos)
0000036E                          M 	rept	__stack
0000036E 4EB9 0000 0000           M 	jsr	errorhandler
00000374                          M 	__fstring_generatedecodedstring	"ADDRESS ERROR"
00000374 =00000001                M 	__lpos:	set 1
00000374 =00000000                M 	__pos:	set instr("ADDRESS ERROR",'%<')
00000374                          M 	while	(__pos)
00000374                          M 	__substr:	substr __lpos,,"ADDRESS ERROR"
00000374 4144 4452 4553 5320 4552+M 	dc.b	"ADDRESS ERROR"
00000381 00                       M 	dc.b	0
00000382 01                       M 	dc.b	_eh_default|_eh_address_error+0
00000384 00                       M 	even
00000384                            
00000384                            IllegalInstr:
00000384                            	__ErrorMessage "ILLEGAL INSTRUCTION", _eh_default
00000384                          M 	__fstring_generateargumentscode	"ILLEGAL INSTRUCTION"
00000384 =00000000                M 	__pos:	set instr("ILLEGAL INSTRUCTION",'%<')
00000384 =00000000                M 	__stack:set	0
00000384 =00000000                M 	__sp:	set 0
00000384                          M 	while	(__pos)
00000384                          M 	rept	__stack
00000384 4EB9 0000 0000           M 	jsr	errorhandler
0000038A                          M 	__fstring_generatedecodedstring	"ILLEGAL INSTRUCTION"
0000038A =00000001                M 	__lpos:	set 1
0000038A =00000000                M 	__pos:	set instr("ILLEGAL INSTRUCTION",'%<')
0000038A                          M 	while	(__pos)
0000038A                          M 	__substr:	substr __lpos,,"ILLEGAL INSTRUCTION"
0000038A 494C 4C45 4741 4C20 494E+M 	dc.b	"ILLEGAL INSTRUCTION"
0000039D 00                       M 	dc.b	0
0000039E 00                       M 	dc.b	_eh_default+0
000003A0 00                       M 	even
000003A0                            
000003A0                            ZeroDivide:
000003A0                            	__ErrorMessage "ZERO DIVIDE", _eh_default
000003A0                          M 	__fstring_generateargumentscode	"ZERO DIVIDE"
000003A0 =00000000                M 	__pos:	set instr("ZERO DIVIDE",'%<')
000003A0 =00000000                M 	__stack:set	0
000003A0 =00000000                M 	__sp:	set 0
000003A0                          M 	while	(__pos)
000003A0                          M 	rept	__stack
000003A0 4EB9 0000 0000           M 	jsr	errorhandler
000003A6                          M 	__fstring_generatedecodedstring	"ZERO DIVIDE"
000003A6 =00000001                M 	__lpos:	set 1
000003A6 =00000000                M 	__pos:	set instr("ZERO DIVIDE",'%<')
000003A6                          M 	while	(__pos)
000003A6                          M 	__substr:	substr __lpos,,"ZERO DIVIDE"
000003A6 5A45 524F 2044 4956 4944+M 	dc.b	"ZERO DIVIDE"
000003B1 00                       M 	dc.b	0
000003B2 00                       M 	dc.b	_eh_default+0
000003B4 00                       M 	even
000003B4                            
000003B4                            ChkInstr:
000003B4                            	__ErrorMessage "CHK INSTRUCTION", _eh_default
000003B4                          M 	__fstring_generateargumentscode	"CHK INSTRUCTION"
000003B4 =00000000                M 	__pos:	set instr("CHK INSTRUCTION",'%<')
000003B4 =00000000                M 	__stack:set	0
000003B4 =00000000                M 	__sp:	set 0
000003B4                          M 	while	(__pos)
000003B4                          M 	rept	__stack
000003B4 4EB9 0000 0000           M 	jsr	errorhandler
000003BA                          M 	__fstring_generatedecodedstring	"CHK INSTRUCTION"
000003BA =00000001                M 	__lpos:	set 1
000003BA =00000000                M 	__pos:	set instr("CHK INSTRUCTION",'%<')
000003BA                          M 	while	(__pos)
000003BA                          M 	__substr:	substr __lpos,,"CHK INSTRUCTION"
000003BA 4348 4B20 494E 5354 5255+M 	dc.b	"CHK INSTRUCTION"
000003C9 00                       M 	dc.b	0
000003CA 00                       M 	dc.b	_eh_default+0
000003CC 00                       M 	even
000003CC                            
000003CC                            TrapvInstr:
000003CC                            	__ErrorMessage "TRAPV INSTRUCTION", _eh_default
000003CC                          M 	__fstring_generateargumentscode	"TRAPV INSTRUCTION"
000003CC =00000000                M 	__pos:	set instr("TRAPV INSTRUCTION",'%<')
000003CC =00000000                M 	__stack:set	0
000003CC =00000000                M 	__sp:	set 0
000003CC                          M 	while	(__pos)
000003CC                          M 	rept	__stack
000003CC 4EB9 0000 0000           M 	jsr	errorhandler
000003D2                          M 	__fstring_generatedecodedstring	"TRAPV INSTRUCTION"
000003D2 =00000001                M 	__lpos:	set 1
000003D2 =00000000                M 	__pos:	set instr("TRAPV INSTRUCTION",'%<')
000003D2                          M 	while	(__pos)
000003D2                          M 	__substr:	substr __lpos,,"TRAPV INSTRUCTION"
000003D2 5452 4150 5620 494E 5354+M 	dc.b	"TRAPV INSTRUCTION"
000003E3 00                       M 	dc.b	0
000003E4 00                       M 	dc.b	_eh_default+0
000003E6 00                       M 	even
000003E6                            
000003E6                            PrivilegeViol:
000003E6                            	__ErrorMessage "PRIVILEGE VIOLATION", _eh_default
000003E6                          M 	__fstring_generateargumentscode	"PRIVILEGE VIOLATION"
000003E6 =00000000                M 	__pos:	set instr("PRIVILEGE VIOLATION",'%<')
000003E6 =00000000                M 	__stack:set	0
000003E6 =00000000                M 	__sp:	set 0
000003E6                          M 	while	(__pos)
000003E6                          M 	rept	__stack
000003E6 4EB9 0000 0000           M 	jsr	errorhandler
000003EC                          M 	__fstring_generatedecodedstring	"PRIVILEGE VIOLATION"
000003EC =00000001                M 	__lpos:	set 1
000003EC =00000000                M 	__pos:	set instr("PRIVILEGE VIOLATION",'%<')
000003EC                          M 	while	(__pos)
000003EC                          M 	__substr:	substr __lpos,,"PRIVILEGE VIOLATION"
000003EC 5052 4956 494C 4547 4520+M 	dc.b	"PRIVILEGE VIOLATION"
000003FF 00                       M 	dc.b	0
00000400 00                       M 	dc.b	_eh_default+0
00000402 00                       M 	even
00000402                            
00000402                            Trace:
00000402                            	__ErrorMessage "TRACE", _eh_default
00000402                          M 	__fstring_generateargumentscode	"TRACE"
00000402 =00000000                M 	__pos:	set instr("TRACE",'%<')
00000402 =00000000                M 	__stack:set	0
00000402 =00000000                M 	__sp:	set 0
00000402                          M 	while	(__pos)
00000402                          M 	rept	__stack
00000402 4EB9 0000 0000           M 	jsr	errorhandler
00000408                          M 	__fstring_generatedecodedstring	"TRACE"
00000408 =00000001                M 	__lpos:	set 1
00000408 =00000000                M 	__pos:	set instr("TRACE",'%<')
00000408                          M 	while	(__pos)
00000408                          M 	__substr:	substr __lpos,,"TRACE"
00000408 5452 4143 45             M 	dc.b	"TRACE"
0000040D 00                       M 	dc.b	0
0000040E 00                       M 	dc.b	_eh_default+0
00000410 00                       M 	even
00000410                            
00000410                            Line1010Emu:
00000410                            	__ErrorMessage "LINE 1010 EMULATOR", _eh_default
00000410                          M 	__fstring_generateargumentscode	"LINE 1010 EMULATOR"
00000410 =00000000                M 	__pos:	set instr("LINE 1010 EMULATOR",'%<')
00000410 =00000000                M 	__stack:set	0
00000410 =00000000                M 	__sp:	set 0
00000410                          M 	while	(__pos)
00000410                          M 	rept	__stack
00000410 4EB9 0000 0000           M 	jsr	errorhandler
00000416                          M 	__fstring_generatedecodedstring	"LINE 1010 EMULATOR"
00000416 =00000001                M 	__lpos:	set 1
00000416 =00000000                M 	__pos:	set instr("LINE 1010 EMULATOR",'%<')
00000416                          M 	while	(__pos)
00000416                          M 	__substr:	substr __lpos,,"LINE 1010 EMULATOR"
00000416 4C49 4E45 2031 3031 3020+M 	dc.b	"LINE 1010 EMULATOR"
00000428 00                       M 	dc.b	0
00000429 00                       M 	dc.b	_eh_default+0
0000042A                          M 	even
0000042A                            
0000042A                            Line1111Emu:
0000042A                            	__ErrorMessage "LINE 1111 EMULATOR", _eh_default
0000042A                          M 	__fstring_generateargumentscode	"LINE 1111 EMULATOR"
0000042A =00000000                M 	__pos:	set instr("LINE 1111 EMULATOR",'%<')
0000042A =00000000                M 	__stack:set	0
0000042A =00000000                M 	__sp:	set 0
0000042A                          M 	while	(__pos)
0000042A                          M 	rept	__stack
0000042A 4EB9 0000 0000           M 	jsr	errorhandler
00000430                          M 	__fstring_generatedecodedstring	"LINE 1111 EMULATOR"
00000430 =00000001                M 	__lpos:	set 1
00000430 =00000000                M 	__pos:	set instr("LINE 1111 EMULATOR",'%<')
00000430                          M 	while	(__pos)
00000430                          M 	__substr:	substr __lpos,,"LINE 1111 EMULATOR"
00000430 4C49 4E45 2031 3131 3120+M 	dc.b	"LINE 1111 EMULATOR"
00000442 00                       M 	dc.b	0
00000443 00                       M 	dc.b	_eh_default+0
00000444                          M 	even
00000444                            
00000444                            ErrorExcept:
00000444                            	__ErrorMessage "ERROR EXCEPTION", _eh_default
00000444                          M 	__fstring_generateargumentscode	"ERROR EXCEPTION"
00000444 =00000000                M 	__pos:	set instr("ERROR EXCEPTION",'%<')
00000444 =00000000                M 	__stack:set	0
00000444 =00000000                M 	__sp:	set 0
00000444                          M 	while	(__pos)
00000444                          M 	rept	__stack
00000444 4EB9 0000 0000           M 	jsr	errorhandler
0000044A                          M 	__fstring_generatedecodedstring	"ERROR EXCEPTION"
0000044A =00000001                M 	__lpos:	set 1
0000044A =00000000                M 	__pos:	set instr("ERROR EXCEPTION",'%<')
0000044A                          M 	while	(__pos)
0000044A                          M 	__substr:	substr __lpos,,"ERROR EXCEPTION"
0000044A 4552 524F 5220 4558 4345+M 	dc.b	"ERROR EXCEPTION"
00000459 00                       M 	dc.b	0
0000045A 00                       M 	dc.b	_eh_default+0
0000045C 00                       M 	even
0000045C                            
0000045C                            ; ---------------------------------------------------------------
0000045C                            ; Import error handler global functions
0000045C                            ; ---------------------------------------------------------------
0000045C                            
0000045C                            ErrorHandler.__global__error_initconsole equ ErrorHandler+$146
0000045C                            ErrorHandler.__global__errorhandler_setupvdp equ ErrorHandler+$234
0000045C                            ErrorHandler.__global__console_loadpalette equ ErrorHandler+$A1C
0000045C                            ErrorHandler.__global__console_setposasxy_stack equ ErrorHandler+$A58
0000045C                            ErrorHandler.__global__console_setposasxy equ ErrorHandler+$A5E
0000045C                            ErrorHandler.__global__console_getposasxy equ ErrorHandler+$A8A
0000045C                            ErrorHandler.__global__console_startnewline equ ErrorHandler+$AAC
0000045C                            ErrorHandler.__global__console_setbasepattern equ ErrorHandler+$AD4
0000045C                            ErrorHandler.__global__console_setwidth equ ErrorHandler+$AE8
0000045C                            ErrorHandler.__global__console_writeline_withpattern equ ErrorHandler+$AFE
0000045C                            ErrorHandler.__global__console_writeline equ ErrorHandler+$B00
0000045C                            ErrorHandler.__global__console_write equ ErrorHandler+$B04
0000045C                            ErrorHandler.__global__console_writeline_formatted equ ErrorHandler+$BB0
0000045C                            ErrorHandler.__global__console_write_formatted equ ErrorHandler+$BB4
0000045C                            
0000045C                            
0000045C                            ; ---------------------------------------------------------------
0000045C                            ; Error handler external functions (compiled only when used)
0000045C                            ; ---------------------------------------------------------------
0000045C                            
0000045C                            
0000045C                            
0000045C                            
0000045C                            
0000045C                            ; ---------------------------------------------------------------
0000045C                            ; Include error handler binary module
0000045C                            ; ---------------------------------------------------------------
0000045C                            
0000045C                            ErrorHandler:
0000045C 46FC 2700 4FEF FFF2 48E7+  	dc.b	$46, $FC, $27, $00, $4F, $EF, $FF, $F2, $48, $E7, $FF, $FE
00000468 4EBA 0226 49EF 004A 4E68+  	dc.b	$4E, $BA, $02, $26, $49, $EF, $00, $4A, $4E, $68, $2F, $08
00000474 47EF 0040 4EBA 0128 41FA+  	dc.b	$47, $EF, $00, $40, $4E, $BA, $01, $28, $41, $FA, $02, $AA
00000480 4EBA 0ADE 225C 45D4 4EBA+  	dc.b	$4E, $BA, $0A, $DE, $22, $5C, $45, $D4, $4E, $BA, $0B, $82
0000048C 4EBA 0A7A 49D2 1C19 6A02+  	dc.b	$4E, $BA, $0A, $7A, $49, $D2, $1C, $19, $6A, $02, $52, $49
00000498 47D1 0806 0000 670E 43FA+  	dc.b	$47, $D1, $08, $06, $00, $00, $67, $0E, $43, $FA, $02, $8D
000004A4 45EC 0002 4EBA 0B62 504C+  	dc.b	$45, $EC, $00, $02, $4E, $BA, $0B, $62, $50, $4C, $43, $FA
000004B0 028E 45EC 0002 4EBA 0B54+  	dc.b	$02, $8E, $45, $EC, $00, $02, $4E, $BA, $0B, $54, $43, $FA
000004BC 0290 45EC 0002 4EBA 0B48+  	dc.b	$02, $90, $45, $EC, $00, $02, $4E, $BA, $0B, $48, $45, $EC
000004C8 0006 4EBA 01A6 43FA 028A+  	dc.b	$00, $06, $4E, $BA, $01, $A6, $43, $FA, $02, $8A, $2F, $01
000004D4 45D7 4EBA 0B34 4EBA 0A2C+  	dc.b	$45, $D7, $4E, $BA, $0B, $34, $4E, $BA, $0A, $2C, $58, $4F
000004E0 0806 0006 6600 00A6 45EF+  	dc.b	$08, $06, $00, $06, $66, $00, $00, $A6, $45, $EF, $00, $04
000004EC 4EBA 09F8 3F01 7003 4EBA+  	dc.b	$4E, $BA, $09, $F8, $3F, $01, $70, $03, $4E, $BA, $09, $C4
000004F8 303C 6430 7A07 4EBA 0104+  	dc.b	$30, $3C, $64, $30, $7A, $07, $4E, $BA, $01, $04, $32, $1F
00000504 7011 4EBA 09B2 303C 6130+  	dc.b	$70, $11, $4E, $BA, $09, $B2, $30, $3C, $61, $30, $7A, $06
00000510 4EBA 00F2 303C 7370 7A00+  	dc.b	$4E, $BA, $00, $F2, $30, $3C, $73, $70, $7A, $00, $2F, $0C
0000051C 45D7 4EBA 00E4 584F 0806+  	dc.b	$45, $D7, $4E, $BA, $00, $E4, $58, $4F, $08, $06, $00, $01
00000528 6714 43FA 023C 45D7 4EBA+  	dc.b	$67, $14, $43, $FA, $02, $3C, $45, $D7, $4E, $BA, $0A, $DE
00000534 43FA 023D 45D4 4EBA 0AD0+  	dc.b	$43, $FA, $02, $3D, $45, $D4, $4E, $BA, $0A, $D0, $58, $4F
00000540 4EBA 09A4 5241 7001 4EBA+  	dc.b	$4E, $BA, $09, $A4, $52, $41, $70, $01, $4E, $BA, $09, $70
0000054C 2038 0078 41FA 022B 4EBA+  	dc.b	$20, $38, $00, $78, $41, $FA, $02, $2B, $4E, $BA, $00, $DC
00000558 2038 0070 41FA 0227 4EBA+  	dc.b	$20, $38, $00, $70, $41, $FA, $02, $27, $4E, $BA, $00, $D0
00000564 4EBA 09A2 344C 3278 0002+  	dc.b	$4E, $BA, $09, $A2, $34, $4C, $32, $78, $00, $02, $53, $49
00000570 4EBA 0974 7A19 9A41 6B0A+  	dc.b	$4E, $BA, $09, $74, $7A, $19, $9A, $41, $6B, $0A, $61, $32
0000057C 4EBA 0044 51CD FFFA 0806+  	dc.b	$4E, $BA, $00, $44, $51, $CD, $FF, $FA, $08, $06, $00, $05
00000588 6608 60FE 7200 4EBA 09A0+  	dc.b	$66, $08, $60, $FE, $72, $00, $4E, $BA, $09, $A0, $2E, $CB
00000594 4CDF 7FFF 487A FFF0 2F2F+  	dc.b	$4C, $DF, $7F, $FF, $48, $7A, $FF, $F0, $2F, $2F, $FF, $C4
000005A0 4E75 43FA 0140 45FA 01E6+  	dc.b	$4E, $75, $43, $FA, $01, $40, $45, $FA, $01, $E6, $4E, $FA
000005AC 0888 4FEF FFD0 41D7 7EFF+  	dc.b	$08, $88, $4F, $EF, $FF, $D0, $41, $D7, $7E, $FF, $20, $FC
000005B8 2853 5029 30FC 3A20 6018+  	dc.b	$28, $53, $50, $29, $30, $FC, $3A, $20, $60, $18, $4F, $EF
000005C4 FFD0 41D7 7EFF 30FC 202B+  	dc.b	$FF, $D0, $41, $D7, $7E, $FF, $30, $FC, $20, $2B, $32, $0A
000005D0 924C 4EBA 05AA 30FC 3A20+  	dc.b	$92, $4C, $4E, $BA, $05, $AA, $30, $FC, $3A, $20, $70, $05
000005DC 72EC B4C9 6D02 72EE 10C1+  	dc.b	$72, $EC, $B4, $C9, $6D, $02, $72, $EE, $10, $C1, $32, $1A
000005E8 4EBA 05BC 10FC 0020 51C8+  	dc.b	$4E, $BA, $05, $BC, $10, $FC, $00, $20, $51, $C8, $FF, $EA
000005F4 4218 41D7 7200 4EBA 095E+  	dc.b	$42, $18, $41, $D7, $72, $00, $4E, $BA, $09, $5E, $4F, $EF
00000600 0030 4E75 4FEF FFF0 7EFF+  	dc.b	$00, $30, $4E, $75, $4F, $EF, $FF, $F0, $7E, $FF, $41, $D7
0000060C 30C0 30FC 3A20 10FC 00EC+  	dc.b	$30, $C0, $30, $FC, $3A, $20, $10, $FC, $00, $EC, $22, $1A
00000618 4EBA 0584 4218 41D7 7200+  	dc.b	$4E, $BA, $05, $84, $42, $18, $41, $D7, $72, $00, $4E, $BA
00000624 0936 5240 51CD FFE0 4FEF+  	dc.b	$09, $36, $52, $40, $51, $CD, $FF, $E0, $4F, $EF, $00, $10
00000630 4E75 2200 4841 4601 6620+  	dc.b	$4E, $75, $22, $00, $48, $41, $46, $01, $66, $20, $51, $4F
0000063C 2E88 2440 43FA 0021 0C5A+  	dc.b	$2E, $88, $24, $40, $43, $FA, $00, $21, $0C, $5A, $4E, $F9
00000648 6608 43FA 0010 2F52 0004+  	dc.b	$66, $08, $43, $FA, $00, $10, $2F, $52, $00, $04, $45, $D7
00000654 4EBA 09BA 504F 4E75 D0E8+  	dc.b	$4E, $BA, $09, $BA, $50, $4F, $4E, $75, $D0, $E8, $BF, $EC
00000660 C8E0 00D0 E83C 756E 6465+  	dc.b	$C8, $E0, $00, $D0, $E8, $3C, $75, $6E, $64, $65, $66, $69
0000066C 6E65 643E E000 3278 0002+  	dc.b	$6E, $65, $64, $3E, $E0, $00, $32, $78, $00, $02, $59, $49
00000678 B2CA 650C 0C52 0040 650A+  	dc.b	$B2, $CA, $65, $0C, $0C, $52, $00, $40, $65, $0A, $54, $4A
00000684 B2CA 64F4 7200 4E75 2212+  	dc.b	$B2, $CA, $64, $F4, $72, $00, $4E, $75, $22, $12, $4E, $75
00000690 4BF9 00C0 0004 4DED FFFC+  	dc.b	$4B, $F9, $00, $C0, $00, $04, $4D, $ED, $FF, $FC, $4A, $55
0000069C 44D5 69FC 41FA 0026 3018+  	dc.b	$44, $D5, $69, $FC, $41, $FA, $00, $26, $30, $18, $6A, $04
000006A8 3A80 60F8 7000 2ABC 4000+  	dc.b	$3A, $80, $60, $F8, $70, $00, $2A, $BC, $40, $00, $00, $00
000006B4 2C80 2ABC 4000 0010 2C80+  	dc.b	$2C, $80, $2A, $BC, $40, $00, $00, $10, $2C, $80, $2A, $BC
000006C0 C000 0000 3C80 4E75 8004+  	dc.b	$C0, $00, $00, $00, $3C, $80, $4E, $75, $80, $04, $81, $34
000006CC 8220 8404 8500 8700 8B00+  	dc.b	$82, $20, $84, $04, $85, $00, $87, $00, $8B, $00, $8C, $81
000006D8 8D00 8F02 9011 9100 9200+  	dc.b	$8D, $00, $8F, $02, $90, $11, $91, $00, $92, $00, $00, $00
000006E4 4400 0000 0000 0001 0010+  	dc.b	$44, $00, $00, $00, $00, $00, $00, $01, $00, $10, $00, $11
000006F0 0100 0101 0110 0111 1000+  	dc.b	$01, $00, $01, $01, $01, $10, $01, $11, $10, $00, $10, $01
000006FC 1010 1011 1100 1101 1110+  	dc.b	$10, $10, $10, $11, $11, $00, $11, $01, $11, $10, $11, $11
00000708 FFFF 4000 0002 0028 0028+  	dc.b	$FF, $FF, $40, $00, $00, $02, $00, $28, $00, $28, $00, $00
00000714 0080 00FF 0EEE FFF2 00CE+  	dc.b	$00, $80, $00, $FF, $0E, $EE, $FF, $F2, $00, $CE, $FF, $F2
00000720 0EEA FFF2 0E86 FFF2 EAE0+  	dc.b	$0E, $EA, $FF, $F2, $0E, $86, $FF, $F2, $EA, $E0, $FA, $01
0000072C F026 00EA 4164 6472 6573+  	dc.b	$F0, $26, $00, $EA, $41, $64, $64, $72, $65, $73, $73, $3A
00000738 20E8 BBEC C000 EA4C 6F63+  	dc.b	$20, $E8, $BB, $EC, $C0, $00, $EA, $4C, $6F, $63, $61, $74
00000744 696F 6E3A 20EC 8300 EA4D+  	dc.b	$69, $6F, $6E, $3A, $20, $EC, $83, $00, $EA, $4D, $6F, $64
00000750 756C 653A 20E8 BFEC C800+  	dc.b	$75, $6C, $65, $3A, $20, $E8, $BF, $EC, $C8, $00, $EA, $43
0000075C 616C 6C65 723A 20E8 BBEC+  	dc.b	$61, $6C, $6C, $65, $72, $3A, $20, $E8, $BB, $EC, $C0, $00
00000768 FA10 E875 7370 3A20 EC83+  	dc.b	$FA, $10, $E8, $75, $73, $70, $3A, $20, $EC, $83, $00, $FA
00000774 03E8 7372 3A20 EC81 00EA+  	dc.b	$03, $E8, $73, $72, $3A, $20, $EC, $81, $00, $EA, $56, $49
00000780 6E74 3A20 00EA 4849 6E74+  	dc.b	$6E, $74, $3A, $20, $00, $EA, $48, $49, $6E, $74, $3A, $20
0000078C 0000 02F9 0000 0000 0000+  	dc.b	$00, $00, $02, $F9, $00, $00, $00, $00, $00, $00, $00, $00
00000798 183C 3C18 1800 1800 6C6C+  	dc.b	$18, $3C, $3C, $18, $18, $00, $18, $00, $6C, $6C, $6C, $00
000007A4 0000 0000 6C6C FE6C FE6C+  	dc.b	$00, $00, $00, $00, $6C, $6C, $FE, $6C, $FE, $6C, $6C, $00
000007B0 187E C07C 06FC 1800 00C6+  	dc.b	$18, $7E, $C0, $7C, $06, $FC, $18, $00, $00, $C6, $0C, $18
000007BC 3060 C600 386C 3876 CCCC+  	dc.b	$30, $60, $C6, $00, $38, $6C, $38, $76, $CC, $CC, $76, $00
000007C8 1818 3000 0000 0000 1830+  	dc.b	$18, $18, $30, $00, $00, $00, $00, $00, $18, $30, $60, $60
000007D4 6030 1800 6030 1818 1830+  	dc.b	$60, $30, $18, $00, $60, $30, $18, $18, $18, $30, $60, $00
000007E0 00EE 7CFE 7CEE 0000 0018+  	dc.b	$00, $EE, $7C, $FE, $7C, $EE, $00, $00, $00, $18, $18, $7E
000007EC 1818 0000 0000 0000 1818+  	dc.b	$18, $18, $00, $00, $00, $00, $00, $00, $18, $18, $30, $00
000007F8 0000 00FE 0000 0000 0000+  	dc.b	$00, $00, $00, $FE, $00, $00, $00, $00, $00, $00, $00, $00
00000804 0038 3800 060C 1830 60C0+  	dc.b	$00, $38, $38, $00, $06, $0C, $18, $30, $60, $C0, $80, $00
00000810 7CC6 CEDE F6E6 7C00 1878+  	dc.b	$7C, $C6, $CE, $DE, $F6, $E6, $7C, $00, $18, $78, $18, $18
0000081C 1818 7E00 7CC6 0C18 3066+  	dc.b	$18, $18, $7E, $00, $7C, $C6, $0C, $18, $30, $66, $FE, $00
00000828 7CC6 063C 06C6 7C00 0C1C+  	dc.b	$7C, $C6, $06, $3C, $06, $C6, $7C, $00, $0C, $1C, $3C, $6C
00000834 FE0C 0C00 FEC0 FC06 06C6+  	dc.b	$FE, $0C, $0C, $00, $FE, $C0, $FC, $06, $06, $C6, $7C, $00
00000840 7CC6 C0FC C6C6 7C00 FEC6+  	dc.b	$7C, $C6, $C0, $FC, $C6, $C6, $7C, $00, $FE, $C6, $06, $0C
0000084C 1818 1800 7CC6 C67C C6C6+  	dc.b	$18, $18, $18, $00, $7C, $C6, $C6, $7C, $C6, $C6, $7C, $00
00000858 7CC6 C67E 06C6 7C00 001C+  	dc.b	$7C, $C6, $C6, $7E, $06, $C6, $7C, $00, $00, $1C, $1C, $00
00000864 001C 1C00 0018 1800 0018+  	dc.b	$00, $1C, $1C, $00, $00, $18, $18, $00, $00, $18, $18, $30
00000870 0C18 3060 3018 0C00 0000+  	dc.b	$0C, $18, $30, $60, $30, $18, $0C, $00, $00, $00, $FE, $00
0000087C 00FE 0000 6030 180C 1830+  	dc.b	$00, $FE, $00, $00, $60, $30, $18, $0C, $18, $30, $60, $00
00000888 7CC6 060C 1800 1800 7CC6+  	dc.b	$7C, $C6, $06, $0C, $18, $00, $18, $00, $7C, $C6, $C6, $DE
00000894 DCC0 7E00 386C C6C6 FEC6+  	dc.b	$DC, $C0, $7E, $00, $38, $6C, $C6, $C6, $FE, $C6, $C6, $00
000008A0 FC66 667C 6666 FC00 3C66+  	dc.b	$FC, $66, $66, $7C, $66, $66, $FC, $00, $3C, $66, $C0, $C0
000008AC C066 3C00 F86C 6666 666C+  	dc.b	$C0, $66, $3C, $00, $F8, $6C, $66, $66, $66, $6C, $F8, $00
000008B8 FEC2 C0F8 C0C2 FE00 FE62+  	dc.b	$FE, $C2, $C0, $F8, $C0, $C2, $FE, $00, $FE, $62, $60, $7C
000008C4 6060 F000 7CC6 C0C0 DEC6+  	dc.b	$60, $60, $F0, $00, $7C, $C6, $C0, $C0, $DE, $C6, $7C, $00
000008D0 C6C6 C6FE C6C6 C600 3C18+  	dc.b	$C6, $C6, $C6, $FE, $C6, $C6, $C6, $00, $3C, $18, $18, $18
000008DC 1818 3C00 3C18 1818 D8D8+  	dc.b	$18, $18, $3C, $00, $3C, $18, $18, $18, $D8, $D8, $70, $00
000008E8 C6CC D8F0 D8CC C600 F060+  	dc.b	$C6, $CC, $D8, $F0, $D8, $CC, $C6, $00, $F0, $60, $60, $60
000008F4 6062 FE00 C6EE FED6 D6C6+  	dc.b	$60, $62, $FE, $00, $C6, $EE, $FE, $D6, $D6, $C6, $C6, $00
00000900 C6E6 E6F6 DECE C600 7CC6+  	dc.b	$C6, $E6, $E6, $F6, $DE, $CE, $C6, $00, $7C, $C6, $C6, $C6
0000090C C6C6 7C00 FC66 667C 6060+  	dc.b	$C6, $C6, $7C, $00, $FC, $66, $66, $7C, $60, $60, $F0, $00
00000918 7CC6 C6C6 C6D6 7C06 FCC6+  	dc.b	$7C, $C6, $C6, $C6, $C6, $D6, $7C, $06, $FC, $C6, $C6, $FC
00000924 D8CC C600 7CC6 C07C 06C6+  	dc.b	$D8, $CC, $C6, $00, $7C, $C6, $C0, $7C, $06, $C6, $7C, $00
00000930 7E5A 1818 1818 3C00 C6C6+  	dc.b	$7E, $5A, $18, $18, $18, $18, $3C, $00, $C6, $C6, $C6, $C6
0000093C C6C6 7C00 C6C6 C6C6 6C38+  	dc.b	$C6, $C6, $7C, $00, $C6, $C6, $C6, $C6, $6C, $38, $10, $00
00000948 C6C6 D6D6 FEEE C600 C66C+  	dc.b	$C6, $C6, $D6, $D6, $FE, $EE, $C6, $00, $C6, $6C, $38, $38
00000954 386C C600 6666 663C 1818+  	dc.b	$38, $6C, $C6, $00, $66, $66, $66, $3C, $18, $18, $3C, $00
00000960 FE86 0C18 3062 FE00 7C60+  	dc.b	$FE, $86, $0C, $18, $30, $62, $FE, $00, $7C, $60, $60, $60
0000096C 6060 7C00 C060 3018 0C06+  	dc.b	$60, $60, $7C, $00, $C0, $60, $30, $18, $0C, $06, $02, $00
00000978 7C0C 0C0C 0C0C 7C00 1038+  	dc.b	$7C, $0C, $0C, $0C, $0C, $0C, $7C, $00, $10, $38, $6C, $C6
00000984 0000 0000 0000 0000 0000+  	dc.b	$00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $FF
00000990 3030 1800 0000 0000 0000+  	dc.b	$30, $30, $18, $00, $00, $00, $00, $00, $00, $00, $78, $0C
0000099C 7CCC 7E00 E060 7C66 6666+  	dc.b	$7C, $CC, $7E, $00, $E0, $60, $7C, $66, $66, $66, $FC, $00
000009A8 0000 7CC6 C0C6 7C00 1C0C+  	dc.b	$00, $00, $7C, $C6, $C0, $C6, $7C, $00, $1C, $0C, $7C, $CC
000009B4 CCCC 7E00 0000 7CC6 FEC0+  	dc.b	$CC, $CC, $7E, $00, $00, $00, $7C, $C6, $FE, $C0, $7C, $00
000009C0 1C36 30FC 3030 7800 0000+  	dc.b	$1C, $36, $30, $FC, $30, $30, $78, $00, $00, $00, $76, $CE
000009CC C67E 067C E060 7C66 6666+  	dc.b	$C6, $7E, $06, $7C, $E0, $60, $7C, $66, $66, $66, $E6, $00
000009D8 1800 3818 1818 3C00 0C00+  	dc.b	$18, $00, $38, $18, $18, $18, $3C, $00, $0C, $00, $1C, $0C
000009E4 0C0C CC78 E060 666C 786C+  	dc.b	$0C, $0C, $CC, $78, $E0, $60, $66, $6C, $78, $6C, $E6, $00
000009F0 1818 1818 1818 1C00 0000+  	dc.b	$18, $18, $18, $18, $18, $18, $1C, $00, $00, $00, $6C, $FE
000009FC D6D6 C600 0000 DC66 6666+  	dc.b	$D6, $D6, $C6, $00, $00, $00, $DC, $66, $66, $66, $66, $00
00000A08 0000 7CC6 C6C6 7C00 0000+  	dc.b	$00, $00, $7C, $C6, $C6, $C6, $7C, $00, $00, $00, $DC, $66
00000A14 667C 60F0 0000 76CC CC7C+  	dc.b	$66, $7C, $60, $F0, $00, $00, $76, $CC, $CC, $7C, $0C, $1E
00000A20 0000 DC66 6060 F000 0000+  	dc.b	$00, $00, $DC, $66, $60, $60, $F0, $00, $00, $00, $7C, $C0
00000A2C 7C06 7C00 3030 FC30 3036+  	dc.b	$7C, $06, $7C, $00, $30, $30, $FC, $30, $30, $36, $1C, $00
00000A38 0000 CCCC CCCC 7600 0000+  	dc.b	$00, $00, $CC, $CC, $CC, $CC, $76, $00, $00, $00, $C6, $C6
00000A44 6C38 1000 0000 C6C6 D6FE+  	dc.b	$6C, $38, $10, $00, $00, $00, $C6, $C6, $D6, $FE, $6C, $00
00000A50 0000 C66C 386C C600 0000+  	dc.b	$00, $00, $C6, $6C, $38, $6C, $C6, $00, $00, $00, $C6, $C6
00000A5C CE76 067C 0000 FC98 3064+  	dc.b	$CE, $76, $06, $7C, $00, $00, $FC, $98, $30, $64, $FC, $00
00000A68 0E18 1870 1818 0E00 1818+  	dc.b	$0E, $18, $18, $70, $18, $18, $0E, $00, $18, $18, $18, $00
00000A74 1818 1800 7018 180E 1818+  	dc.b	$18, $18, $18, $00, $70, $18, $18, $0E, $18, $18, $70, $00
00000A80 76DC 0000 0000 0000 43FA+  	dc.b	$76, $DC, $00, $00, $00, $00, $00, $00, $43, $FA, $05, $D2
00000A8C 0C59 DEB2 6670 70FE D059+  	dc.b	$0C, $59, $DE, $B2, $66, $70, $70, $FE, $D0, $59, $74, $FC
00000A98 7600 4841 4881 D241 D241+  	dc.b	$76, $00, $48, $41, $48, $81, $D2, $41, $D2, $41, $B2, $40
00000AA4 625C 675E 2031 1000 6758+  	dc.b	$62, $5C, $67, $5E, $20, $31, $10, $00, $67, $58, $47, $F1
00000AB0 0800 4841 7000 301B B253+  	dc.b	$08, $00, $48, $41, $70, $00, $30, $1B, $B2, $53, $65, $4C
00000ABC 43F3 08FE 45E9 FFFC E248+  	dc.b	$43, $F3, $08, $FE, $45, $E9, $FF, $FC, $E2, $48, $C0, $42
00000AC8 B273 0000 6514 6204 D6C0+  	dc.b	$B2, $73, $00, $00, $65, $14, $62, $04, $D6, $C0, $60, $1A
00000AD4 47F3 0004 200A 908B 6AE6+  	dc.b	$47, $F3, $00, $04, $20, $0A, $90, $8B, $6A, $E6, $59, $4B
00000AE0 600C 45F3 00FC 200A 908B+  	dc.b	$60, $0C, $45, $F3, $00, $FC, $20, $0A, $90, $8B, $6A, $D8
00000AEC 47D2 925B 7400 341B D3C2+  	dc.b	$47, $D2, $92, $5B, $74, $00, $34, $1B, $D3, $C2, $48, $41
00000AF8 4241 4841 D283 7000 4E75+  	dc.b	$42, $41, $48, $41, $D2, $83, $70, $00, $4E, $75, $70, $FF
00000B04 4E75 4841 7000 3001 D680+  	dc.b	$4E, $75, $48, $41, $70, $00, $30, $01, $D6, $80, $52, $83
00000B10 323C FFFF 4841 5941 6A8E+  	dc.b	$32, $3C, $FF, $FF, $48, $41, $59, $41, $6A, $8E, $70, $FF
00000B1C 4E75 47FA 053C 0C5B DEB2+  	dc.b	$4E, $75, $47, $FA, $05, $3C, $0C, $5B, $DE, $B2, $66, $4A
00000B28 D6D3 7800 7200 7400 45D3+  	dc.b	$D6, $D3, $78, $00, $72, $00, $74, $00, $45, $D3, $51, $CC
00000B34 0006 1619 7807 D603 D341+  	dc.b	$00, $06, $16, $19, $78, $07, $D6, $03, $D3, $41, $52, $42
00000B40 B252 620A 65EC B42A 0002+  	dc.b	$B2, $52, $62, $0A, $65, $EC, $B4, $2A, $00, $02, $67, $12
00000B4C 65E4 584A B252 62FA 65DC+  	dc.b	$65, $E4, $58, $4A, $B2, $52, $62, $FA, $65, $DC, $B4, $2A
00000B58 0002 65D6 66F0 10EA 0003+  	dc.b	$00, $02, $65, $D6, $66, $F0, $10, $EA, $00, $03, $67, $0A
00000B64 51CF FFC6 4E94 64C0 4E75+  	dc.b	$51, $CF, $FF, $C6, $4E, $94, $64, $C0, $4E, $75, $53, $48
00000B70 4E75 7000 4E75 4EFA 002E+  	dc.b	$4E, $75, $70, $00, $4E, $75, $4E, $FA, $00, $2E, $4E, $FA
00000B7C 0022 760F 3401 E84A C443+  	dc.b	$00, $22, $76, $0F, $34, $01, $E8, $4A, $C4, $43, $10, $FB
00000B88 206A 51CF 0006 4E94 655E+  	dc.b	$20, $6A, $51, $CF, $00, $06, $4E, $94, $65, $5E, $C2, $43
00000B94 10FB 105C 51CF 0056 4ED4+  	dc.b	$10, $FB, $10, $5C, $51, $CF, $00, $56, $4E, $D4, $48, $41
00000BA0 6104 654C 4841 7404 760F+  	dc.b	$61, $04, $65, $4C, $48, $41, $74, $04, $76, $0F, $E5, $79
00000BAC 1801 C843 10FB 4040 51CF+  	dc.b	$18, $01, $C8, $43, $10, $FB, $40, $40, $51, $CF, $00, $04
00000BB8 4E94 6534 E579 1801 C843+  	dc.b	$4E, $94, $65, $34, $E5, $79, $18, $01, $C8, $43, $10, $FB
00000BC4 402E 51CF 0004 4E94 6522+  	dc.b	$40, $2E, $51, $CF, $00, $04, $4E, $94, $65, $22, $E5, $79
00000BD0 1801 C843 10FB 401C 51CF+  	dc.b	$18, $01, $C8, $43, $10, $FB, $40, $1C, $51, $CF, $00, $04
00000BDC 4E94 6510 E579 1801 C843+  	dc.b	$4E, $94, $65, $10, $E5, $79, $18, $01, $C8, $43, $10, $FB
00000BE8 400A 51CF 0004 4ED4 4E75+  	dc.b	$40, $0A, $51, $CF, $00, $04, $4E, $D4, $4E, $75, $30, $31
00000BF4 3233 3435 3637 3839 4142+  	dc.b	$32, $33, $34, $35, $36, $37, $38, $39, $41, $42, $43, $44
00000C00 4546 4EFA 0026 4EFA 001A+  	dc.b	$45, $46, $4E, $FA, $00, $26, $4E, $FA, $00, $1A, $74, $07
00000C0C 7018 D201 D100 10C0 51CF+  	dc.b	$70, $18, $D2, $01, $D1, $00, $10, $C0, $51, $CF, $00, $06
00000C18 4E94 6504 51CA FFEE 4E75+  	dc.b	$4E, $94, $65, $04, $51, $CA, $FF, $EE, $4E, $75, $48, $41
00000C24 6104 6518 4841 740F 7018+  	dc.b	$61, $04, $65, $18, $48, $41, $74, $0F, $70, $18, $D2, $41
00000C30 D100 10C0 51CF 0006 4E94+  	dc.b	$D1, $00, $10, $C0, $51, $CF, $00, $06, $4E, $94, $65, $04
00000C3C 51CA FFEE 4E75 4EFA 0010+  	dc.b	$51, $CA, $FF, $EE, $4E, $75, $4E, $FA, $00, $10, $4E, $FA
00000C48 0048 47FA 009A 0241 00FF+  	dc.b	$00, $48, $47, $FA, $00, $9A, $02, $41, $00, $FF, $60, $04
00000C54 47FA 008C 4200 7609 381B+  	dc.b	$47, $FA, $00, $8C, $42, $00, $76, $09, $38, $1B, $34, $03
00000C60 9244 55CA FFFC D244 9443+  	dc.b	$92, $44, $55, $CA, $FF, $FC, $D2, $44, $94, $43, $44, $42
00000C6C 8002 670E 0602 0030 10C2+  	dc.b	$80, $02, $67, $0E, $06, $02, $00, $30, $10, $C2, $51, $CF
00000C78 0006 4E94 6510 381B 6ADC+  	dc.b	$00, $06, $4E, $94, $65, $10, $38, $1B, $6A, $DC, $06, $01
00000C84 0030 10C1 51CF 0004 4ED4+  	dc.b	$00, $30, $10, $C1, $51, $CF, $00, $04, $4E, $D4, $4E, $75
00000C90 47FA 002E 4200 7609 281B+  	dc.b	$47, $FA, $00, $2E, $42, $00, $76, $09, $28, $1B, $34, $03
00000C9C 9284 55CA FFFC D284 9443+  	dc.b	$92, $84, $55, $CA, $FF, $FC, $D2, $84, $94, $43, $44, $42
00000CA8 8002 670E 0602 0030 10C2+  	dc.b	$80, $02, $67, $0E, $06, $02, $00, $30, $10, $C2, $51, $CF
00000CB4 0006 4E94 65D4 281B 6ADC+  	dc.b	$00, $06, $4E, $94, $65, $D4, $28, $1B, $6A, $DC, $60, $9E
00000CC0 3B9A CA00 05F5 E100 0098+  	dc.b	$3B, $9A, $CA, $00, $05, $F5, $E1, $00, $00, $98, $96, $80
00000CCC 000F 4240 0001 86A0 0000+  	dc.b	$00, $0F, $42, $40, $00, $01, $86, $A0, $00, $00, $27, $10
00000CD8 FFFF 03E8 0064 000A FFFF+  	dc.b	$FF, $FF, $03, $E8, $00, $64, $00, $0A, $FF, $FF, $27, $10
00000CE4 03E8 0064 000A FFFF 48C1+  	dc.b	$03, $E8, $00, $64, $00, $0A, $FF, $FF, $48, $C1, $60, $08
00000CF0 4EFA 0006 4881 48C1 0803+  	dc.b	$4E, $FA, $00, $06, $48, $81, $48, $C1, $08, $03, $00, $03
00000CFC 6604 487A 00CE 48E7 5060+  	dc.b	$66, $04, $48, $7A, $00, $CE, $48, $E7, $50, $60, $4E, $BA
00000D08 FD80 660C 2E81 4EBA FE0E+  	dc.b	$FD, $80, $66, $0C, $2E, $81, $4E, $BA, $FE, $0E, $4C, $DF
00000D14 060A 4E75 4CDF 060A 0803+  	dc.b	$06, $0A, $4E, $75, $4C, $DF, $06, $0A, $08, $03, $00, $02
00000D20 6708 47FA 000A 4EFA 00B8+  	dc.b	$67, $08, $47, $FA, $00, $0A, $4E, $FA, $00, $B8, $70, $FF
00000D2C 4E75 3C75 6E6B 6E6F 776E+  	dc.b	$4E, $75, $3C, $75, $6E, $6B, $6E, $6F, $77, $6E, $3E, $00
00000D38 10FC 002B 51CF 0006 4E94+  	dc.b	$10, $FC, $00, $2B, $51, $CF, $00, $06, $4E, $94, $65, $D2
00000D44 4841 4A41 6700 FE5A 4EBA+  	dc.b	$48, $41, $4A, $41, $67, $00, $FE, $5A, $4E, $BA, $FE, $58
00000D50 4EFA FE52 0803 0003 66BC+  	dc.b	$4E, $FA, $FE, $52, $08, $03, $00, $03, $66, $BC, $4E, $FA
00000D5C FE42 48E7 F810 10D9 5FCF+  	dc.b	$FE, $42, $48, $E7, $F8, $10, $10, $D9, $5F, $CF, $FF, $FC
00000D68 6E14 6718 1620 7470 C403+  	dc.b	$6E, $14, $67, $18, $16, $20, $74, $70, $C4, $03, $4E, $BB
00000D74 201A 64EA 4CDF 081F 4E75+  	dc.b	$20, $1A, $64, $EA, $4C, $DF, $08, $1F, $4E, $75, $4E, $94
00000D80 64E0 60F4 5348 4E94 4CDF+  	dc.b	$64, $E0, $60, $F4, $53, $48, $4E, $94, $4C, $DF, $08, $1F
00000D8C 4E75 47FA FDE6 B702 D402+  	dc.b	$4E, $75, $47, $FA, $FD, $E6, $B7, $02, $D4, $02, $4E, $FB
00000D98 205A 4E71 4E71 47FA FEA2+  	dc.b	$20, $5A, $4E, $71, $4E, $71, $47, $FA, $FE, $A2, $B7, $02
00000DA4 D402 4EFB 204A 4E71 4E71+  	dc.b	$D4, $02, $4E, $FB, $20, $4A, $4E, $71, $4E, $71, $47, $FA
00000DB0 FE52 B702 D402 4EFB 203A+  	dc.b	$FE, $52, $B7, $02, $D4, $02, $4E, $FB, $20, $3A, $53, $48
00000DBC 4E75 47FA FF2C 1403 0242+  	dc.b	$4E, $75, $47, $FA, $FF, $2C, $14, $03, $02, $42, $00, $03
00000DC8 D442 4EFB 2026 4A40 6B08+  	dc.b	$D4, $42, $4E, $FB, $20, $26, $4A, $40, $6B, $08, $4A, $81
00000DD4 6716 4EFA FF60 4EFA FF78+  	dc.b	$67, $16, $4E, $FA, $FF, $60, $4E, $FA, $FF, $78, $26, $5A
00000DE0 10DB 67D6 51CF FFFA 4E94+  	dc.b	$10, $DB, $67, $D6, $51, $CF, $FF, $FA, $4E, $94, $64, $F4
00000DEC 4E75 5248 603C 504B 321A+  	dc.b	$4E, $75, $52, $48, $60, $3C, $50, $4B, $32, $1A, $4E, $D3
00000DF8 584B 221A 4ED3 5248 6022+  	dc.b	$58, $4B, $22, $1A, $4E, $D3, $52, $48, $60, $22, $50, $4B
00000E04 321A 6004 584B 221A 6A0C+  	dc.b	$32, $1A, $60, $04, $58, $4B, $22, $1A, $6A, $0C, $44, $81
00000E10 10FC 002D 5347 65D4 4ED3+  	dc.b	$10, $FC, $00, $2D, $53, $47, $65, $D4, $4E, $D3, $10, $FC
00000E1C 002B 5347 65CA 4ED3 51CF+  	dc.b	$00, $2B, $53, $47, $65, $CA, $4E, $D3, $51, $CF, $00, $06
00000E28 4E94 65C0 10D9 51CF FFBC+  	dc.b	$4E, $94, $65, $C0, $10, $D9, $51, $CF, $FF, $BC, $4E, $D4
00000E34 4BF9 00C0 0004 4DED FFFC+  	dc.b	$4B, $F9, $00, $C0, $00, $04, $4D, $ED, $FF, $FC, $4A, $51
00000E40 6B10 2A99 41D2 3818 4EBA+  	dc.b	$6B, $10, $2A, $99, $41, $D2, $38, $18, $4E, $BA, $01, $F6
00000E4C 43E9 0020 60EC 5449 4E63+  	dc.b	$43, $E9, $00, $20, $60, $EC, $54, $49, $4E, $63, $2A, $19
00000E58 26C5 26D9 26D9 36FC 5D00+  	dc.b	$26, $C5, $26, $D9, $26, $D9, $36, $FC, $5D, $00, $47, $FA
00000E64 003A 2A85 7000 3219 4E93+  	dc.b	$00, $3A, $2A, $85, $70, $00, $32, $19, $4E, $93, $2A, $BC
00000E70 4000 0000 7200 4E93 2ABC+  	dc.b	$40, $00, $00, $00, $72, $00, $4E, $93, $2A, $BC, $C0, $00
00000E7C 0000 7000 7603 3C80 3419+  	dc.b	$00, $00, $70, $00, $76, $03, $3C, $80, $34, $19, $3C, $82
00000E88 3419 6AFA 7200 4EB3 2010+  	dc.b	$34, $19, $6A, $FA, $72, $00, $4E, $B3, $20, $10, $51, $CB
00000E94 FFEE 3ABC 8174 2A85 4E75+  	dc.b	$FF, $EE, $3A, $BC, $81, $74, $2A, $85, $4E, $75, $2C, $80
00000EA0 2C80 2C80 2C80 2C80 2C80+  	dc.b	$2C, $80, $2C, $80, $2C, $80, $2C, $80, $2C, $80, $2C, $80
00000EAC 2C80 51C9 FFEE 4E75 4CAF+  	dc.b	$2C, $80, $51, $C9, $FF, $EE, $4E, $75, $4C, $AF, $00, $03
00000EB8 0004 48E7 6010 4E6B 0C2B+  	dc.b	$00, $04, $48, $E7, $60, $10, $4E, $6B, $0C, $2B, $00, $5D
00000EC4 000C 6618 3413 0242 E000+  	dc.b	$00, $0C, $66, $18, $34, $13, $02, $42, $E0, $00, $C2, $EB
00000ED0 000A D441 D440 D440 3682+  	dc.b	$00, $0A, $D4, $41, $D4, $40, $D4, $40, $36, $82, $23, $D3
00000EDC 00C0 0004 4CDF 0806 4E75+  	dc.b	$00, $C0, $00, $04, $4C, $DF, $08, $06, $4E, $75, $2F, $0B
00000EE8 4E6B 0C2B 005D 000C 6612+  	dc.b	$4E, $6B, $0C, $2B, $00, $5D, $00, $0C, $66, $12, $72, $00
00000EF4 3213 0241 1FFF 82EB 000A+  	dc.b	$32, $13, $02, $41, $1F, $FF, $82, $EB, $00, $0A, $20, $01
00000F00 4840 E248 265F 4E75 2F0B+  	dc.b	$48, $40, $E2, $48, $26, $5F, $4E, $75, $2F, $0B, $4E, $6B
00000F0C 0C2B 005D 000C 6618 3F00+  	dc.b	$0C, $2B, $00, $5D, $00, $0C, $66, $18, $3F, $00, $30, $13
00000F18 D06B 000A 0240 5FFF 3680+  	dc.b	$D0, $6B, $00, $0A, $02, $40, $5F, $FF, $36, $80, $23, $DB
00000F24 00C0 0004 36DB 301F 265F+  	dc.b	$00, $C0, $00, $04, $36, $DB, $30, $1F, $26, $5F, $4E, $75
00000F30 2F0B 4E6B 0C2B 005D 000C+  	dc.b	$2F, $0B, $4E, $6B, $0C, $2B, $00, $5D, $00, $0C, $66, $04
00000F3C 3741 0008 265F 4E75 2F0B+  	dc.b	$37, $41, $00, $08, $26, $5F, $4E, $75, $2F, $0B, $4E, $6B
00000F48 0C2B 005D 000C 6606 584B+  	dc.b	$0C, $2B, $00, $5D, $00, $0C, $66, $06, $58, $4B, $36, $C1
00000F54 36C1 265F 4E75 61D4 487A+  	dc.b	$36, $C1, $26, $5F, $4E, $75, $61, $D4, $48, $7A, $FF, $AA
00000F60 48E7 7E12 4E6B 0C2B 005D+  	dc.b	$48, $E7, $7E, $12, $4E, $6B, $0C, $2B, $00, $5D, $00, $0C
00000F6C 661C 2A1B 4C93 005C 4846+  	dc.b	$66, $1C, $2A, $1B, $4C, $93, $00, $5C, $48, $46, $4D, $F9
00000F78 00C0 0000 7200 1218 6E0E+  	dc.b	$00, $C0, $00, $00, $72, $00, $12, $18, $6E, $0E, $6B, $28
00000F84 4893 001C 2705 4CDF 487E+  	dc.b	$48, $93, $00, $1C, $27, $05, $4C, $DF, $48, $7E, $4E, $75
00000F90 51CB 000E D642 DA86 0885+  	dc.b	$51, $CB, $00, $0E, $D6, $42, $DA, $86, $08, $85, $00, $1D
00000F9C 2D45 0004 D244 3C81 7200+  	dc.b	$2D, $45, $00, $04, $D2, $44, $3C, $81, $72, $00, $12, $18
00000FA8 6EE6 67D8 0241 001E 4EFB+  	dc.b	$6E, $E6, $67, $D8, $02, $41, $00, $1E, $4E, $FB, $10, $02
00000FB4 DA86 721D 0385 6020 6026+  	dc.b	$DA, $86, $72, $1D, $03, $85, $60, $20, $60, $26, $60, $2A
00000FC0 6032 603A 1418 6014 1818+  	dc.b	$60, $32, $60, $3A, $14, $18, $60, $14, $18, $18, $60, $D8
00000FCC 6036 1218 D241 7680 4843+  	dc.b	$60, $36, $12, $18, $D2, $41, $76, $80, $48, $43, $CA, $83
00000FD8 4841 8A81 3602 2D45 0004+  	dc.b	$48, $41, $8A, $81, $36, $02, $2D, $45, $00, $04, $60, $C0
00000FE4 0244 07FF 60BA 0244 07FF+  	dc.b	$02, $44, $07, $FF, $60, $BA, $02, $44, $07, $FF, $00, $44
00000FF0 2000 60B0 0244 07FF 0044+  	dc.b	$20, $00, $60, $B0, $02, $44, $07, $FF, $00, $44, $40, $00
00000FFC 60A6 0044 6000 60A0 3F04+  	dc.b	$60, $A6, $00, $44, $60, $00, $60, $A0, $3F, $04, $1E, $98
00001008 381F 6098 487A FEFA 2F0C+  	dc.b	$38, $1F, $60, $98, $48, $7A, $FE, $FA, $2F, $0C, $49, $FA
00001014 0016 4FEF FFF0 41D7 7E0E+  	dc.b	$00, $16, $4F, $EF, $FF, $F0, $41, $D7, $7E, $0E, $4E, $BA
00001020 FD3E 4FEF 0010 285F 4E75+  	dc.b	$FD, $3E, $4F, $EF, $00, $10, $28, $5F, $4E, $75, $42, $18
0000102C 4447 0647 000F 90C7 2F08+  	dc.b	$44, $47, $06, $47, $00, $0F, $90, $C7, $2F, $08, $4E, $BA
00001038 FF28 205F 7E0E 4E75 741E+  	dc.b	$FF, $28, $20, $5F, $7E, $0E, $4E, $75, $74, $1E, $10, $18
00001044 1200 E609 C242 3CB1 1000+  	dc.b	$12, $00, $E6, $09, $C2, $42, $3C, $B1, $10, $00, $D0, $00
00001050 C042 3CB1 0000 51CC FFEA+  	dc.b	$C0, $42, $3C, $B1, $00, $00, $51, $CC, $FF, $EA, $4E, $75
0000105C                            
0000105C                            ; ---------------------------------------------------------------
0000105C                            ; WARNING!
0000105C                            ;	DO NOT put any data from now on! DO NOT use ROM padding!
0000105C                            ;	Symbol data should be appended here after ROM is compiled
0000105C                            ;	by ConvSym utility, otherwise debugger modules won't be able
0000105C                            ;	to resolve symbol names.
0000105C                            ; ---------------------------------------------------------------
0000105C                            
0000105C                            ; ---------------------------------------------------------------------------
0000105C                            ; Libraries
0000105C                            ; ---------------------------------------------------------------------------
0000105C                            
0000105C                            	include	"_lib/decompress.68k"			; Decompression library
0000105C                            ; ---------------------------------------------------------------------------
0000105C                            ; Mega Drive Framework
0000105C                            ; By Devon 2022
0000105C                            ; ---------------------------------------------------------------------------
0000105C                            
0000105C                            ; ---------------------------------------------------------------------------
0000105C                            ; Decode 1BPP graphics data into 4BPP
0000105C                            ; VDP command should be set beforehand if type = 1
0000105C                            ; ---------------------------------------------------------------------------
0000105C                            ; PARAMETERS:
0000105C                            ;	type - Memory type (0 = Regular RAM, 1 = VRAM)
0000105C                            ;	d0.b - Palette entry for set pixels
0000105C                            ;	d1.w - Size of 1BPP graphics data (minus 1)
0000105C                            ;	a0.l - Pointer to 1BPP graphics data
0000105C                            ;	a1.l - Destination buffer for decoded graphics data (if type = 0)
0000105C                            ; ---------------------------------------------------------------------------
0000105C                            
0000105C                            DEC1BPP macro type
0000105C                            	andi.b	#$F,d0					; Force palette entry to be 4-bit
0000105C                          M 	anxi.b	#$f,d0
0000105C                            
0000105C                            .DecodeLoop:
0000105C                            	moveq	#0,d2					; Clear pixel buffer
0000105C                            	move.b	(a0)+,d3				; Get row of pixels
0000105C                            	moveq	#8-1,d4					; Pixels per row
0000105C                            
0000105C                            .DecodeRowLoop:
0000105C                            	lsl.l	#4,d2					; Make room for next pixel
0000105C                            	add.b	d3,d3					; Shift pixels out
0000105C                            	bcc.s	.DecodeRowDoLoop			; If the current pixel wasn't set, branch
0000105C                            	or.b	d0,d2					; Place set pixel
0000105C                            
0000105C                            .DecodeRowDoLoop:
0000105C                            	dbf	d4,.DecodeRowLoop			; Loop until row is decoded
0000105C                            	if (\type)=0
0000105C                            		move.l	d2,(a1)+			; Copy row to buffer
0000105C                            	else
0000105C                            		move.l	d2,VDPDATA			; Copy row to VRAM
0000105C                            	endif
0000105C                            	dbf	d1,.DecodeLoop				; Loop until all rows are decoded
0000105C                            	endm
0000105C                            
0000105C                            ; ---------------------------------------------------------------------------
0000105C                            ; Decode 1BPP graphics data into 4BPP in regular RAM
0000105C                            ; ---------------------------------------------------------------------------
0000105C                            ; PARAMETERS:
0000105C                            ;	d0.b - Palette entry for set pixels
0000105C                            ;	d1.w - Size of 1BPP graphics data (minus 1)
0000105C                            ;	a0.l - Pointer to 1BPP graphics data
0000105C                            ;	a1.l - Destination buffer for decoded graphics data
0000105C                            ; ---------------------------------------------------------------------------
0000105C                            
0000105C                            Decode1BPPToRAM:
0000105C                            	DEC1BPP	0
0000105C 0200 000F                M 	anxi.b	#$f,d0
00001060                          M .decodeloop:
00001060 7400                     M 	moveq	#0,d2
00001062 1618                     M 	move.b	(a0)+,d3
00001064 7807                     M 	moveq	#8-1,d4
00001066                          M .decoderowloop:
00001066 E98A                     M 	lsl.l	#4,d2
00001068                          M 	add.b	d3,d3
00001068                          M 	local	num
00001068 D603                     M 	axd.b	d3,d3
0000106A 6400                     M 	bcc.s	.decoderowdoloop
0000106C                          M 	or.b	d0,d2
0000106C                          M 	local	num
0000106C 8400                     M 	ox.b	d0,d2
0000106E                          M .decoderowdoloop:
0000106E 51CC FFF6                M 	dbf	d4,.decoderowloop
00001072 22C2                     M 	move.l	d2,(a1)+
00001074 51C9 FFEA                M 	dbf	d1,.decodeloop
00001078 4E75                       	rts
0000107A                            
0000107A                            ; ---------------------------------------------------------------------------
0000107A                            ; Decode 1BPP graphics data into 4BPP in VRAM
0000107A                            ; VDP command should be set beforehand
0000107A                            ; ---------------------------------------------------------------------------
0000107A                            ; PARAMETERS:
0000107A                            ;	d0.b - Palette entry for set pixels
0000107A                            ;	d1.w - Size of 1BPP graphics data (minus 1)
0000107A                            ;	a0.l - Pointer to 1BPP graphics data
0000107A                            ; ---------------------------------------------------------------------------
0000107A                            
0000107A                            Decode1BPPToVRAM:
0000107A                            	DEC1BPP	1
0000107A 0200 000F                M 	anxi.b	#$f,d0
0000107E                          M .decodeloop:
0000107E 7400                     M 	moveq	#0,d2
00001080 1618                     M 	move.b	(a0)+,d3
00001082 7807                     M 	moveq	#8-1,d4
00001084                          M .decoderowloop:
00001084 E98A                     M 	lsl.l	#4,d2
00001086                          M 	add.b	d3,d3
00001086                          M 	local	num
00001086 D603                     M 	axd.b	d3,d3
00001088 6400                     M 	bcc.s	.decoderowdoloop
0000108A                          M 	or.b	d0,d2
0000108A                          M 	local	num
0000108A 8400                     M 	ox.b	d0,d2
0000108C                          M .decoderowdoloop:
0000108C 51CC FFF6                M 	dbf	d4,.decoderowloop
00001090 23C2 00C0 0000           M 	move.l	d2,vdpdata
00001096 51C9 FFE6                M 	dbf	d1,.decodeloop
0000109A 4E75                       	rts
0000109C                            
0000109C                            ; ---------------------------------------------------------------------------
0000109C                            ; Kosinski decompression (General purpose)
0000109C                            ; New faster version by written by vladikcomper, with additional
0000109C                            ; improvements by MarkeyJester and Flamewing
0000109C                            ; ---------------------------------------------------------------------------
0000109C                            ; PARAMETERS:
0000109C                            ;	a0.l - Source address
0000109C                            ;	a1.l - Destination address
0000109C                            ; ---------------------------------------------------------------------------
0000109C                            ; RETURNS:
0000109C                            ;	a1.l - End of decompressed data address
0000109C                            ; ---------------------------------------------------------------------------
0000109C                            
0000109C =00000001                  _Kos_UseLUT			equ	1
0000109C =00000003                  _Kos_LoopUnroll			equ	3
0000109C =00000001                  _Kos_ExtremeUnrolling		equ	1
0000109C                            
0000109C                            ; ---------------------------------------------------------------------------
0000109C                            
0000109C                            _Kos_RunBitStream macro
0000109C                            	dbra	d2,.Skip\@
0000109C                            	moveq	#7,d2				; Set repeat count to 8.
0000109C                            	move.b	d1,d0				; Use the remaining 8 bits.
0000109C                            	not.w	d3				; Have all 16 bits been used up?
0000109C                            	bne.s	.Skip\@				; Branch if not.
0000109C                            	move.b	(a0)+,d0			; Get desc field low-byte.
0000109C                            	move.b	(a0)+,d1			; Get desc field hi-byte.
0000109C                            	if _Kos_UseLUT=1
0000109C                            		move.b	(a4,d0.w),d0		; Invert bit order...
0000109C                            		move.b	(a4,d1.w),d1		; ... for both bytes.
0000109C                            	endif
0000109C                            
0000109C                            .Skip\@:
0000109C                            	endm
0000109C                            
0000109C                            ; ---------------------------------------------------------------------------
0000109C                            
0000109C                            _Kos_ReadBit macro
0000109C                            	if _Kos_UseLUT=1
0000109C                            		add.b	d0,d0			; Get a bit from the bitstream.
0000109C                            	else
0000109C                            		lsr.b	#1,d0			; Get a bit from the bitstream.
0000109C                            	endif
0000109C                            	endm
0000109C                            
0000109C                            ; ---------------------------------------------------------------------------
0000109C                            
0000109C                            KosDec:
0000109C 7E07                       	moveq	#(1<<_Kos_LoopUnroll)-1,d7
0000109E 7000                       		moveq	#0,d0
000010A0 7200                       		moveq	#0,d1
000010A2 49FA 0000                  		lea	KosDec_ByteMap(pc),a4	; Load LUT pointer.
000010A6 1018                       	move.b	(a0)+,d0			; Get desc field low-byte.
000010A8 1218                       	move.b	(a0)+,d1			; Get desc field hi-byte.
000010AA 1034 0000                  		move.b	(a4,d0.w),d0		; Invert bit order...
000010AE 1234 1000                  		move.b	(a4,d1.w),d1		; ... for both bytes.
000010B2 7407                       	moveq	#7,d2				; Set repeat count to 8.
000010B4 7600                       	moveq	#0,d3				; d3 will be desc field switcher.
000010B6 6000                       	bra.s	@FetchNewCode
000010B8                            
000010B8                            ; ---------------------------------------------------------------------------
000010B8                            
000010B8                            @FetchCodeLoop:
000010B8                            	; Code 1 (Uncompressed byte).
000010B8                            	_Kos_RunBitStream
000010B8 51CA 0000                M 	dbra	d2,.skip_88
000010BC 7407                     M 	moveq	#7,d2
000010BE 1001                     M 	move.b	d1,d0
000010C0 4643                     M 	not.w	d3
000010C2 6600                     M 	bne.s	.skip_88
000010C4 1018                     M 	move.b	(a0)+,d0
000010C6 1218                     M 	move.b	(a0)+,d1
000010C8 1034 0000                M 	move.b	(a4,d0.w),d0
000010CC 1234 1000                M 	move.b	(a4,d1.w),d1
000010D0                          M .skip_88:
000010D0 12D8                       	move.b	(a0)+,(a1)+
000010D2                             
000010D2                            @FetchNewCode:
000010D2                            	_Kos_ReadBit
000010D2                          M 	add.b	d0,d0
000010D2                          M 	local	num
000010D2 D000                     M 	axd.b	d0,d0
000010D4 65E2                       	bcs.s	@FetchCodeLoop			; If code = 1, branch.
000010D6                             
000010D6                            	; Codes 00 and 01.
000010D6 7AFF                       	moveq	#-1,d5
000010D8 4BD1                       	lea	(a1),a5
000010DA                            	_Kos_RunBitStream
000010DA 51CA 0000                M 	dbra	d2,.skip_91
000010DE 7407                     M 	moveq	#7,d2
000010E0 1001                     M 	move.b	d1,d0
000010E2 4643                     M 	not.w	d3
000010E4 6600                     M 	bne.s	.skip_91
000010E6 1018                     M 	move.b	(a0)+,d0
000010E8 1218                     M 	move.b	(a0)+,d1
000010EA 1034 0000                M 	move.b	(a4,d0.w),d0
000010EE 1234 1000                M 	move.b	(a4,d1.w),d1
000010F2                          M .skip_91:
000010F2                            		_Kos_ReadBit
000010F2                          M 	add.b	d0,d0
000010F2                          M 	local	num
000010F2 D000                     M 	axd.b	d0,d0
000010F4 6500 0000                  		bcs.w	@Code_01
000010F8                             
000010F8                            		; Code 00 (Dictionary ref. short).
000010F8                            		_Kos_RunBitStream
000010F8 51CA 0000                M 	dbra	d2,.skip_94
000010FC 7407                     M 	moveq	#7,d2
000010FE 1001                     M 	move.b	d1,d0
00001100 4643                     M 	not.w	d3
00001102 6600                     M 	bne.s	.skip_94
00001104 1018                     M 	move.b	(a0)+,d0
00001106 1218                     M 	move.b	(a0)+,d1
00001108 1034 0000                M 	move.b	(a4,d0.w),d0
0000110C 1234 1000                M 	move.b	(a4,d1.w),d1
00001110                          M .skip_94:
00001110                            		_Kos_ReadBit
00001110                          M 	add.b	d0,d0
00001110                          M 	local	num
00001110 D000                     M 	axd.b	d0,d0
00001112 6500                       		bcs.s	@Copy45
00001114                            		_Kos_RunBitStream
00001114 51CA 0000                M 	dbra	d2,.skip_97
00001118 7407                     M 	moveq	#7,d2
0000111A 1001                     M 	move.b	d1,d0
0000111C 4643                     M 	not.w	d3
0000111E 6600                     M 	bne.s	.skip_97
00001120 1018                     M 	move.b	(a0)+,d0
00001122 1218                     M 	move.b	(a0)+,d1
00001124 1034 0000                M 	move.b	(a4,d0.w),d0
00001128 1234 1000                M 	move.b	(a4,d1.w),d1
0000112C                          M .skip_97:
0000112C                            		_Kos_ReadBit
0000112C                          M 	add.b	d0,d0
0000112C                          M 	local	num
0000112C D000                     M 	axd.b	d0,d0
0000112E 6500                       		bcs.s	@Copy3
00001130                            		_Kos_RunBitStream
00001130 51CA 0000                M 	dbra	d2,.skip_100
00001134 7407                     M 	moveq	#7,d2
00001136 1001                     M 	move.b	d1,d0
00001138 4643                     M 	not.w	d3
0000113A 6600                     M 	bne.s	.skip_100
0000113C 1018                     M 	move.b	(a0)+,d0
0000113E 1218                     M 	move.b	(a0)+,d1
00001140 1034 0000                M 	move.b	(a4,d0.w),d0
00001144 1234 1000                M 	move.b	(a4,d1.w),d1
00001148                          M .skip_100:
00001148 1A18                       		move.b	(a0)+,d5		; d5 = displacement.
0000114A                            		adda.w	d5,a5
0000114A DAC5                     M 	axda.w	d5,a5
0000114C 12DD                       		move.b	(a5)+,(a1)+
0000114E 12DD                       		move.b	(a5)+,(a1)+
00001150 6080                       		bra.s	@FetchNewCode
00001152                            
00001152                            ; ---------------------------------------------------------------------------
00001152                            
00001152                            @Copy3:
00001152                            		_Kos_RunBitStream
00001152 51CA 0000                M 	dbra	d2,.skip_102
00001156 7407                     M 	moveq	#7,d2
00001158 1001                     M 	move.b	d1,d0
0000115A 4643                     M 	not.w	d3
0000115C 6600                     M 	bne.s	.skip_102
0000115E 1018                     M 	move.b	(a0)+,d0
00001160 1218                     M 	move.b	(a0)+,d1
00001162 1034 0000                M 	move.b	(a4,d0.w),d0
00001166 1234 1000                M 	move.b	(a4,d1.w),d1
0000116A                          M .skip_102:
0000116A 1A18                       		move.b	(a0)+,d5		; d5 = displacement.
0000116C                            		adda.w	d5,a5
0000116C DAC5                     M 	axda.w	d5,a5
0000116E 12DD                       		move.b	(a5)+,(a1)+
00001170 12DD                       		move.b	(a5)+,(a1)+
00001172 12DD                       		move.b	(a5)+,(a1)+
00001174 6000 FF5C                  		bra.w	@FetchNewCode
00001178                            
00001178                            ; ---------------------------------------------------------------------------
00001178                            
00001178                            @Copy45:
00001178                            		_Kos_RunBitStream
00001178 51CA 0000                M 	dbra	d2,.skip_104
0000117C 7407                     M 	moveq	#7,d2
0000117E 1001                     M 	move.b	d1,d0
00001180 4643                     M 	not.w	d3
00001182 6600                     M 	bne.s	.skip_104
00001184 1018                     M 	move.b	(a0)+,d0
00001186 1218                     M 	move.b	(a0)+,d1
00001188 1034 0000                M 	move.b	(a4,d0.w),d0
0000118C 1234 1000                M 	move.b	(a4,d1.w),d1
00001190                          M .skip_104:
00001190                            		_Kos_ReadBit
00001190                          M 	add.b	d0,d0
00001190                          M 	local	num
00001190 D000                     M 	axd.b	d0,d0
00001192 6500                       		bcs.s	@Copy5
00001194                            		_Kos_RunBitStream
00001194 51CA 0000                M 	dbra	d2,.skip_107
00001198 7407                     M 	moveq	#7,d2
0000119A 1001                     M 	move.b	d1,d0
0000119C 4643                     M 	not.w	d3
0000119E 6600                     M 	bne.s	.skip_107
000011A0 1018                     M 	move.b	(a0)+,d0
000011A2 1218                     M 	move.b	(a0)+,d1
000011A4 1034 0000                M 	move.b	(a4,d0.w),d0
000011A8 1234 1000                M 	move.b	(a4,d1.w),d1
000011AC                          M .skip_107:
000011AC 1A18                       		move.b	(a0)+,d5		; d5 = displacement.
000011AE                            		adda.w	d5,a5
000011AE DAC5                     M 	axda.w	d5,a5
000011B0 12DD                       		move.b	(a5)+,(a1)+
000011B2 12DD                       		move.b	(a5)+,(a1)+
000011B4 12DD                       		move.b	(a5)+,(a1)+
000011B6 12DD                       		move.b	(a5)+,(a1)+
000011B8 6000 FF18                  		bra.w	@FetchNewCode
000011BC                            
000011BC                            ; ---------------------------------------------------------------------------
000011BC                            
000011BC                            @Copy5:
000011BC                            		_Kos_RunBitStream
000011BC 51CA 0000                M 	dbra	d2,.skip_109
000011C0 7407                     M 	moveq	#7,d2
000011C2 1001                     M 	move.b	d1,d0
000011C4 4643                     M 	not.w	d3
000011C6 6600                     M 	bne.s	.skip_109
000011C8 1018                     M 	move.b	(a0)+,d0
000011CA 1218                     M 	move.b	(a0)+,d1
000011CC 1034 0000                M 	move.b	(a4,d0.w),d0
000011D0 1234 1000                M 	move.b	(a4,d1.w),d1
000011D4                          M .skip_109:
000011D4 1A18                       		move.b	(a0)+,d5		; d5 = displacement.
000011D6                            		adda.w	d5,a5
000011D6 DAC5                     M 	axda.w	d5,a5
000011D8 12DD                       		move.b	(a5)+,(a1)+
000011DA 12DD                       		move.b	(a5)+,(a1)+
000011DC 12DD                       		move.b	(a5)+,(a1)+
000011DE 12DD                       		move.b	(a5)+,(a1)+
000011E0 12DD                       		move.b	(a5)+,(a1)+
000011E2 6000 FEEE                  		bra.w	@FetchNewCode
000011E6                            
000011E6                            ; ---------------------------------------------------------------------------
000011E6                            
000011E6                            
000011E6                            ; ---------------------------------------------------------------------------
000011E6                            
000011E6                            @Code_01:
000011E6 7800                       	moveq	#0,d4				; d4 will contain copy count.
000011E8                            	; Code 01 (Dictionary ref. long / special).
000011E8                            	_Kos_RunBitStream
000011E8 51CA 0000                M 	dbra	d2,.skip_114
000011EC 7407                     M 	moveq	#7,d2
000011EE 1001                     M 	move.b	d1,d0
000011F0 4643                     M 	not.w	d3
000011F2 6600                     M 	bne.s	.skip_114
000011F4 1018                     M 	move.b	(a0)+,d0
000011F6 1218                     M 	move.b	(a0)+,d1
000011F8 1034 0000                M 	move.b	(a4,d0.w),d0
000011FC 1234 1000                M 	move.b	(a4,d1.w),d1
00001200                          M .skip_114:
00001200 1C18                       	move.b	(a0)+,d6			; d6 = %LLLLLLLL.
00001202 1818                       	move.b	(a0)+,d4			; d4 = %HHHHHCCC.
00001204 1A04                       	move.b	d4,d5				; d5 = %11111111 HHHHHCCC.
00001206 EB4D                       	lsl.w	#5,d5				; d5 = %111HHHHH CCC00000.
00001208 1A06                       	move.b	d6,d5				; d5 = %111HHHHH LLLLLLLL.
0000120A                            		and.w	d7,d4			; d4 = %00000CCC.
0000120A                          M 	local	num
0000120A C847                     M 	anx.w	d7,d4
0000120C 6600                       	bne.s	@StreamCopy			; if CCC=0, branch.
0000120E                             
0000120E                            	; special mode (extended counter)
0000120E 1818                       	move.b	(a0)+,d4			; Read cnt
00001210 6700                       	beq.s	@Quit				; If cnt=0, quit decompression.
00001212                            	subq.b	#1,d4
00001212 5304                     M 	sxbq.b	#1,d4
00001214 6700 FEBC                  	beq.w	@FetchNewCode			; If cnt=1, fetch a new code.
00001218                             
00001218                            	adda.w	d5,a5
00001218 DAC5                     M 	axda.w	d5,a5
0000121A 12DD                       	move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
0000121C 3C04                       	move.w	d4,d6
0000121E 4646                       	not.w	d6
00001220                            	and.w	d7,d6
00001220                          M 	local	num
00001220 CC47                     M 	anx.w	d7,d6
00001222                            	add.w	d6,d6
00001222                          M 	local	num
00001222 DC46                     M 	axd.w	d6,d6
00001224 E64C                       	lsr.w	#_Kos_LoopUnroll,d4
00001226 4EFB 6000                  	jmp	@LargeCopy(pc,d6.w)
0000122A                            
0000122A                            ; ---------------------------------------------------------------------------
0000122A                            
0000122A                            @LargeCopy:
0000122A                            	rept (1<<_Kos_LoopUnroll)
0000122A                            		move.b	(a5)+,(a1)+
0000122A                            	endr
0000122A 12DD                     M 	move.b	(a5)+,(a1)+
0000122C 12DD                     M 	move.b	(a5)+,(a1)+
0000122E 12DD                     M 	move.b	(a5)+,(a1)+
00001230 12DD                     M 	move.b	(a5)+,(a1)+
00001232 12DD                     M 	move.b	(a5)+,(a1)+
00001234 12DD                     M 	move.b	(a5)+,(a1)+
00001236 12DD                     M 	move.b	(a5)+,(a1)+
00001238 12DD                     M 	move.b	(a5)+,(a1)+
0000123A 51CC FFEE                  	dbra	d4,@LargeCopy
0000123E 6000 FE92                  	bra.w	@FetchNewCode
00001242                            
00001242                            ; ---------------------------------------------------------------------------
00001242                            
00001242                            @StreamCopy:
00001242                            		adda.w	d5,a5
00001242 DAC5                     M 	axda.w	d5,a5
00001244 12DD                       		move.b	(a5)+,(a1)+		; Do 1 extra copy (to compensate +1 to copy counter).
00001246 BF44                       			eor.w	d7,d4
00001248                            		add.w	d4,d4
00001248                          M 	local	num
00001248 D844                     M 	axd.w	d4,d4
0000124A 4EFB 4000                  		jmp	@MediumCopy(pc,d4.w)
0000124E                            
0000124E                            ; ---------------------------------------------------------------------------
0000124E                            
0000124E                            @MediumCopy:
0000124E                            		rept 8
0000124E                            			move.b	(a5)+,(a1)+
0000124E                            		endr
0000124E 12DD                     M 	move.b	(a5)+,(a1)+
00001250 12DD                     M 	move.b	(a5)+,(a1)+
00001252 12DD                     M 	move.b	(a5)+,(a1)+
00001254 12DD                     M 	move.b	(a5)+,(a1)+
00001256 12DD                     M 	move.b	(a5)+,(a1)+
00001258 12DD                     M 	move.b	(a5)+,(a1)+
0000125A 12DD                     M 	move.b	(a5)+,(a1)+
0000125C 12DD                     M 	move.b	(a5)+,(a1)+
0000125E 6000 FE72                  		bra.w	@FetchNewCode
00001262                            
00001262                            ; ---------------------------------------------------------------------------
00001262                            
00001262                            @Quit:
00001262 4E75                       	rts
00001264                            
00001264                            ; ---------------------------------------------------------------------------
00001264                            
00001264                            KosDec_ByteMap:
00001264 0080 40C0 20A0 60E0 1090+  		dc.b	$00,$80,$40,$C0,$20,$A0,$60,$E0,$10,$90,$50,$D0,$30,$B0,$70,$F0
00001274 0888 48C8 28A8 68E8 1898+  		dc.b	$08,$88,$48,$C8,$28,$A8,$68,$E8,$18,$98,$58,$D8,$38,$B8,$78,$F8
00001284 0484 44C4 24A4 64E4 1494+  		dc.b	$04,$84,$44,$C4,$24,$A4,$64,$E4,$14,$94,$54,$D4,$34,$B4,$74,$F4
00001294 0C8C 4CCC 2CAC 6CEC 1C9C+  		dc.b	$0C,$8C,$4C,$CC,$2C,$AC,$6C,$EC,$1C,$9C,$5C,$DC,$3C,$BC,$7C,$FC
000012A4 0282 42C2 22A2 62E2 1292+  		dc.b	$02,$82,$42,$C2,$22,$A2,$62,$E2,$12,$92,$52,$D2,$32,$B2,$72,$F2
000012B4 0A8A 4ACA 2AAA 6AEA 1A9A+  		dc.b	$0A,$8A,$4A,$CA,$2A,$AA,$6A,$EA,$1A,$9A,$5A,$DA,$3A,$BA,$7A,$FA
000012C4 0686 46C6 26A6 66E6 1696+  		dc.b	$06,$86,$46,$C6,$26,$A6,$66,$E6,$16,$96,$56,$D6,$36,$B6,$76,$F6
000012D4 0E8E 4ECE 2EAE 6EEE 1E9E+  		dc.b	$0E,$8E,$4E,$CE,$2E,$AE,$6E,$EE,$1E,$9E,$5E,$DE,$3E,$BE,$7E,$FE
000012E4 0181 41C1 21A1 61E1 1191+  		dc.b	$01,$81,$41,$C1,$21,$A1,$61,$E1,$11,$91,$51,$D1,$31,$B1,$71,$F1
000012F4 0989 49C9 29A9 69E9 1999+  		dc.b	$09,$89,$49,$C9,$29,$A9,$69,$E9,$19,$99,$59,$D9,$39,$B9,$79,$F9
00001304 0585 45C5 25A5 65E5 1595+  		dc.b	$05,$85,$45,$C5,$25,$A5,$65,$E5,$15,$95,$55,$D5,$35,$B5,$75,$F5
00001314 0D8D 4DCD 2DAD 6DED 1D9D+  		dc.b	$0D,$8D,$4D,$CD,$2D,$AD,$6D,$ED,$1D,$9D,$5D,$DD,$3D,$BD,$7D,$FD
00001324 0383 43C3 23A3 63E3 1393+  		dc.b	$03,$83,$43,$C3,$23,$A3,$63,$E3,$13,$93,$53,$D3,$33,$B3,$73,$F3
00001334 0B8B 4BCB 2BAB 6BEB 1B9B+  		dc.b	$0B,$8B,$4B,$CB,$2B,$AB,$6B,$EB,$1B,$9B,$5B,$DB,$3B,$BB,$7B,$FB
00001344 0787 47C7 27A7 67E7 1797+  		dc.b	$07,$87,$47,$C7,$27,$A7,$67,$E7,$17,$97,$57,$D7,$37,$B7,$77,$F7
00001354 0F8F 4FCF 2FAF 6FEF 1F9F+  		dc.b	$0F,$8F,$4F,$CF,$2F,$AF,$6F,$EF,$1F,$9F,$5F,$DF,$3F,$BF,$7F,$FF
00001364                            
00001364                            
00001364                            ; -------------------------------------------------------------------------
00001364                            ; Comper decompressor (by Vladikcomper)
00001364                            ; -------------------------------------------------------------------------
00001364                            ; PARAMETERS:
00001364                            ;	a0.l - Source data
00001364                            ;	a1.l - Destination buffer
00001364                            ; -------------------------------------------------------------------------
00001364                             
00001364                            CompDec:
00001364                            .NewBlock:
00001364 3018                       	move.w	(a0)+,d0			; Fetch description field
00001366 760F                       	moveq	#15,d3				; set bits counter to 16
00001368                             
00001368                            .MainLoop
00001368                            	add.w	d0,d0				; Roll description field
00001368                          M 	local	num
00001368 D040                     M 	axd.w	d0,d0
0000136A 6500                       	bcs.s	.Flag				; If a flag issued, branch
0000136C 32D8                       	move.w	(a0)+,(a1)+			; Otherwise, do uncompressed data
0000136E 51CB FFF8                  	dbf	d3,.MainLoop			; If bits counter remains, parse the next word
00001372 60F0                       	bra.s	.NewBlock			; Start a new block
00001374                            
00001374                            ; -------------------------------------------------------------------------
00001374                            
00001374                            .Flag:
00001374 72FF                       	moveq	#-1,d1				; Init displacement
00001376 1218                       	move.b	(a0)+,d1			; Load displacement
00001378                            	add.w	d1,d1
00001378                          M 	local	num
00001378 D241                     M 	axd.w	d1,d1
0000137A 7400                       	moveq	#0,d2				; Init copy count
0000137C 1418                       	move.b	(a0)+,d2			; Load copy length
0000137E 6700                       	beq.s	.End				; If zero, branch
00001380 45F1 1000                  	lea	(a1,d1),a2			; Load start copy address
00001384                             
00001384                            .Loop:
00001384 32DA                       	move.w	(a2)+,(a1)+			; Copy given sequence
00001386 51CA FFFC                  	dbf	d2,.Loop			; Repeat
0000138A 51CB FFDC                  	dbf	d3,.MainLoop			; If bits counter remains, parse the next word
0000138E 60D4                       	bra.s	.NewBlock			; Start a new block
00001390                             
00001390                            .End:
00001390 4E75                       	rts
00001392                            
00001392                            ; ---------------------------------------------------------------------------
00001392                            	include	"_lib/mode1.m68k"			; Mode 1 library
00001392                            ; -------------------------------------------------------------------------
00001392                            ; Mega Drive Framework
00001392                            ; By Devon 2022
00001392                            ; -------------------------------------------------------------------------
00001392                            
00001392                            ; -------------------------------------------------------------------------
00001392                            ; Initialize the Sub CPU
00001392                            ; -------------------------------------------------------------------------
00001392                            ; NOTES:
00001392                            ;	* This assumes that the Sega CD is present and that you have
00001392                            ;	  the Sub CPU BIOS code ready to go. Call FindMCDBIOS before this
00001392                            ;
00001392                            ;	* Sub CPU boot requires that we send it level 2 interrupt requests.
00001392                            ;	  After calling this, make sure you enable vertical interrupts
00001392                            ;	  and have your handler call SendMCDInt2. Then you can properly
00001392                            ;	  wait for the Sub CPU to boot and initialize.
00001392                            ; -------------------------------------------------------------------------
00001392                            ; PARAMETERS:
00001392                            ;	a0.l - Pointer to compressed Sub CPU BIOS code
00001392                            ;	a1.l - Pointer to user Sub CPU program
00001392                            ;	d0.l - Size of user Sub CPU program
00001392                            ; RETURNS:
00001392                            ;	d0.b - Error codes
00001392                            ;	       Bit 0 - MCD took too long to respond
00001392                            ;	       Bit 1 - Failed to load user Sub CPU
00001392                            ; -------------------------------------------------------------------------
00001392                            
00001392                            InitSubCPU:
00001392 6100                       	bsr.s	ResetSubCPU			; Reset the Sub CPU
00001394                            
00001394 6100 0000                  	bsr.w	ReqSubCPUBus			; Request Sub CPU bus
00001398 1602                       	move.b	d2,d3
0000139A 6600                       	bne.s	.ReturnBus			; If it failed to do that, branch
0000139C                            
0000139C 13FC 0000 00A1 2002        	move.b	#0,MCDPROTECT			; Disable write protect on Sub CPU memory
000013A4                            
000013A4 48E7 9040                  	movem.l	d0/d3/a1,-(sp)			; Decompress Sub CPU BIOS into PRG RAM
000013A8 43F9 0042 0000             	lea	PRGRAM,a1
000013AE 6100 FCEC                  	bsr.w	KosDec
000013B2 4CDF 0209                  	movem.l	(sp)+,d0/d3/a1
000013B6                            
000013B6 2049                       	movea.l	a1,a0				; Copy user Sub CPU program into PRG RAM
000013B8 223C 0000 6000             	move.l	#$6000,d1
000013BE 6100 0000                  	bsr.w	CopyPRGRAMData
000013C2                            	or.b	d2,d3
000013C2                          M 	local	num
000013C2 8602                     M 	ox.b	d2,d3
000013C4                            
000013C4                            .ReturnBus:
000013C4 13FC 002A 00A1 2002        	move.b	#$2A,MCDPROTECT			; Enable write protect on Sub CPU memory
000013CC 6100 0000                  	bsr.w	ReturnSubCPUBus			; Return Sub CPU bus
000013D0                            	or.b	d2,d3				; Set error code
000013D0                          M 	local	num
000013D0 8602                     M 	ox.b	d2,d3
000013D2                            
000013D2 1003                       	move.b	d3,d0				; Get return code
000013D4 4E75                       	rts
000013D6                            
000013D6                            ; -------------------------------------------------------------------------
000013D6                            ; Copy new user Sub CPU program into PRG RAM and reset the Sub CPU
000013D6                            ; -------------------------------------------------------------------------
000013D6                            ; PARAMETERS:
000013D6                            ;	a0.l - Pointer to Sub CPU program to copy
000013D6                            ;	d0.l - Size of Sub CPU program to copy
000013D6                            ; RETURNS:
000013D6                            ;	d0.b - Error codes
000013D6                            ;	       Bit 0 - MCD took too long to respond
000013D6                            ;	       Bit 1 - Failed to load user Sub CPU
000013D6                            ; -------------------------------------------------------------------------
000013D6                            
000013D6                            CopyNewUserSP:
000013D6 6100                       	bsr.s	ResetSubCPU			; Reset the Sub CPU
000013D8 223C 0000 6000             	move.l	#$6000,d1			; Copy to user Sub CPU program area
000013DE                            
000013DE                            ; -------------------------------------------------------------------------
000013DE                            ; Copy data into PRG RAM
000013DE                            ; -------------------------------------------------------------------------
000013DE                            ; PARAMETERS:
000013DE                            ;	a0.l - Pointer to data to copy
000013DE                            ;	d0.l - Size of data to copy
000013DE                            ;	d1.l - Destination offset in PRG RAM
000013DE                            ; RETURNS:
000013DE                            ;	d0.b - Error codes
000013DE                            ;	       Bit 0 - MCD took too long to respond
000013DE                            ;	       Bit 1 - Failed to load user Sub CPU
000013DE                            ; -------------------------------------------------------------------------
000013DE                            
000013DE                            CopyToPRGRAM:
000013DE 6100                       	bsr.s	ReqSubCPUBus			; Request Sub CPU bus
000013E0 1602                       	move.b	d2,d3
000013E2 6600                       	bne.s	.ReturnBus			; If it failed to do that, branch
000013E4                            
000013E4 1639 00A1 2002             	move.b	MCDPROTECT,d3			; Save write protect settings on Sub CPU memory
000013EA 13FC 0000 00A1 2002        	move.b	#0,MCDPROTECT			; Disable write protect on Sub CPU memory
000013F2                            
000013F2 6100 0000                  	bsr.w	CopyPRGRAMData			; Copy data to PRG-RAM
000013F6                            	or.b	d2,d3
000013F6                          M 	local	num
000013F6 8602                     M 	ox.b	d2,d3
000013F8                            
000013F8 13C3 00A1 2002             	move.b	d3,MCDPROTECT			; Restore write protect on Sub CPU memory
000013FE                            
000013FE                            .ReturnBus:
000013FE 6100                       	bsr.s	ReturnSubCPUBus			; Return Sub CPU bus
00001400                            	or.b	d2,d3				; Set error code
00001400                          M 	local	num
00001400 8602                     M 	ox.b	d2,d3
00001402                            
00001402 1003                       	move.b	d3,d0				; Get return code
00001404 4E75                       	rts
00001406                            
00001406                            ; -------------------------------------------------------------------------
00001406                            ; Reset the Sub CPU
00001406                            ; -------------------------------------------------------------------------
00001406                            
00001406                            ResetSubCPU:
00001406 33FC FF00 00A1 2002        	move.w	#$FF00,MCDPROTECT		; Reset the Sub CPU
0000140E 13FC 0003 00A1 2001        	move.b	#3,MCDBUSREQ
00001416 13FC 0002 00A1 2001        	move.b	#2,MCDBUSREQ
0000141E 13FC 0000 00A1 2001        	move.b	#0,MCDBUSREQ
00001426                            
00001426 747F                       	moveq	#$80-1,d2			; Wait
00001428 51CA FFFE                  	dbf	d2,*
0000142C 4E75                       	rts
0000142E                            
0000142E                            ; -------------------------------------------------------------------------
0000142E                            ; Request the Sub CPU bus
0000142E                            ; -------------------------------------------------------------------------
0000142E                            ; RETURNS:
0000142E                            ;	d2.b - Return code
0000142E                            ;	       0 - Success
0000142E                            ;	       1 - MCD took too long to respond
0000142E                            ; -------------------------------------------------------------------------
0000142E                            
0000142E                            ReqSubCPUBus:
0000142E 343C 00FF                  	move.w	#$100-1,d2			; Max time to wait for MCD response
00001432                            
00001432                            .ResetSub:
00001432 08B9 0000 00A1 2001        	bclr	#0,MCDBUSREQ			; Set the Sub CPU to be reset
0000143A 57CA FFF6                  	dbeq	d2,.ResetSub			; Loop until we've waited too long or until the MCD has responded
0000143E 6600                       	bne.s	.WaitedTooLong			; If we've waited too long, branch
00001440                            
00001440 343C 00FF                  	move.w	#$100-1,d2			; Max time to wait for MCD response
00001444                            
00001444                            .ReqSubBus:
00001444 08F9 0001 00A1 2001        	bset	#1,MCDBUSREQ			; Request Sub CPU bus
0000144C 56CA FFF6                  	dbne	d2,.ReqSubBus			; Loop until we've waited too long or until the MCD has responded
00001450 6700                       	beq.s	.WaitedTooLong			; If we've waited too long, branch
00001452                            
00001452 7400                       	moveq	#0,d2				; Success
00001454 4E75                       	rts
00001456                            
00001456                            .WaitedTooLong:
00001456 7401                       	moveq	#1,d2				; Waited too long
00001458 4E75                       	rts
0000145A                            
0000145A                            ; -------------------------------------------------------------------------
0000145A                            ; Return the Sub CPU bus
0000145A                            ; -------------------------------------------------------------------------
0000145A                            ; RETURNS:
0000145A                            ;	d2.b - Return code
0000145A                            ;	       0 - Success
0000145A                            ;	       1 - MCD took too long to respond
0000145A                            ; -------------------------------------------------------------------------
0000145A                            
0000145A                            ReturnSubCPUBus:
0000145A 343C 00FF                  	move.w	#$100-1,d2			; Max time to wait for MCD response
0000145E                            
0000145E                            .RunSub:
0000145E 08F9 0000 00A1 2001        	bset	#0,MCDBUSREQ			; Set the Sub CPU to run again
00001466 56CA FFF6                  	dbne	d2,.RunSub			; Loop until we've waited too long or until the MCD has responded
0000146A 6700                       	beq.s	.WaitedTooLong			; If we've waited too long, branch
0000146C                            
0000146C 343C 00FF                  	move.w	#$100-1,d2			; Max time to wait for MCD response
00001470                            
00001470                            .GiveSubBus:
00001470 08B9 0001 00A1 2001        	bclr	#1,MCDBUSREQ			; Give back Sub CPU bus
00001478 57CA FFF6                  	dbeq	d2,.GiveSubBus			; Loop until we've waited too long or until the MCD has responded
0000147C 6600                       	bne.s	.WaitedTooLong			; If we've waited too long, branch
0000147E                            
0000147E 7400                       	moveq	#0,d2				; Success
00001480 4E75                       	rts
00001482                            
00001482                            .WaitedTooLong:
00001482 7401                       	moveq	#1,d2				; Waited too long
00001484 4E75                       	rts
00001486                            
00001486                            ; -------------------------------------------------------------------------
00001486                            ; Copy PRG-RAM data
00001486                            ; -------------------------------------------------------------------------
00001486                            ; NOTE: Requires that Sub CPU bus access must be granted
00001486                            ; -------------------------------------------------------------------------
00001486                            ; PARAMETERS:
00001486                            ;	a0.l - Pointer to data to copy
00001486                            ;	d0.l - Size of data to copy
00001486                            ;	d1.l - PRG RAM offset
00001486                            ; RETURNS:
00001486                            ;	d2.b - Return code
00001486                            ;	       0 - Success
00001486                            ;	       2 - Failed to copy data
00001486                            ; -------------------------------------------------------------------------
00001486                            
00001486                            CopyPRGRAMData:
00001486 43F9 0042 0000             	lea	PRGRAM,a1			; Get destination address
0000148C 2401                       	move.l	d1,d2
0000148E                            	andi.l	#PRGRAM_SIZE-1,d2
0000148E 0282 0001 FFFF           M 	anxi.l	#prgram_size-1,d2
00001494                            	add.l	d2,a1
00001494                          M 	local	num
00001494 D3C2                     M 	axd.l	d2,a1
00001496                            	
00001496 1439 00A1 2003             	move.b	MCDMEMMODE,d2			; Set bank ID
0000149C                            	andi.b	#$3F,d2
0000149C 0202 003F                M 	anxi.b	#$3f,d2
000014A0 4841                       	swap	d1
000014A2 E619                       	ror.b	#3,d1
000014A4                            	andi.b	#$C0,d1
000014A4 0201 00C0                M 	anxi.b	#$c0,d1
000014A8                            	or.b	d2,d1
000014A8                          M 	local	num
000014A8 8202                     M 	ox.b	d2,d1
000014AA 13C1 00A1 2003             	move.b	d1,MCDMEMMODE
000014B0                            
000014B0                            .CopyData:
000014B0 1290                       	move.b	(a0),(a1)			; Copy byte
000014B2 B308                       	cmpm.b	(a0)+,(a1)+			; Did it copy correctly?
000014B4 6700                       	beq.s	.CopyDataLoop			; If so, branch
000014B6 7402                       	moveq	#2,d2				; Failed to copy data
000014B8 4E75                       	rts
000014BA                            
000014BA                            .CopyDataLoop:
000014BA                            	subq.l	#1,d0				; Decrement size
000014BA 5380                     M 	sxbq.l	#1,d0
000014BC 6700                       	beq.s	.End				; If there's no more data left copy, branch
000014BE B3FC 0043 FFFF             	cmpa.l	#PRGRAM_END,a1			; Have we reached the end of the bank?
000014C4 63EA                       	bls.s	.CopyData			; If not, branch
000014C6                            
000014C6 43F9 0042 0000             	lea	PRGRAM,a1			; Go to top of bank
000014CC 1239 00A1 2003             	move.b	MCDMEMMODE,d1			; Increment bank ID
000014D2                            	addi.b	#$40,d1
000014D2 0601 0040                M 	axdi.b	#$40,d1
000014D6 13C1 00A1 2003             	move.b	d1,MCDMEMMODE
000014DC 60D2                       	bra.s	.CopyData			; Copy more data
000014DE                            
000014DE                            .End:
000014DE 7400                       	moveq	#0,d2				; Success
000014E0 4E75                       	rts
000014E2                            
000014E2                            ; -------------------------------------------------------------------------
000014E2                            ; Send a level 2 interrupt request to the Sub CPU
000014E2                            ; -------------------------------------------------------------------------
000014E2                            
000014E2                            SendMCDInt2:
000014E2 08F9 0000 00A1 2000        	bset	#0,MCDINT2			; Send interrupt request
000014EA 4E75                       	rts
000014EC                            
000014EC                            ; -------------------------------------------------------------------------
000014EC                            ; Check if there's a known MCD BIOS available
000014EC                            ; -------------------------------------------------------------------------
000014EC                            ; RETURNS:
000014EC                            ;	cc/cs - Found, not found 
000014EC                            ;	a0.l  - Pointer to Sub CPU BIOS
000014EC                            ; -------------------------------------------------------------------------
000014EC                            
000014EC                            FindMCDBIOS:
000014EC 0CB9 5345 4741 0040 0100   	cmpi.l	#"SEGA",MCDBIOS+$100		; Is the "SEGA" signature present?
000014F6 6600                       	bne.s	.NotFound			; If not, branch
000014F8 0C79 4252 0040 0180        	cmpi.w	#"BR",MCDBIOS+$180		; Is the "Boot ROM" software type present?
00001500 6600                       	bne.s	.NotFound			; If not, branch
00001502                            
00001502 45FA 0000                  	lea	MCDBIOSList(pc),a2		; Get list of known BIOSes
00001506 7000                       	moveq	#(MCDBIOSListEnd-MCDBIOSList)/2-1,d0
00001508                            
00001508                            .FindLoop:
00001508 43FA 0000                  	lea	MCDBIOSList(pc),a1		; Get pointer to BIOS data
0000150C                            	adda.w	(a2)+,a1
0000150C D2DA                     M 	axda.w	(a2)+,a1
0000150E                            
0000150E 2059                       	movea.l	(a1)+,a0			; Get Sub CPU BIOS address
00001510 47F9 0040 0120             	lea	MCDBIOS+$120,a3			; Get BIOS name
00001516                            
00001516                            .CheckName:
00001516 1219                       	move.b	(a1)+,d1			; Get character
00001518 6700                       	beq.s	.NameMatch			; If we are done checking, branch
0000151A B21B                       	cmp.b	(a3)+,d1			; Does the BIOS name match so far?
0000151C 6600                       	bne.s	.NextBIOS			; If not, go check the next BIOS
0000151E 60F6                       	bra.s	.CheckName			; Loop until name is fully checked
00001520                            
00001520                            .NameMatch:
00001520 1219                       	move.b	(a1)+,d1			; Is this Sub CPU BIOS address region specific?
00001522 6700                       	beq.s	.Found				; If not, branch
00001524 B239 0040 01F0             	cmp.b	MCDBIOS+$1F0,d1			; Does the BIOS region match?
0000152A 6600                       	bne.s	.NextBIOS			; If not, branch
0000152C                            
0000152C                            .Found:
0000152C                            	andi	#$FE,ccr			; BIOS found
0000152C 023C 00FE                M 	anxi.	#$fe,ccr
00001530 4E75                       	rts
00001532                            
00001532                            .NextBIOS:
00001532 51C8 FFD4                  	dbf	d0,.FindLoop			; Loop until all BIOSes are checked
00001536                            
00001536                            .NotFound:
00001536                            	ori	#1,ccr				; BIOS not found
00001536 003C 0001                M 	oxi.	#1,ccr
0000153A 4E75                       	rts
0000153C                            
0000153C                            ; -------------------------------------------------------------------------
0000153C                            ; MCD BIOSes to find
0000153C                            ; -------------------------------------------------------------------------
0000153C                            
0000153C                            MCDBIOSList:
0000153C 0000                       	dc.w	MCDBIOS_JP1-MCDBIOSList
0000153E 0000                       	dc.w	MCDBIOS_US1-MCDBIOSList
00001540 0000                       	dc.w	MCDBIOS_EU1-MCDBIOSList
00001542 0000                       	dc.w	MCDBIOS_CD2-MCDBIOSList
00001544 0000                       	dc.w	MCDBIOS_CDX-MCDBIOSList
00001546 0000                       	dc.w	MCDBIOS_LaserActive-MCDBIOSList
00001548 0000                       	dc.w	MCDBIOS_Wondermega1-MCDBIOSList
0000154A 0000                       	dc.w	MCDBIOS_Wondermega2-MCDBIOSList
0000154C                            MCDBIOSListEnd:
0000154C                            
0000154C                            MCDBIOS_JP1:
0000154C 0041 6000                  	dc.l	MCDBIOS+$16000
00001550 4D45 4741 2D43 4420 424F+  	dc.b	"MEGA-CD BOOT ROM", 0
00001561 4A                         	dc.b	"J"
00001562                            	even
00001562                            
00001562                            MCDBIOS_US1:
00001562 0041 5800                  	dc.l	MCDBIOS+$15800
00001566 5345 4741 2D43 4420 424F+  	dc.b	"SEGA-CD BOOT ROM", 0
00001577 00                         	dc.b	0
00001578                            	even
00001578                            
00001578                            MCDBIOS_EU1:
00001578 0041 5800                  	dc.l	MCDBIOS+$15800
0000157C 4D45 4741 2D43 4420 424F+  	dc.b	"MEGA-CD BOOT ROM", 0
0000158D 45                         	dc.b	"E"
0000158E                            	even
0000158E                            
0000158E                            MCDBIOS_CD2:
0000158E 0041 6000                  	dc.l	MCDBIOS+$16000
00001592 4344 3220 424F 4F54 2052+  	dc.b	"CD2 BOOT ROM    ", 0
000015A3 00                         	dc.b	0
000015A4                            	even
000015A4                            
000015A4                            MCDBIOS_CDX:
000015A4 0041 6000                  	dc.l	MCDBIOS+$16000
000015A8 4344 5820 424F 4F54 2052+  	dc.b	"CDX BOOT ROM    ", 0
000015B9 00                         	dc.b	0
000015BA                            	even
000015BA                            
000015BA                            MCDBIOS_LaserActive:
000015BA 0041 AD00                  	dc.l	MCDBIOS+$1AD00
000015BE 4D45 4741 2D4C 4420 424F+  	dc.b	"MEGA-LD BOOT ROM", 0
000015CF 00                         	dc.b	0
000015D0                            	even
000015D0                            
000015D0                            MCDBIOS_Wondermega1:
000015D0 0041 6000                  	dc.l	MCDBIOS+$16000
000015D4 574F 4E44 4552 2D4D 4547+  	dc.b	"WONDER-MEGA BOOTROM", 0
000015E8 00                         	dc.b	0
000015EA 00                         	even
000015EA                            
000015EA                            MCDBIOS_Wondermega2:
000015EA 0041 6000                  	dc.l	MCDBIOS+$16000
000015EE 574F 4E44 4552 4D45 4741+  	dc.b	"WONDERMEGA2 BOOTROM", 0
00001602 00                         	dc.b	0
00001604 00                         	even
00001604                            
00001604                            ; -------------------------------------------------------------------------
00001604                            	include	"_lib/text.m68k"			; Text library
00001604                            ; ---------------------------------------------------------------------------
00001604                            ; Mega Drive Framework
00001604                            ; By Devon 2022
00001604                            ; ---------------------------------------------------------------------------
00001604                            ; Text functions
00001604                            ; ---------------------------------------------------------------------------
00001604                            
00001604                            ; ---------------------------------------------------------------------------
00001604                            ; Load the debug font into VRAM
00001604                            ; VDP command should be set beforehand
00001604                            ; ---------------------------------------------------------------------------
00001604                            ; PARAMETERS:
00001604                            ;	d0.b - Palette entry for set pixels
00001604                            ; ---------------------------------------------------------------------------
00001604                            
00001604                            LoadDebugFont:
00001604 41FA 0000                  	lea	.DebugFont(pc),a0			; Load font
00001608 323C 0000                  	move.w	#.DebugFontEnd-.DebugFont-1,d1
0000160C 6000 FA6C                  	bra.w	Decode1BPPToVRAM
00001610                            
00001610                            ; ---------------------------------------------------------------------------
00001610                            
00001610                            .DebugFont:
00001610 0000 0000 0000 0000 3078+  	dc.b	$00, $00, $00, $00, $00, $00, $00, $00, $30, $78, $78, $78
0000161C 3000 3000 5050 0000 0000+  	dc.b	$30, $00, $30, $00, $50, $50, $00, $00, $00, $00, $00, $00
00001628 44FE 4444 44FE 4400 287E+  	dc.b	$44, $FE, $44, $44, $44, $FE, $44, $00, $28, $7E, $A8, $7C
00001634 2AFC 2800 C6CC 1830 60C6+  	dc.b	$2A, $FC, $28, $00, $C6, $CC, $18, $30, $60, $C6, $86, $00
00001640 3048 2870 CAC4 7A00 4040+  	dc.b	$30, $48, $28, $70, $CA, $C4, $7A, $00, $40, $40, $00, $00
0000164C 0000 0000 060C 0C0C 0C0C+  	dc.b	$00, $00, $00, $00, $06, $0C, $0C, $0C, $0C, $0C, $06, $00
00001658 C060 6060 6060 C000 0054+  	dc.b	$C0, $60, $60, $60, $60, $60, $C0, $00, $00, $54, $38, $7C
00001664 3854 0000 0018 187E 7E18+  	dc.b	$38, $54, $00, $00, $00, $18, $18, $7E, $7E, $18, $18, $00
00001670 0000 0000 00C0 C040 0000+  	dc.b	$00, $00, $00, $00, $00, $C0, $C0, $40, $00, $00, $00, $7E
0000167C 7E00 0000 0000 0000 00C0+  	dc.b	$7E, $00, $00, $00, $00, $00, $00, $00, $00, $C0, $C0, $00
00001688 060C 1830 60C0 8000 7CC6+  	dc.b	$06, $0C, $18, $30, $60, $C0, $80, $00, $7C, $C6, $CE, $DA
00001694 F2E6 7C00 1838 1818 1818+  	dc.b	$F2, $E6, $7C, $00, $18, $38, $18, $18, $18, $18, $7E, $00
000016A0 7CC6 061C 78E0 FE00 7CC6+  	dc.b	$7C, $C6, $06, $1C, $78, $E0, $FE, $00, $7C, $C6, $06, $3C
000016AC 06C6 7C00 C6C6 C6C6 FE06+  	dc.b	$06, $C6, $7C, $00, $C6, $C6, $C6, $C6, $FE, $06, $06, $00
000016B8 FEC0 FC06 06C6 7C00 7CC6+  	dc.b	$FE, $C0, $FC, $06, $06, $C6, $7C, $00, $7C, $C6, $C0, $FC
000016C4 C6C6 7C00 FE06 0C18 3030+  	dc.b	$C6, $C6, $7C, $00, $FE, $06, $0C, $18, $30, $30, $30, $00
000016D0 7CC6 C67C C6C6 7C00 7CC6+  	dc.b	$7C, $C6, $C6, $7C, $C6, $C6, $7C, $00, $7C, $C6, $C6, $7E
000016DC 06C6 7C00 0060 6000 0060+  	dc.b	$06, $C6, $7C, $00, $00, $60, $60, $00, $00, $60, $60, $00
000016E8 0060 6000 6060 2000 0C18+  	dc.b	$00, $60, $60, $00, $60, $60, $20, $00, $0C, $18, $30, $60
000016F4 3018 0C00 007E 7E00 007E+  	dc.b	$30, $18, $0C, $00, $00, $7E, $7E, $00, $00, $7E, $7E, $00
00001700 3018 0C06 0C18 3000 7CC6+  	dc.b	$30, $18, $0C, $06, $0C, $18, $30, $00, $7C, $C6, $06, $1C
0000170C 3000 3000 7CC2 9AAA BCC0+  	dc.b	$30, $00, $30, $00, $7C, $C2, $9A, $AA, $BC, $C0, $7C, $00
00001718 7CC6 C6FE C6C6 C600 FCC6+  	dc.b	$7C, $C6, $C6, $FE, $C6, $C6, $C6, $00, $FC, $C6, $C6, $FC
00001724 C6C6 FC00 7CC6 C0C0 C0C6+  	dc.b	$C6, $C6, $FC, $00, $7C, $C6, $C0, $C0, $C0, $C6, $7C, $00
00001730 FCC6 C6C6 C6C6 FC00 FEC0+  	dc.b	$FC, $C6, $C6, $C6, $C6, $C6, $FC, $00, $FE, $C0, $C0, $FC
0000173C C0C0 FE00 FEC0 C0FC C0C0+  	dc.b	$C0, $C0, $FE, $00, $FE, $C0, $C0, $FC, $C0, $C0, $C0, $00
00001748 7CC6 C0DE C6C6 7C00 C6C6+  	dc.b	$7C, $C6, $C0, $DE, $C6, $C6, $7C, $00, $C6, $C6, $C6, $FE
00001754 C6C6 C600 7E18 1818 1818+  	dc.b	$C6, $C6, $C6, $00, $7E, $18, $18, $18, $18, $18, $7E, $00
00001760 0606 0606 06C6 7C00 C6C6+  	dc.b	$06, $06, $06, $06, $06, $C6, $7C, $00, $C6, $C6, $CC, $F8
0000176C CCC6 C600 C0C0 C0C0 C0C0+  	dc.b	$CC, $C6, $C6, $00, $C0, $C0, $C0, $C0, $C0, $C0, $FE, $00
00001778 82C6 EEFE D6C6 C600 C6E6+  	dc.b	$82, $C6, $EE, $FE, $D6, $C6, $C6, $00, $C6, $E6, $F6, $FE
00001784 DECE C600 7CC6 C6C6 C6C6+  	dc.b	$DE, $CE, $C6, $00, $7C, $C6, $C6, $C6, $C6, $C6, $7C, $00
00001790 FCC6 C6FC C0C0 C000 7CC6+  	dc.b	$FC, $C6, $C6, $FC, $C0, $C0, $C0, $00, $7C, $C6, $C6, $C6
0000179C D6CC 7A00 FCC6 C6FC C6C6+  	dc.b	$D6, $CC, $7A, $00, $FC, $C6, $C6, $FC, $C6, $C6, $C6, $00
000017A8 7CC6 C07C 06C6 7C00 7E18+  	dc.b	$7C, $C6, $C0, $7C, $06, $C6, $7C, $00, $7E, $18, $18, $18
000017B4 1818 1800 C6C6 C6C6 C6C6+  	dc.b	$18, $18, $18, $00, $C6, $C6, $C6, $C6, $C6, $C6, $7C, $00
000017C0 C6C6 6C6C 3838 1000 C6C6+  	dc.b	$C6, $C6, $6C, $6C, $38, $38, $10, $00, $C6, $C6, $C6, $D6
000017CC FEEE C600 C6EE 7C38 7CEE+  	dc.b	$FE, $EE, $C6, $00, $C6, $EE, $7C, $38, $7C, $EE, $C6, $00
000017D8 C6C6 C67E 06C6 7C00 FE0E+  	dc.b	$C6, $C6, $C6, $7E, $06, $C6, $7C, $00, $FE, $0E, $1C, $38
000017E4 70E0 FE00 0E0C 0C0C 0C0C+  	dc.b	$70, $E0, $FE, $00, $0E, $0C, $0C, $0C, $0C, $0C, $0E, $00
000017F0 C060 3018 0C06 0200 E060+  	dc.b	$C0, $60, $30, $18, $0C, $06, $02, $00, $E0, $60, $60, $60
000017FC 6060 E000 2070 D888 0000+  	dc.b	$60, $60, $E0, $00, $20, $70, $D8, $88, $00, $00, $00, $00
00001808 0000 0000 0000 FE00 3018+  	dc.b	$00, $00, $00, $00, $00, $00, $FE, $00, $30, $18, $08, $00
00001814 0000 0000 0000 7C06 7EC6+  	dc.b	$00, $00, $00, $00, $00, $00, $7C, $06, $7E, $C6, $7A, $00
00001820 C0C0 FCC6 C6C6 FC00 0000+  	dc.b	$C0, $C0, $FC, $C6, $C6, $C6, $FC, $00, $00, $00, $7E, $C0
0000182C C0C0 7E00 0606 7EC6 C6C6+  	dc.b	$C0, $C0, $7E, $00, $06, $06, $7E, $C6, $C6, $C6, $7E, $00
00001838 0000 7CC6 FEC0 7E00 1C30+  	dc.b	$00, $00, $7C, $C6, $FE, $C0, $7E, $00, $1C, $30, $30, $7C
00001844 3030 3000 0000 7EC6 7E06+  	dc.b	$30, $30, $30, $00, $00, $00, $7E, $C6, $7E, $06, $FC, $00
00001850 C0C0 FCC6 C6C6 C600 0018+  	dc.b	$C0, $C0, $FC, $C6, $C6, $C6, $C6, $00, $00, $18, $00, $18
0000185C 1818 1800 0006 0006 06C6+  	dc.b	$18, $18, $18, $00, $00, $06, $00, $06, $06, $C6, $7C, $00
00001868 6066 6C78 7C66 6600 1818+  	dc.b	$60, $66, $6C, $78, $7C, $66, $66, $00, $18, $18, $18, $18
00001874 1818 1800 0000 C6EE FED6+  	dc.b	$18, $18, $18, $00, $00, $00, $C6, $EE, $FE, $D6, $C6, $00
00001880 0000 FCC6 C6C6 C600 0000+  	dc.b	$00, $00, $FC, $C6, $C6, $C6, $C6, $00, $00, $00, $7C, $C6
0000188C C6C6 7C00 0000 FCC6 C6FC+  	dc.b	$C6, $C6, $7C, $00, $00, $00, $FC, $C6, $C6, $FC, $C0, $C0
00001898 0000 7EC6 C67E 0606 0000+  	dc.b	$00, $00, $7E, $C6, $C6, $7E, $06, $06, $00, $00, $DC, $E6
000018A4 C0C0 C000 0000 7EC0 7C06+  	dc.b	$C0, $C0, $C0, $00, $00, $00, $7E, $C0, $7C, $06, $FC, $00
000018B0 0030 7C30 3034 1800 0000+  	dc.b	$00, $30, $7C, $30, $30, $34, $18, $00, $00, $00, $C6, $C6
000018BC C6C6 7C00 0000 C6C6 6C38+  	dc.b	$C6, $C6, $7C, $00, $00, $00, $C6, $C6, $6C, $38, $10, $00
000018C8 0000 C6D6 FEEE C600 0000+  	dc.b	$00, $00, $C6, $D6, $FE, $EE, $C6, $00, $00, $00, $C6, $6C
000018D4 386C C600 0000 C6C6 7E06+  	dc.b	$38, $6C, $C6, $00, $00, $00, $C6, $C6, $7E, $06, $FC, $00
000018E0 0000 FE1C 3870 FE00 060C+  	dc.b	$00, $00, $FE, $1C, $38, $70, $FE, $00, $06, $0C, $0C, $18
000018EC 0C0C 0600 1818 1818 1818+  	dc.b	$0C, $0C, $06, $00, $18, $18, $18, $18, $18, $18, $18, $00
000018F8 C060 6030 6060 C000 0000+  	dc.b	$C0, $60, $60, $30, $60, $60, $C0, $00, $00, $00, $72, $DA
00001904 8C00 0000                  	dc.b	$8C, $00, $00, $00
00001908                            .DebugFontEnd:
00001908                            
00001908                            ; ---------------------------------------------------------------------------
00001908                            ; Draw text
00001908                            ; ---------------------------------------------------------------------------
00001908                            ; PARAMETERS:
00001908                            ;	a0.l - Pointer to text data
00001908                            ;	d0.l - VDP command
00001908                            ;	d1.w - Base tile ID
00001908                            ; ---------------------------------------------------------------------------
00001908                            
00001908                            DrawText:
00001908                            .LineLoop:
00001908 23C0 00C0 0004             	move.l	d0,VDPCTRL				; Set VDP command
0000190E                            
0000190E                            .CharLoop:
0000190E 7400                       	moveq	#0,d2					; Get character
00001910 1418                       	move.b	(a0)+,d2
00001912 6700                       	beq.s	.End					; If it's the termination character, branch
00001914 6B00                       	bmi.s	.NewLine				; If it's the newline character, branch
00001916                            
00001916                            	add.w	d1,d2					; Draw character
00001916                          M 	local	num
00001916 D441                     M 	axd.w	d1,d2
00001918 33C2 00C0 0000             	move.w	d2,VDPDATA
0000191E                            
0000191E 60EE                       	bra.s	.CharLoop				; Next character
00001920                            
00001920                            .NewLine:
00001920                            	addi.l	#$800000,d0				; Next line
00001920 0680 0080 0000           M 	axdi.l	#$800000,d0
00001926 60E0                       	bra.s	.LineLoop
00001928                            
00001928                            .End:
00001928 4E75                       	rts
0000192A                            
0000192A                            ; ---------------------------------------------------------------------------
0000192A                            	include	"_lib/dma.m68k"				; DMA library
0000192A                            ; ---------------------------------------------------------------------------
0000192A                            ; Mega Drive Framework
0000192A                            ; By Devon 2022
0000192A                            ; ---------------------------------------------------------------------------
0000192A                            ; Ultra DMA Queue by Flamewing
0000192A                            ; https://github.com/flamewing/ultra-dma-queue
0000192A                            ; ---------------------------------------------------------------------------
0000192A                            
0000192A                            ; ---------------------------------------------------------------------------
0000192A                            ; Queue DMA transfer
0000192A                            ; ---------------------------------------------------------------------------
0000192A                            ; OPTIONS:
0000192A                            ; 	DMA_SRC_BYTES (default 1)
0000192A                            ; 	DMA_RAM_SAFE (default 0)
0000192A                            ; 	DMA_RAM_SAFE_USE (default 1&(DMA_RAM_SAFE=0))
0000192A                            ; 	DMA_128KB_SAFE (default 0)
0000192A                            ; 	DMA_VINT_SAFE (default 0)
0000192A                            ;
0000192A                            ; With the default settings, runs in:
0000192A                            ; * 48(11/0) cycles if queue is full (DMA discarded)
0000192A                            ; * 184(29/9) cycles otherwise (DMA queued)
0000192A                            ;
0000192A                            ; With DMA_128KB_SAFE = 1, runs in:
0000192A                            ; * 48(11/0) cycles if queue is full at the start (DMA discarded)
0000192A                            ; * 200(32/9) cycles if the DMA does not cross a 128kB boundary (DMA queued)
0000192A                            ; * 226(38/9) cycles if the DMA crosses a 128kB boundary, and the first piece
0000192A                            ;   fills the queue (second piece is discarded)
0000192A                            ; * 338(56/17) cycles if the DMA crosses a 128kB boundary, and the queue has
0000192A                            ;   space for both pieces (both pieces queued)
0000192A                            ;
0000192A                            ; Setting DMA_VINT_SAFE to 1 adds 46(6/1) cycles to all times.
0000192A                            ;
0000192A                            ; Setting DMA_SRC_BYTES to 0 reduces all times by 10(1/0) cycles,
0000192A                            ; but only if the DMA is not entirely discarded. However, all callers must be
0000192A                            ; edited to make sure the adresss given is in the correct form; you can use
0000192A                            ; the dmaSource function for that, which also sanitizes RAM addresses.
0000192A                            ;
0000192A                            ; Setting DMA_RAM_SAFE to 1, or DMA_RAM_SAFE_USE to 0,
0000192A                            ; reduces all times by 14(2/0) cycles, but only if the DMA is not entirely
0000192A                            ; discarded. However, all callers must be edited to make sure the adresss given
0000192A                            ; in the correct form.
0000192A                            ; ---------------------------------------------------------------------------
0000192A                            ; PARAMETERS:
0000192A                            ;	d1.l - Source address
0000192A                            ;	d2.w - Destination address
0000192A                            ;	d3.w - Transfer size
0000192A                            ; ---------------------------------------------------------------------------
0000192A                            
0000192A                            QueueDMA:
0000192A 3278 87CC                  	movea.w	dma_queue_cur.w,a1
0000192E B2FC 87CC                  	cmpa.w	#dma_queue_cur,a1
00001932 6700                       	beq.s	.done					; Return if there's no more room in the buffer
00001934                            
00001934 E289                       		lsr.l	#1,d1				; Source address is in words for the VDP registers
00001936 0881 0017                  		bclr.l	#23,d1				; Make sure bit 23 is clear (68k->VDP DMA flag)
0000193A 03C9 0003                  	movep.l	d1,dmaSlotSrc(a1)			; Write source address; the useless top byte will be overwritten later
0000193E 7000                       	moveq	#0,d0					; We need a zero on d0
00001940                            
00001940                            	; It does not cross a 128kB boundary. So just finish writing it.
00001940 0789 0001                  	movep.w	d3,dmaSlotSize(a1)			; Write DMA length, overwriting useless top byte of source address
00001944                            
00001944                            .FinishXfer:
00001944                            	; Command to specify destination address and begin DMA
00001944 3002                       	move.w	d2,d0					; Use the fact that top word of d0 is zero to avoid clearing on VDPCMDR
00001946                            	VDPCMDR	d0,VRAM,DMA,0				; Convert destination address to VDP DMA command
00001946                          M 	local	upperbits,lowerbits
00001946 E588                     M 	lsl.l	#2,d0
00001948 =00000001                M 	upperbits:	equ (vram_dma)>>30
00001948 5240                     M 	axdq.w	#upperbits,d0
0000194A E458                     M 	ror.w	#2,d0
0000194C 4840                     M 	swap	d0
0000194E =00000080                M 	lowerbits:	equ (vram_dma)&$f0
0000194E 4AC0                     M 	tas.b	d0
00001950 43E9 000A                  	lea	dmaSlotCmd(a1),a1			; Seek to correct RAM address to store VDP DMA command
00001954 22C0                       	move.l	d0,(a1)+				; Write VDP DMA command for destination address
00001956 31C9 87CC                  	move.w	a1,dma_queue_cur.w			; Write next queue slot
0000195A                            
0000195A                            .done:
0000195A 4E75                       	rts
0000195C                            
0000195C                            ; ---------------------------------------------------------------------------
0000195C                            
0000195C                            
0000195C                            ; ---------------------------------------------------------------------------
0000195C                            ; Flush DMA queue
0000195C                            ; ---------------------------------------------------------------------------
0000195C                            
0000195C                            FlushDMAQueue:
0000195C 3038 87CC                  	move.w	dma_queue_cur.w,d0
00001960                            	subi.w	#dma_queue,d0
00001960 0440 86D0                M 	sxbi.w	#dma_queue,d0
00001964 4EFB 0000                  	jmp	.JumpTable(pc,d0.w)
00001968                            
00001968                            ; ---------------------------------------------------------------------------
00001968                            
00001968                            .JumpTable:
00001968 4E75                       	rts
0000196A                            	rept 6
0000196A                            		trap	#0				; Just in case
0000196A                            	endr
0000196A 4E40                     M 	trap	#0
0000196C 4E40                     M 	trap	#0
0000196E 4E40                     M 	trap	#0
00001970 4E40                     M 	trap	#0
00001972 4E40                     M 	trap	#0
00001974 4E40                     M 	trap	#0
00001976                            
00001976                            ; ---------------------------------------------------------------------------
00001976                            
00001976 =00000001                  	.c: = 1
00001976                            	rept DMASLOT_COUNT
00001976                            		lea	VDPCTRL,a5
00001976                            		lea	dma_queue.w,a1
00001976                            		if .c<>DMASLOT_COUNT
00001976                            			bra.w	.Jump0-(.c*8)
00001976                            		endif
00001976                            		.c: = .c+1
00001976                            	endr
00001976 4BF9 00C0 0004           M 	lea	vdpctrl,a5
0000197C 43F8 86D0                M 	lea	dma_queue.w,a1
00001980 6000 0000                M 	bra.w	.jump0-(.c*8)
00001984 =00000002                M 	.c:	= .c+1
00001984 4BF9 00C0 0004           M 	lea	vdpctrl,a5
0000198A 43F8 86D0                M 	lea	dma_queue.w,a1
0000198E 6000 0000                M 	bra.w	.jump0-(.c*8)
00001992 =00000003                M 	.c:	= .c+1
00001992 4BF9 00C0 0004           M 	lea	vdpctrl,a5
00001998 43F8 86D0                M 	lea	dma_queue.w,a1
0000199C 6000 0000                M 	bra.w	.jump0-(.c*8)
000019A0 =00000004                M 	.c:	= .c+1
000019A0 4BF9 00C0 0004           M 	lea	vdpctrl,a5
000019A6 43F8 86D0                M 	lea	dma_queue.w,a1
000019AA 6000 0000                M 	bra.w	.jump0-(.c*8)
000019AE =00000005                M 	.c:	= .c+1
000019AE 4BF9 00C0 0004           M 	lea	vdpctrl,a5
000019B4 43F8 86D0                M 	lea	dma_queue.w,a1
000019B8 6000 0000                M 	bra.w	.jump0-(.c*8)
000019BC =00000006                M 	.c:	= .c+1
000019BC 4BF9 00C0 0004           M 	lea	vdpctrl,a5
000019C2 43F8 86D0                M 	lea	dma_queue.w,a1
000019C6 6000 0000                M 	bra.w	.jump0-(.c*8)
000019CA =00000007                M 	.c:	= .c+1
000019CA 4BF9 00C0 0004           M 	lea	vdpctrl,a5
000019D0 43F8 86D0                M 	lea	dma_queue.w,a1
000019D4 6000 0000                M 	bra.w	.jump0-(.c*8)
000019D8 =00000008                M 	.c:	= .c+1
000019D8 4BF9 00C0 0004           M 	lea	vdpctrl,a5
000019DE 43F8 86D0                M 	lea	dma_queue.w,a1
000019E2 6000 0000                M 	bra.w	.jump0-(.c*8)
000019E6 =00000009                M 	.c:	= .c+1
000019E6 4BF9 00C0 0004           M 	lea	vdpctrl,a5
000019EC 43F8 86D0                M 	lea	dma_queue.w,a1
000019F0 6000 0000                M 	bra.w	.jump0-(.c*8)
000019F4 =0000000A                M 	.c:	= .c+1
000019F4 4BF9 00C0 0004           M 	lea	vdpctrl,a5
000019FA 43F8 86D0                M 	lea	dma_queue.w,a1
000019FE 6000 0000                M 	bra.w	.jump0-(.c*8)
00001A02 =0000000B                M 	.c:	= .c+1
00001A02 4BF9 00C0 0004           M 	lea	vdpctrl,a5
00001A08 43F8 86D0                M 	lea	dma_queue.w,a1
00001A0C 6000 0000                M 	bra.w	.jump0-(.c*8)
00001A10 =0000000C                M 	.c:	= .c+1
00001A10 4BF9 00C0 0004           M 	lea	vdpctrl,a5
00001A16 43F8 86D0                M 	lea	dma_queue.w,a1
00001A1A 6000 0000                M 	bra.w	.jump0-(.c*8)
00001A1E =0000000D                M 	.c:	= .c+1
00001A1E 4BF9 00C0 0004           M 	lea	vdpctrl,a5
00001A24 43F8 86D0                M 	lea	dma_queue.w,a1
00001A28 6000 0000                M 	bra.w	.jump0-(.c*8)
00001A2C =0000000E                M 	.c:	= .c+1
00001A2C 4BF9 00C0 0004           M 	lea	vdpctrl,a5
00001A32 43F8 86D0                M 	lea	dma_queue.w,a1
00001A36 6000 0000                M 	bra.w	.jump0-(.c*8)
00001A3A =0000000F                M 	.c:	= .c+1
00001A3A 4BF9 00C0 0004           M 	lea	vdpctrl,a5
00001A40 43F8 86D0                M 	lea	dma_queue.w,a1
00001A44 6000 0000                M 	bra.w	.jump0-(.c*8)
00001A48 =00000010                M 	.c:	= .c+1
00001A48 4BF9 00C0 0004           M 	lea	vdpctrl,a5
00001A4E 43F8 86D0                M 	lea	dma_queue.w,a1
00001A52 6000 0000                M 	bra.w	.jump0-(.c*8)
00001A56 =00000011                M 	.c:	= .c+1
00001A56 4BF9 00C0 0004           M 	lea	vdpctrl,a5
00001A5C 43F8 86D0                M 	lea	dma_queue.w,a1
00001A60 6000 0000                M 	bra.w	.jump0-(.c*8)
00001A64 =00000012                M 	.c:	= .c+1
00001A64 4BF9 00C0 0004           M 	lea	vdpctrl,a5
00001A6A 43F8 86D0                M 	lea	dma_queue.w,a1
00001A6E =00000013                M 	.c:	= .c+1
00001A6E                            
00001A6E                            ; ---------------------------------------------------------------------------
00001A6E                            
00001A6E                            	rept DMASLOT_COUNT
00001A6E                            		move.l	(a1)+,(a5)			; Transfer length
00001A6E                            		move.l	(a1)+,(a5)			; Source address high
00001A6E                            		move.l	(a1)+,(a5)			; Source address low + destination high
00001A6E                            		move.w	(a1)+,(a5)			; Destination low, trigger DMA
00001A6E                            	endr
00001A6E 2A99                     M 	move.l	(a1)+,(a5)
00001A70 2A99                     M 	move.l	(a1)+,(a5)
00001A72 2A99                     M 	move.l	(a1)+,(a5)
00001A74 3A99                     M 	move.w	(a1)+,(a5)
00001A76 2A99                     M 	move.l	(a1)+,(a5)
00001A78 2A99                     M 	move.l	(a1)+,(a5)
00001A7A 2A99                     M 	move.l	(a1)+,(a5)
00001A7C 3A99                     M 	move.w	(a1)+,(a5)
00001A7E 2A99                     M 	move.l	(a1)+,(a5)
00001A80 2A99                     M 	move.l	(a1)+,(a5)
00001A82 2A99                     M 	move.l	(a1)+,(a5)
00001A84 3A99                     M 	move.w	(a1)+,(a5)
00001A86 2A99                     M 	move.l	(a1)+,(a5)
00001A88 2A99                     M 	move.l	(a1)+,(a5)
00001A8A 2A99                     M 	move.l	(a1)+,(a5)
00001A8C 3A99                     M 	move.w	(a1)+,(a5)
00001A8E 2A99                     M 	move.l	(a1)+,(a5)
00001A90 2A99                     M 	move.l	(a1)+,(a5)
00001A92 2A99                     M 	move.l	(a1)+,(a5)
00001A94 3A99                     M 	move.w	(a1)+,(a5)
00001A96 2A99                     M 	move.l	(a1)+,(a5)
00001A98 2A99                     M 	move.l	(a1)+,(a5)
00001A9A 2A99                     M 	move.l	(a1)+,(a5)
00001A9C 3A99                     M 	move.w	(a1)+,(a5)
00001A9E 2A99                     M 	move.l	(a1)+,(a5)
00001AA0 2A99                     M 	move.l	(a1)+,(a5)
00001AA2 2A99                     M 	move.l	(a1)+,(a5)
00001AA4 3A99                     M 	move.w	(a1)+,(a5)
00001AA6 2A99                     M 	move.l	(a1)+,(a5)
00001AA8 2A99                     M 	move.l	(a1)+,(a5)
00001AAA 2A99                     M 	move.l	(a1)+,(a5)
00001AAC 3A99                     M 	move.w	(a1)+,(a5)
00001AAE 2A99                     M 	move.l	(a1)+,(a5)
00001AB0 2A99                     M 	move.l	(a1)+,(a5)
00001AB2 2A99                     M 	move.l	(a1)+,(a5)
00001AB4 3A99                     M 	move.w	(a1)+,(a5)
00001AB6 2A99                     M 	move.l	(a1)+,(a5)
00001AB8 2A99                     M 	move.l	(a1)+,(a5)
00001ABA 2A99                     M 	move.l	(a1)+,(a5)
00001ABC 3A99                     M 	move.w	(a1)+,(a5)
00001ABE 2A99                     M 	move.l	(a1)+,(a5)
00001AC0 2A99                     M 	move.l	(a1)+,(a5)
00001AC2 2A99                     M 	move.l	(a1)+,(a5)
00001AC4 3A99                     M 	move.w	(a1)+,(a5)
00001AC6 2A99                     M 	move.l	(a1)+,(a5)
00001AC8 2A99                     M 	move.l	(a1)+,(a5)
00001ACA 2A99                     M 	move.l	(a1)+,(a5)
00001ACC 3A99                     M 	move.w	(a1)+,(a5)
00001ACE 2A99                     M 	move.l	(a1)+,(a5)
00001AD0 2A99                     M 	move.l	(a1)+,(a5)
00001AD2 2A99                     M 	move.l	(a1)+,(a5)
00001AD4 3A99                     M 	move.w	(a1)+,(a5)
00001AD6 2A99                     M 	move.l	(a1)+,(a5)
00001AD8 2A99                     M 	move.l	(a1)+,(a5)
00001ADA 2A99                     M 	move.l	(a1)+,(a5)
00001ADC 3A99                     M 	move.w	(a1)+,(a5)
00001ADE 2A99                     M 	move.l	(a1)+,(a5)
00001AE0 2A99                     M 	move.l	(a1)+,(a5)
00001AE2 2A99                     M 	move.l	(a1)+,(a5)
00001AE4 3A99                     M 	move.w	(a1)+,(a5)
00001AE6 2A99                     M 	move.l	(a1)+,(a5)
00001AE8 2A99                     M 	move.l	(a1)+,(a5)
00001AEA 2A99                     M 	move.l	(a1)+,(a5)
00001AEC 3A99                     M 	move.w	(a1)+,(a5)
00001AEE 2A99                     M 	move.l	(a1)+,(a5)
00001AF0 2A99                     M 	move.l	(a1)+,(a5)
00001AF2 2A99                     M 	move.l	(a1)+,(a5)
00001AF4 3A99                     M 	move.w	(a1)+,(a5)
00001AF6 2A99                     M 	move.l	(a1)+,(a5)
00001AF8 2A99                     M 	move.l	(a1)+,(a5)
00001AFA 2A99                     M 	move.l	(a1)+,(a5)
00001AFC 3A99                     M 	move.w	(a1)+,(a5)
00001AFE                            
00001AFE                            .Jump0:
00001AFE                            	RESETDMA
00001AFE 31FC 86D0 87CC           M 	move.w	#dma_queue,dma_queue_cur.w
00001B04 4E75                       	rts
00001B06                            
00001B06                            ; ---------------------------------------------------------------------------
00001B06                            ; Pre-initializes the DMA queue with VDP register numbers in alternating
00001B06                            ; bytes.
00001B06                            ; Must be called before the queue is used, and the queue expects that only it
00001B06                            ; write to this region of RAM.
00001B06                            ; ---------------------------------------------------------------------------
00001B06                            
00001B06                            InitDMAQueue:
00001B06 41F8 86D0                  	lea	dma_queue.w,a0
00001B0A 7094                       	moveq	#$FFFFFF94,d0				; Fast-store $94 (sign-extended) in d0
00001B0C 223C 9397 9695             	move.l	#$93979695,d1
00001B12                            
00001B12 =00000000                  	.c: = 0
00001B12                            	rept DMASLOT_COUNT
00001B12                            		move.b	d0,.c+dmaSlotReg94(a0)
00001B12                            		movep.l	d1,.c+dmaSlotReg93(a0)
00001B12                            		.c: = .c+dmaSlotLen
00001B12                            	endr
00001B12 1080                     M 	move.b	d0,.c+dmaslotreg94(a0)
00001B14 03C8 0002                M 	movep.l	d1,.c+dmaslotreg93(a0)
00001B18 =0000000E                M 	.c:	= .c+dmaslotlen
00001B18 1140 000E                M 	move.b	d0,.c+dmaslotreg94(a0)
00001B1C 03C8 0010                M 	movep.l	d1,.c+dmaslotreg93(a0)
00001B20 =0000001C                M 	.c:	= .c+dmaslotlen
00001B20 1140 001C                M 	move.b	d0,.c+dmaslotreg94(a0)
00001B24 03C8 001E                M 	movep.l	d1,.c+dmaslotreg93(a0)
00001B28 =0000002A                M 	.c:	= .c+dmaslotlen
00001B28 1140 002A                M 	move.b	d0,.c+dmaslotreg94(a0)
00001B2C 03C8 002C                M 	movep.l	d1,.c+dmaslotreg93(a0)
00001B30 =00000038                M 	.c:	= .c+dmaslotlen
00001B30 1140 0038                M 	move.b	d0,.c+dmaslotreg94(a0)
00001B34 03C8 003A                M 	movep.l	d1,.c+dmaslotreg93(a0)
00001B38 =00000046                M 	.c:	= .c+dmaslotlen
00001B38 1140 0046                M 	move.b	d0,.c+dmaslotreg94(a0)
00001B3C 03C8 0048                M 	movep.l	d1,.c+dmaslotreg93(a0)
00001B40 =00000054                M 	.c:	= .c+dmaslotlen
00001B40 1140 0054                M 	move.b	d0,.c+dmaslotreg94(a0)
00001B44 03C8 0056                M 	movep.l	d1,.c+dmaslotreg93(a0)
00001B48 =00000062                M 	.c:	= .c+dmaslotlen
00001B48 1140 0062                M 	move.b	d0,.c+dmaslotreg94(a0)
00001B4C 03C8 0064                M 	movep.l	d1,.c+dmaslotreg93(a0)
00001B50 =00000070                M 	.c:	= .c+dmaslotlen
00001B50 1140 0070                M 	move.b	d0,.c+dmaslotreg94(a0)
00001B54 03C8 0072                M 	movep.l	d1,.c+dmaslotreg93(a0)
00001B58 =0000007E                M 	.c:	= .c+dmaslotlen
00001B58 1140 007E                M 	move.b	d0,.c+dmaslotreg94(a0)
00001B5C 03C8 0080                M 	movep.l	d1,.c+dmaslotreg93(a0)
00001B60 =0000008C                M 	.c:	= .c+dmaslotlen
00001B60 1140 008C                M 	move.b	d0,.c+dmaslotreg94(a0)
00001B64 03C8 008E                M 	movep.l	d1,.c+dmaslotreg93(a0)
00001B68 =0000009A                M 	.c:	= .c+dmaslotlen
00001B68 1140 009A                M 	move.b	d0,.c+dmaslotreg94(a0)
00001B6C 03C8 009C                M 	movep.l	d1,.c+dmaslotreg93(a0)
00001B70 =000000A8                M 	.c:	= .c+dmaslotlen
00001B70 1140 00A8                M 	move.b	d0,.c+dmaslotreg94(a0)
00001B74 03C8 00AA                M 	movep.l	d1,.c+dmaslotreg93(a0)
00001B78 =000000B6                M 	.c:	= .c+dmaslotlen
00001B78 1140 00B6                M 	move.b	d0,.c+dmaslotreg94(a0)
00001B7C 03C8 00B8                M 	movep.l	d1,.c+dmaslotreg93(a0)
00001B80 =000000C4                M 	.c:	= .c+dmaslotlen
00001B80 1140 00C4                M 	move.b	d0,.c+dmaslotreg94(a0)
00001B84 03C8 00C6                M 	movep.l	d1,.c+dmaslotreg93(a0)
00001B88 =000000D2                M 	.c:	= .c+dmaslotlen
00001B88 1140 00D2                M 	move.b	d0,.c+dmaslotreg94(a0)
00001B8C 03C8 00D4                M 	movep.l	d1,.c+dmaslotreg93(a0)
00001B90 =000000E0                M 	.c:	= .c+dmaslotlen
00001B90 1140 00E0                M 	move.b	d0,.c+dmaslotreg94(a0)
00001B94 03C8 00E2                M 	movep.l	d1,.c+dmaslotreg93(a0)
00001B98 =000000EE                M 	.c:	= .c+dmaslotlen
00001B98 1140 00EE                M 	move.b	d0,.c+dmaslotreg94(a0)
00001B9C 03C8 00F0                M 	movep.l	d1,.c+dmaslotreg93(a0)
00001BA0 =000000FC                M 	.c:	= .c+dmaslotlen
00001BA0                            
00001BA0                            	RESETDMA
00001BA0 31FC 86D0 87CC           M 	move.w	#dma_queue,dma_queue_cur.w
00001BA6 4E75                       	rts
00001BA8                            
00001BA8                            ; ---------------------------------------------------------------------------
00001BA8                            	
00001BA8                            ; ---------------------------------------------------------------------------
00001BA8                            ; Main source
00001BA8                            ; ---------------------------------------------------------------------------
00001BA8                            
00001BA8                            	include	"main.m68k"
00001BA8                            ; ---------------------------------------------------------------------------
00001BA8                            ; Mode 1 Demo
00001BA8                            ; By Devon 2022
00001BA8                            ; ---------------------------------------------------------------------------
00001BA8                            ; Main source
00001BA8                            ; ---------------------------------------------------------------------------
00001BA8                            
00001BA8                            Main:
00001BA8 4A38 87E1                  	tst.b	mcd_found.w				; Was the Mega CD found?
00001BAC 6600 0000                  	bne.w	GfxDemo					; If so, branch
00001BB0                            	
00001BB0 23FC C002 0000 00C0 0004   	move.l	#$C0020000,VDPCTRL			; Set font color
00001BBA 33FC 0EEE 00C0 0000        	move.w	#$EEE,VDPDATA
00001BC2                            
00001BC2 23FC 4400 0000 00C0 0004   	move.l	#$44000000,VDPCTRL			; Load font into VRAM
00001BCC 7001                       	moveq	#1,d0
00001BCE 6100 FA34                  	bsr.w	LoadDebugFont
00001BD2                            
00001BD2 41FA 0000                  	lea	.MCDNotFoundMsg(pc),a0			; Draw message
00001BD6 203C 440A 0003             	move.l	#$440A0003,d0
00001BDC 7200                       	moveq	#0,d1
00001BDE 6100 FD28                  	bsr.w	DrawText
00001BE2                            
00001BE2 33FC 8174 00C0 0004        	move.w	#$8174,VDPCTRL				; Enable screen
00001BEA 4E72 2700                  	stop	#$2700					; Halt
00001BEE                            
00001BEE                            ; ---------------------------------------------------------------------------
00001BEE                            
00001BEE                            .MCDNotFoundMsg:
00001BEE 5468 6973 2074 6573 7420+  	dc.b	"This test requires the Mega CD.", -1, -1
00001C0F 2020 2020 2020 2020 5072+  	dc.b	"        Program halted.", 0
00001C28 00                         	even
00001C28                            
00001C28                            ; ---------------------------------------------------------------------------
00001C28                            ; Demo program
00001C28                            ; ---------------------------------------------------------------------------
00001C28                            
00001C28                            	include	"demo/demo.m68k"
00001C28                            ; ---------------------------------------------------------------------------
00001C28                            ; Mode 1 Demo
00001C28                            ; By Devon 2022
00001C28                            ; ---------------------------------------------------------------------------
00001C28                            ; Demo program
00001C28                            ; ---------------------------------------------------------------------------
00001C28                            
00001C28                            	include	"subcpu/gfxdef.i"
00001C28                            ; ---------------------------------------------------------------------------
00001C28                            ; Mode 1 Demo
00001C28                            ; By Devon 2022
00001C28                            ; ---------------------------------------------------------------------------
00001C28                            ; Graphics definitions
00001C28                            ; ---------------------------------------------------------------------------
00001C28                            
00001C28 =00000000                  STAMP_DATA	EQU	$00000			; Stamp data location in Word RAM
00001C28 =00010000                  STAMP_MAP	EQU	$10000			; Stamp map location in Word RAM
00001C28 =00020000                  TRACE_TABLE	EQU	$20000			; Trace table location in Word RAM
00001C28 =00030000                  IMG_BUFFER	EQU	$30000			; Image buffer location in Word RAM
00001C28                            
00001C28 =00000100                  IMG_WIDTH	EQU	256			; Image buffer width
00001C28 =00000070                  IMG_HEIGHT	EQU	112			; Image buffer height
00001C28 =000000A0                  IMG_FOV		EQU	160			; FOV
00001C28 =0000000E                  IMG_TILE_H	EQU	(IMG_HEIGHT+((7-(IMG_HEIGHT&7))&7))/8
00001C28 =00003800                  IMG_SIZE	EQU	(IMG_WIDTH/8)*(IMG_HEIGHT/8)*$20
00001C28                            
00001C28                            ; -------------------------------------------------------------------------
00001C28                            
00001C28                            ; -------------------------------------------------------------------------
00001C28                            ; Variables
00001C28                            ; -------------------------------------------------------------------------
00001C28                            
00001C28                            	rsset	local_vars
00001C28 =FFFF87EA                  scale		rs.w	1			; Scale value
00001C28 =FFFF87EC                  gfx_done	rs.b	1			; Graphics done flag
00001C28 =FFFF87ED                  buffer_id	rs.b	1			; Buffer ID
00001C28 =FFFF87EE                  frame_count	rs.w	1			; Frame count
00001C28                            
00001C28 =FFFF87F0                  camera_x	rs.w	1			; Camera X
00001C28 =FFFF87F2                  camera_y	rs.w	1			; Camera Y
00001C28 =FFFF87F4                  camera_z	rs.w	1			; Camera Z
00001C28 =FFFF87F6                  camera_angle	rs.w	1			; Camera angle
00001C28                            
00001C28 =FFFF87F8                  is_kega		rs.b	1			; Kega Fusion flag
00001C28                            
00001C28                            ; -------------------------------------------------------------------------
00001C28                            ; Demo routine
00001C28                            ; -------------------------------------------------------------------------
00001C28                            
00001C28                            GfxDemo:
00001C28 3039 00C0 001C             	move	VDPDEBUG,d0			; Check if Kega Fusion
00001C2E 0C40 FFFF                  	cmpi.w	#$FFFF,d0
00001C32 57F8 87F8                  	seq	is_kega.w
00001C36                            
00001C36 2078 87E2                  	movea.l	mcd_sub_bios.w,a0		; Initialize Sub CPU
00001C3A 43FA 0000                  	lea	SubCPUPrg(pc),a1
00001C3E 203C 0000 0000             	move.l	#SubCPUPrg_End-SubCPUPrg,d0
00001C44 6100 F74C                  	bsr.w	InitSubCPU
00001C48                            
00001C48 31FC 4EF9 87DA             	move.w	#$4EF9,vblank_int.w		; Set up dummy V-INT
00001C4E 21FC 0000 0000 87DC        	move.l	#VInt_Dummy,vblank_int+2.w
00001C56 33FC 8134 00C0 0004        	move.w	#$8134,VDPCTRL			; Disable display and enable V-INT
00001C5E 46FC 2000                  	move	#$2000,sr			; Enable interrupts
00001C62                            
00001C62 13FC 0052 00A1 200E        	move.b	#"R",MAINFLAG			; Tell Sub CPU that security code is done running
00001C6A                            
00001C6A                            .Wait:
00001C6A 0C39 0047 00A1 200F        	cmpi.b	#"G",SUBFLAG			; Wait for the Sub CPU to finish initializing
00001C72 66F6                       	bne.s	.Wait
00001C74                            
00001C74 4239 00A1 200E             	clr.b	MAINFLAG			; Mark as ready for commands
00001C7A                            
00001C7A                            .Wait2:
00001C7A 0C39 0052 00A1 200F        	cmpi.b	#"R",SUBFLAG			; Wait for the Sub CPU to get ready to send commands
00001C82 66F6                       	bne.s	.Wait2
00001C84                            	
00001C84 46FC 2700                  	move	#$2700,sr			; Disable interrupts
00001C88 21FC 0000 0000 87DC        	move.l	#VInt_Gfx,vblank_int+2.w	; Set vertical interrupt
00001C90                            
00001C90 31FC 3000 87F0             	move.w	#$3000,camera_x.w		; Setu p camera
00001C96 31FC 4000 87F2             	move.w	#$4000,camera_y.w
00001C9C 31FC 3000 87F4             	move.w	#$3000,camera_z.w
00001CA2                            
00001CA2 33FC 8238 00C0 0004        	move.w	#$8200|($E000/$400),VDPCTRL	; Set plane A to same address as plane B
00001CAA 33FC 857C 00C0 0004        	move.w	#$8500|($F800/$200),VDPCTRL	; Set sprite table to $F800
00001CB2 33FC 8B00 00C0 0004        	move.w	#$8B00,VDPCTRL			; Scroll by screen
00001CBA 33FC 8C00 00C0 0004        	move.w	#$8C00,VDPCTRL			; H32 mode
00001CC2 33FC 8D3F 00C0 0004        	move.w	#$8D00|($FC00/$400),VDPCTRL	; Set HScroll table to $FC00
00001CCA                            
00001CCA 41F9 0000 0000             	lea	GfxStamps,a0			; Load stamp data
00001CD0 43F9 0060 0000             	lea	WORDRAM+STAMP_DATA,a1
00001CD6 6100 F68C                  	bsr.w	CompDec
00001CDA                            	
00001CDA 41F9 0000 0000             	lea	GfxStampMap,a0			; Load stamp map
00001CE0 43F9 0061 0000             	lea	WORDRAM+STAMP_MAP,a1
00001CE6 6100 F67C                  	bsr.w	CompDec
00001CEA                            
00001CEA 41F9 0000 0000             	lea	GfxPalette,a0			; Load palette
00001CF0 43F8 8000                  	lea	palette.w,a1
00001CF4 7007                       	moveq	#$20/4-1,d0
00001CF6                            
00001CF6                            .LoadPal:
00001CF6 22D8                       	move.l	(a0)+,(a1)+
00001CF8 51C8 FFFC                  	dbf	d0,.LoadPal
00001CFC                            
00001CFC 203C 6780 0003             	move.l	#$67800003,d0			; Load tilemap
00001D02 7801                       	moveq	#1,d4				; (Tiles are arranged vertically)
00001D04 7A01                       	moveq	#2-1,d5
00001D06 33FC 8F80 00C0 0004        	move.w	#$8F80,VDPCTRL
00001D0E                            
00001D0E                            .LoadMap:
00001D0E 721F                       	moveq	#IMG_WIDTH/8-1,d1
00001D10 740D                       	moveq	#IMG_HEIGHT/8-1,d2
00001D12                            
00001D12                            .MapCol:
00001D12 23C0 00C0 0004             	move.l	d0,VDPCTRL
00001D18                            	add.l	#$20000,d0
00001D18                          M 	local	num
00001D18 0680 0002 0000           M 	axd.l	#$20000,d0
00001D1E 3602                       	move.w	d2,d3
00001D20                            
00001D20                            .MapTile:
00001D20 33C4 00C0 0000             	move.w	d4,VDPDATA
00001D26                            	addq.w	#1,d4
00001D26 5244                     M 	axdq.w	#1,d4
00001D28 51CB FFF6                  	dbf	d3,.MapTile
00001D2C 51C9 FFE4                  	dbf	d1,.MapCol
00001D30                            
00001D30 203C 67C0 0003             	move.l	#$67C00003,d0
00001D36 51CD FFD6                  	dbf	d5,.LoadMap
00001D3A 33FC 8F02 00C0 0004        	move.w	#$8F02,VDPCTRL
00001D42                            
00001D42 23FC 4000 0010 00C0 0004   	move.l	#$40000010,VDPCTRL		; Move to top of map
00001D4C 23FC 0008 0008 00C0 0000   	move.l	#$00080008,VDPDATA
00001D56                            
00001D56                            ; -------------------------------------------------------------------------
00001D56                            
00001D56                            .Loop:
00001D56 6100 0000                  	bsr.w	VSync				; VSync
00001D5A                            
00001D5A                            	addi.w	#$20,camera_x.w			; Move camera
00001D5A 0678 0020 87F0           M 	axdi.w	#$20,camera_x.w
00001D60                            	addi.w	#$20,camera_z.w
00001D60 0678 0020 87F4           M 	axdi.w	#$20,camera_z.w
00001D66                            	addq.w	#2,camera_angle.w
00001D66 5478 87F6                M 	axdq.w	#2,camera_angle.w
00001D6A                            
00001D6A 3038 87F0                  	move.w	camera_x.w,d0			; Start rendering
00001D6E 3238 87F2                  	move.w	camera_y.w,d1
00001D72 3438 87F4                  	move.w	camera_z.w,d2
00001D76 3638 87F6                  	move.w	camera_angle.w,d3
00001D7A 6100                       	bsr.s	GfxRender
00001D7C                            
00001D7C                            .WaitGfx:
00001D7C 6100                       	bsr.s	CheckGfx			; Wait until graphics are done
00001D7E 66FC                       	bne.s	.WaitGfx
00001D80 11FC 0001 87EC             	move.b	#1,gfx_done.w			; Mark graphics as done
00001D86                            
00001D86 6000 FFCE                  	bra.w	.Loop				; Loop
00001D8A                            
00001D8A                            ; -------------------------------------------------------------------------
00001D8A                            ; Start graphics rendering
00001D8A                            ; -------------------------------------------------------------------------
00001D8A                            ; PARAMETERS:
00001D8A                            ;	d0.w - Camera X
00001D8A                            ;	d1.w - Camera Y
00001D8A                            ;	d2.w - Camera Z
00001D8A                            ;	d3.w - Camera angle
00001D8A                            ; -------------------------------------------------------------------------
00001D8A                            
00001D8A                            GfxRender:
00001D8A 33C0 00A1 2010             	move.w	d0,MAINCOM0			; Start graphics rendering
00001D90 33C1 00A1 2012             	move.w	d1,MAINCOM1
00001D96 33C2 00A1 2014             	move.w	d2,MAINCOM2
00001D9C 33C3 00A1 2016             	move.w	d3,MAINCOM3
00001DA2 7001                       	moveq	#1,d0
00001DA4 6100 0000                  	bsr.w	SubCPUCmd
00001DA8 6000 0000                  	bra.w	SubCPUCmd_Wait
00001DAC                            
00001DAC                            ; -------------------------------------------------------------------------
00001DAC                            ; Check graphics status
00001DAC                            ; -------------------------------------------------------------------------
00001DAC                            ; RETURNS:
00001DAC                            ;	eq/ne	- Inactive/Busy
00001DAC                            ; -------------------------------------------------------------------------
00001DAC                            
00001DAC                            CheckGfx:
00001DAC 7002                       	moveq	#2,d0				; Check graphics status
00001DAE 6100 0000                  	bsr.w	SubCPUCmd
00001DB2 6100 0000                  	bsr.w	SubCPUCmd_Wait
00001DB6 4A79 00A1 2020             	tst.w	SUBCOM0
00001DBC 4E75                       	rts
00001DBE                            
00001DBE                            ; -------------------------------------------------------------------------
00001DBE                            ; Dummy vertical interrupt
00001DBE                            ; -------------------------------------------------------------------------
00001DBE                            
00001DBE                            VInt_Dummy:
00001DBE 08F9 0000 00A1 2000        	bset	#0,MCDINT2			; Send interrupt request
00001DC6 4E73                       	rte
00001DC8                            
00001DC8                            ; -------------------------------------------------------------------------
00001DC8                            ; Vertical interrupt
00001DC8                            ; -------------------------------------------------------------------------
00001DC8                            
00001DC8                            VInt_Gfx:
00001DC8 08F9 0000 00A1 2000        	bset	#0,MCDINT2			; Send interrupt request
00001DD0                            	
00001DD0 46FC 2700                  	move	#$2700,sr			; Disable interrupts
00001DD4 48E7 FFFE                  	movem.l	d0-a6,-(sp)			; Push all registers
00001DD8                            	
00001DD8                            	Z80STOP					; Stop Z80
00001DD8                          M 	z80req
00001DD8 33FC 0100 00A1 1100      M 	move.w	#$100,z80bus
00001DE0                          M 	z80wait
00001DE0                          M .wait_152:
00001DE0 0839 0000 00A1 1100      M 	btst	#0,z80bus
00001DE8 66F6                     M 	bne.s	.wait_152
00001DEA                            	
00001DEA 4DF9 00C0 0004             	lea	VDPCTRL,a6			; VDP control
00001DF0                            	DMA68K	palette,0,$80,CRAM,a6		; Transfer palette data
00001DF0 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
00001DF6 2CBC 96C0 9500           M 	move.l	#$96009500|((((palette)/2)&$ff00)<<8)|(((palette)/2)&$ff),(a6)
00001DFC 3CBC 977F                M 	move.w	#$9700|(((palette)>>17)&$7f),(a6)
00001E00                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00001E00                          M 	local	cmd
00001E00 =C0000080                M 	cmd:	= (cram_dma)|(((0)&$3fff)<<16)|((0)/$4000)
00001E00 3CBC C000                M 	move.w	#$c0000080>>16,(a6)
00001E04                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
00001E04                          M 	local	cmd
00001E04 =C0000080                M 	cmd:	= (cram_dma)|(((0)&$3fff)<<16)|((0)/$4000)
00001E04 3F3C 0080                M 	move.w	#$c0000080&$ffff,-(sp)
00001E08 3C9F                     M 	move.w	(sp)+,(a6)
00001E0A                            	
00001E0A 08B8 0000 87EC             	bclr	#0,gfx_done.w			; Transfer graphics data
00001E10 6700 0000                  	beq.w	.NoGfx
00001E14                            
00001E14 4A38 87F8                  	tst.b	is_kega.w
00001E18 6700                       	beq.s	.NotKega
00001E1A                            	
00001E1A 4A38 87ED                  	tst.b	buffer_id.w
00001E1E 6700                       	beq.s	.KegaBuffer0
00001E20                            	DMA68K	WORDRAM+IMG_BUFFER+2-$400000,$20,IMG_SIZE,VRAM,a6
00001E20 2CBC 941C 9300           M 	move.l	#$94009300|((((img_size)/2)&$ff00)<<8)|(((img_size)/2)&$ff),(a6)
00001E26 2CBC 9680 9501           M 	move.l	#$96009500|((((wordram+img_buffer+2-$400000)/2)&$ff00)<<8)|(((wordram+img_buffer+2-$400000)/2)&$ff),(a6)
00001E2C 3CBC 9711                M 	move.w	#$9700|(((wordram+img_buffer+2-$400000)>>17)&$7f),(a6)
00001E30                          M 	vdpcmd	move.w,$20,vram,dma,>>16,(a6)
00001E30                          M 	local	cmd
00001E30 =40200080                M 	cmd:	= (vram_dma)|((($20)&$3fff)<<16)|(($20)/$4000)
00001E30 3CBC 4020                M 	move.w	#$40200080>>16,(a6)
00001E34                          M 	vdpcmd	move.w,$20,vram,dma,&$ffff,-(sp)
00001E34                          M 	local	cmd
00001E34 =40200080                M 	cmd:	= (vram_dma)|((($20)&$3fff)<<16)|(($20)/$4000)
00001E34 3F3C 0080                M 	move.w	#$40200080&$ffff,-(sp)
00001E38 3C9F                     M 	move.w	(sp)+,(a6)
00001E3A                            	VDPCMD	move.l,$20,VRAM,WRITE,(a6)
00001E3A                          M 	local	cmd
00001E3A =40200000                M 	cmd:	= (vram_write)|((($20)&$3fff)<<16)|(($20)/$4000)
00001E3A 2CBC 4020 0000           M 	move.l	#$40200000,(a6)
00001E40 2D79 0063 0000 FFFC        	move.l	WORDRAM+IMG_BUFFER,-4(a6)
00001E48 6000 0000                  	bra.w	.GfxDone
00001E4C                            
00001E4C                            .KegaBuffer0:
00001E4C                            	DMA68K	WORDRAM+IMG_BUFFER+2-$400000,$20+IMG_SIZE,IMG_SIZE,VRAM,a6
00001E4C 2CBC 941C 9300           M 	move.l	#$94009300|((((img_size)/2)&$ff00)<<8)|(((img_size)/2)&$ff),(a6)
00001E52 2CBC 9680 9501           M 	move.l	#$96009500|((((wordram+img_buffer+2-$400000)/2)&$ff00)<<8)|(((wordram+img_buffer+2-$400000)/2)&$ff),(a6)
00001E58 3CBC 9711                M 	move.w	#$9700|(((wordram+img_buffer+2-$400000)>>17)&$7f),(a6)
00001E5C                          M 	vdpcmd	move.w,$20+img_size,vram,dma,>>16,(a6)
00001E5C                          M 	local	cmd
00001E5C =78200080                M 	cmd:	= (vram_dma)|((($20+img_size)&$3fff)<<16)|(($20+img_size)/$4000)
00001E5C 3CBC 7820                M 	move.w	#$78200080>>16,(a6)
00001E60                          M 	vdpcmd	move.w,$20+img_size,vram,dma,&$ffff,-(sp)
00001E60                          M 	local	cmd
00001E60 =78200080                M 	cmd:	= (vram_dma)|((($20+img_size)&$3fff)<<16)|(($20+img_size)/$4000)
00001E60 3F3C 0080                M 	move.w	#$78200080&$ffff,-(sp)
00001E64 3C9F                     M 	move.w	(sp)+,(a6)
00001E66                            	VDPCMD	move.l,$20+IMG_SIZE,VRAM,WRITE,(a6)
00001E66                          M 	local	cmd
00001E66 =78200000                M 	cmd:	= (vram_write)|((($20+img_size)&$3fff)<<16)|(($20+img_size)/$4000)
00001E66 2CBC 7820 0000           M 	move.l	#$78200000,(a6)
00001E6C 2D79 0063 0000 FFFC        	move.l	WORDRAM+IMG_BUFFER,-4(a6)
00001E74 6000                       	bra.s	.GfxDone
00001E76                            
00001E76                            .NotKega:
00001E76 4A38 87ED                  	tst.b	buffer_id.w
00001E7A 6700                       	beq.s	.NotKegaBuffer0
00001E7C                            	DMA68K	WORDRAM+IMG_BUFFER+2,$20,IMG_SIZE,VRAM,a6
00001E7C 2CBC 941C 9300           M 	move.l	#$94009300|((((img_size)/2)&$ff00)<<8)|(((img_size)/2)&$ff),(a6)
00001E82 2CBC 9680 9501           M 	move.l	#$96009500|((((wordram+img_buffer+2)/2)&$ff00)<<8)|(((wordram+img_buffer+2)/2)&$ff),(a6)
00001E88 3CBC 9731                M 	move.w	#$9700|(((wordram+img_buffer+2)>>17)&$7f),(a6)
00001E8C                          M 	vdpcmd	move.w,$20,vram,dma,>>16,(a6)
00001E8C                          M 	local	cmd
00001E8C =40200080                M 	cmd:	= (vram_dma)|((($20)&$3fff)<<16)|(($20)/$4000)
00001E8C 3CBC 4020                M 	move.w	#$40200080>>16,(a6)
00001E90                          M 	vdpcmd	move.w,$20,vram,dma,&$ffff,-(sp)
00001E90                          M 	local	cmd
00001E90 =40200080                M 	cmd:	= (vram_dma)|((($20)&$3fff)<<16)|(($20)/$4000)
00001E90 3F3C 0080                M 	move.w	#$40200080&$ffff,-(sp)
00001E94 3C9F                     M 	move.w	(sp)+,(a6)
00001E96                            	VDPCMD	move.l,$20,VRAM,WRITE,(a6)
00001E96                          M 	local	cmd
00001E96 =40200000                M 	cmd:	= (vram_write)|((($20)&$3fff)<<16)|(($20)/$4000)
00001E96 2CBC 4020 0000           M 	move.l	#$40200000,(a6)
00001E9C 2D79 0063 0000 FFFC        	move.l	WORDRAM+IMG_BUFFER,-4(a6)
00001EA4 6000                       	bra.s	.GfxDone
00001EA6                            
00001EA6                            .NotKegaBuffer0:
00001EA6                            	DMA68K	WORDRAM+IMG_BUFFER+2,$20+IMG_SIZE,IMG_SIZE,VRAM,a6
00001EA6 2CBC 941C 9300           M 	move.l	#$94009300|((((img_size)/2)&$ff00)<<8)|(((img_size)/2)&$ff),(a6)
00001EAC 2CBC 9680 9501           M 	move.l	#$96009500|((((wordram+img_buffer+2)/2)&$ff00)<<8)|(((wordram+img_buffer+2)/2)&$ff),(a6)
00001EB2 3CBC 9731                M 	move.w	#$9700|(((wordram+img_buffer+2)>>17)&$7f),(a6)
00001EB6                          M 	vdpcmd	move.w,$20+img_size,vram,dma,>>16,(a6)
00001EB6                          M 	local	cmd
00001EB6 =78200080                M 	cmd:	= (vram_dma)|((($20+img_size)&$3fff)<<16)|(($20+img_size)/$4000)
00001EB6 3CBC 7820                M 	move.w	#$78200080>>16,(a6)
00001EBA                          M 	vdpcmd	move.w,$20+img_size,vram,dma,&$ffff,-(sp)
00001EBA                          M 	local	cmd
00001EBA =78200080                M 	cmd:	= (vram_dma)|((($20+img_size)&$3fff)<<16)|(($20+img_size)/$4000)
00001EBA 3F3C 0080                M 	move.w	#$78200080&$ffff,-(sp)
00001EBE 3C9F                     M 	move.w	(sp)+,(a6)
00001EC0                            	VDPCMD	move.l,$20+IMG_SIZE,VRAM,WRITE,(a6)
00001EC0                          M 	local	cmd
00001EC0 =78200000                M 	cmd:	= (vram_write)|((($20+img_size)&$3fff)<<16)|(($20+img_size)/$4000)
00001EC0 2CBC 7820 0000           M 	move.l	#$78200000,(a6)
00001EC6 2D79 0063 0000 FFFC        	move.l	WORDRAM+IMG_BUFFER,-4(a6)
00001ECE                            
00001ECE                            .GfxDone:
00001ECE 4638 87ED                  	not.b	buffer_id.w			; Swap buffer
00001ED2 6600                       	bne.s	.HScrollBuf1
00001ED4 2CBC 7C00 0003             	move.l	#$7C000003,(a6)
00001EDA 2D7C 0000 0000 FFFC        	move.l	#$00000000,-4(a6)
00001EE2 6000                       	bra.s	.Display
00001EE4                            
00001EE4                            .HScrollBuf1:
00001EE4 2CBC 7C00 0003             	move.l	#$7C000003,(a6)
00001EEA 2D7C 0100 0100 FFFC        	move.l	#$01000100,-4(a6)
00001EF2                            
00001EF2                            .Display:
00001EF2 3CBC 8174                  	move.w	#$8174,(a6)			; Enable display
00001EF6                            
00001EF6                            .NoGfx:
00001EF6                            	Z80START				; Start Z80
00001EF6 33FC 0000 00A1 1100      M 	move.w	#0,z80bus
00001EFE                            
00001EFE                            	addq.w	#1,frame_count.w		; Increment frame count
00001EFE 5278 87EE                M 	axdq.w	#1,frame_count.w
00001F02 4CDF 7FFF                  	movem.l	(sp)+,d0-a6			; Pop all registers
00001F06 4E73                       	rte
00001F08                            
00001F08                            ; -------------------------------------------------------------------------
00001F08                            ; VSync
00001F08                            ; -------------------------------------------------------------------------
00001F08                            
00001F08                            VSync:
00001F08 46FC 2000                  	move	#$2000,sr			; Enable interrupts
00001F0C 3038 87EE                  	move.w	frame_count.w,d0		; Get frame count
00001F10                            
00001F10                            .Wait:
00001F10 B078 87EE                  	cmp.w	frame_count.w,d0		; Did it change?
00001F14 67FA                       	beq.s	.Wait				; If not, wait
00001F16 4E75                       	rts
00001F18                            
00001F18                            ; -------------------------------------------------------------------------
00001F18                            ; Send a command to the Sub CPU
00001F18                            ; -------------------------------------------------------------------------
00001F18                            ; PARAMETERS
00001F18                            ;	d0.b - Command ID
00001F18                            ; -------------------------------------------------------------------------
00001F18                            
00001F18                            SubCPUCmd:
00001F18 08F9 0001 00A1 2003        	bset	#1,MCDMEMMODE			; Give Word RAM access to the Sub CPU
00001F20 67F6                       	beq.s	SubCPUCmd
00001F22                            
00001F22 13C0 00A1 200E             	move.b	d0,MAINFLAG			; Set command
00001F28                            
00001F28                            .WaitSub:
00001F28 0C39 0042 00A1 200F        	cmpi.b	#"B",SUBFLAG			; Did the Sub CPU get it?
00001F30 66F6                       	bne.s	.WaitSub			; If so, branch
00001F32                            
00001F32 4239 00A1 200E             	clr.b	MAINFLAG			; Reset command
00001F38 4E75                       	rts
00001F3A                            
00001F3A                            ; -------------------------------------------------------------------------
00001F3A                            ; Wait for a Sub CPU command to finish
00001F3A                            ; -------------------------------------------------------------------------
00001F3A                            
00001F3A                            SubCPUCmd_Wait:
00001F3A 0C39 0052 00A1 200F        	cmpi.b	#"R",SUBFLAG			; Is the Sub CPU finished?
00001F42 66F6                       	bne.s	SubCPUCmd_Wait			; If not, branch
00001F44 4E75                       	rts
00001F46                            
00001F46                            ; -------------------------------------------------------------------------
00001F46                            ; Sub CPU program
00001F46                            ; -------------------------------------------------------------------------
00001F46                            
00001F46                            SubCPUPrg:
00001F46                            	incbin	"subcpu/_out/sp.bin"
0000BA18                            SubCPUPrg_End:
0000BA18                            	even
0000BA18                            
0000BA18                            ; -------------------------------------------------------------------------
0000BA18                            ; Data
0000BA18                            ; -------------------------------------------------------------------------
0000BA18                            
0000BA18                            GfxStamps:
0000BA18                            	incbin	"demo/data/stamps.comp"
0001140A                            	even
0001140A                            
0001140A                            GfxStampMap:
0001140A                            	incbin	"demo/data/stampmap.comp"
00011FA2                            GfxStampMap_End:
00011FA2                            	even
00011FA2                            
00011FA2                            GfxPalette:
00011FA2                            	incbin	"demo/data/palette.bin"
00011FC2                            	even
00011FC2                            
00011FC2                            ; -------------------------------------------------------------------------
00011FC2                            	;include	"demo/test.m68k"
00011FC2                            
00011FC2                            ; ---------------------------------------------------------------------------
00011FC2                            
00011FC2                            ; ---------------------------------------------------------------------------
